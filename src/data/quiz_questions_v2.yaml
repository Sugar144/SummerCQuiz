weeks:
  - number: 1
    explanation: |
      Explicación de semana 1
    levels:
      ## Declaración, inicialización y asignación de variables y constantes
      - number: 1
        explanation:
          C: |
            En este nivel aprenderás a **declarar constantes y variables en C**, entender la diferencia entre ambas, y cómo usarlas en un programa con temática de videojuegos.

            ### Constantes con `#define` (preprocesador)
            Sirven para definir valores constantes globales sin tipo.  
            Son reemplazadas por su valor antes de compilar y no ocupan memoria.  
            No llevan `;` al final.  

            ```c
            #define MAX_JUGADORES 4
            #define PUNTOS_VICTORIA 1000

            int main() {
                return 0;
            }
            ```

            En un videojuego, `MAX_JUGADORES` puede representar el número máximo de jugadores en una partida multijugador, y `PUNTOS_VICTORIA` la puntuación necesaria para ganar.

            ---

            ### Constantes locales con `const` (con tipo)
            Se definen dentro de una función, tienen tipo y deben inicializarse al declararse.  

            ```c
            int main() {
                const float VELOCIDAD_JUGADOR = 5.5;
                const int VIDAS_INICIALES = 3;
                return 0;
            }
            ```

            Aquí `VELOCIDAD_JUGADOR` podría representar la velocidad base de un personaje y `VIDAS_INICIALES` el número de vidas con las que empieza un jugador.

            ---

            ### Declaración de variables
            Las variables se usan para almacenar datos que pueden cambiar durante el juego.  
            Cada tipo se declara con una palabra clave:

            - `int` → enteros  
            - `float` → decimales  
            - `bool` → booleanos (requiere `#include <stdbool.h>`)  
            - `char` → un carácter individual  
            - `char[]` → cadenas de caracteres con tamaño fijo  

            ```c
            int main() {
                int puntuacion;
                float energia;
                bool nivelCompletado;
                char inicialJugador;
                char nombreJugador[30];
                return 0;
            }
            ```

            ---

            ### Inicialización y asignación
            Puedes **inicializar al declarar**:

            ```c
            int main() {
                int puntuacion = 500;
                float energia = 5.5;
                char inicialJugador = 'L';
                char nombreJugador[30] = "Link";
                return 0;
            }
            ```

            O **declarar primero y asignar después**:

            ```c
            int main() {
                int puntuacion;
                puntuacion = 500;

                float energia;
                energia = 5.5;

                char inicialJugador;
                inicialJugador = 'L';

                return 0;
            }
            ```

            ---

            ### Ejemplo completo
            ```c
            #include <stdio.h>
            #include <stdbool.h>
            #define MAX_JUGADORES 4
            #define PUNTOS_VICTORIA 1000

            int main() {
                const float VELOCIDAD_JUGADOR = 5.5;
                const int VIDAS_INICIALES = 3;

                int puntuacion = 500;
                float energia = VELOCIDAD_JUGADOR;
                bool nivelCompletado = false;
                char inicialJugador = 'L';
                char nombreJugador[30] = "Link";

                printf("Jugador %c (%s) empieza con %d vidas y velocidad %.1f.\n", 
                       inicialJugador, nombreJugador, VIDAS_INICIALES, VELOCIDAD_JUGADOR);
                return 0;
            }
            ```

            Este programa inicializa un jugador con nombre, vidas y velocidad para una partida.

          Pseudocode: |
            En este nivel aprenderás a **declarar constantes y variables en pseudocódigo**, entender su diferencia, y cómo usarlas en un programa con temática de videojuegos.

            ### Constantes
            Se definen en un bloque `const ... end const`, indicando tipo y valor.  
            Representan valores que no cambian durante la ejecución del programa.

            ```pseudocode
            const
              MAX_JUGADORES: integer = 4;
              PUNTOS_VICTORIA: integer = 1000;
              VELOCIDAD_JUGADOR: real = 5.5;
              VIDAS_INICIALES: integer = 3;
            end const
            ```

            Aquí `MAX_JUGADORES` define el número máximo de jugadores en una partida y `PUNTOS_VICTORIA` los puntos necesarios para ganar.

            ---

            ### Variables
            Se declaran en un bloque `var ... end var` dentro del algoritmo principal.  
            No se pueden inicializar en la misma línea de la declaración.

            ```pseudocode
            algorithm
              var
                puntuacion: integer;
                energia: real;
                nivelCompletado: boolean;
                inicialJugador: character;
                nombreJugador: string;
              end var
            end algorithm
            ```

            ---

            ### Asignación de valores
            Después de declararlas, se asigna valor con `:=`.

            ```pseudocode
            algorithm
              var
                puntuacion: integer;
                energia: real;
                nivelCompletado: boolean;
                inicialJugador: character;
                nombreJugador: string;
              end var

              puntuacion := 500;
              energia := VELOCIDAD_JUGADOR;
              nivelCompletado := false;
              inicialJugador := 'L';
              nombreJugador := "Link";
            end algorithm
            ```

            ---

            ### Tipos básicos
            - `integer` → enteros  
            - `real` → decimales  
            - `boolean` → `true` o `false`  
            - `character` → un solo carácter, ej. `'A'`  
            - `string` → cadenas de texto  

            ---

            ### Ejemplo completo
            ```pseudocode
            const
              MAX_JUGADORES: integer = 4;
              PUNTOS_VICTORIA: integer = 1000;
              VELOCIDAD_JUGADOR: real = 5.5;
              VIDAS_INICIALES: integer = 3;
            end const

            algorithm partidaVideojuego
              var
                puntuacion: integer;
                energia: real;
                nivelCompletado: boolean;
                inicialJugador: character;
                nombreJugador: string;
              end var

              puntuacion := 500;
              energia := VELOCIDAD_JUGADOR;
              nivelCompletado := false;
              inicialJugador := 'L';
              nombreJugador := "Link";

              writeString("Jugador ");
              writeCharacter(inicialJugador);
              writeString(" (");
              writeString(nombreJugador);
              writeString(") empieza con ");
              writeInteger(VIDAS_INICIALES);
              writeString(" vidas y velocidad ");
              writeReal(VELOCIDAD_JUGADOR);
            end algorithm
            ```

            Este algoritmo simula la inicialización de un jugador al comenzar una partida.

        questions:
          - id: c-1-max_nombre
            language: C
            week: 1
            prompt: Usando la directiva define, declara una constante para el máximo de un nombre "MAX_NOMBRE" con el valor entero 20.
            answer: '#define MAX_NOMBRE 20'
            hint:

          - id: c-1-max_drones
            language: Pseudocode
            week: 1
            prompt: Declara una constante para el máximo de drones "MAX_DRONES" con el valor entero 5.
            answer: '#define MAX_DRONES 5'
            hint:

          - id: p-1-max_drones
            language: Pseudocode
            week: 1
            prompt: Declara una constante para el máximo de drones "MAX_DRONES" con el valor entero 5.
            answer: |-
              const
                  MAX_DRONES: integer = 5;
              end const
            hint:

          - id: c-1-const_decimal
            language: C
            week: 1
            prompt: Declara una constante local de tipo decimal para la distancia mínima "DISTANCIA_MINIMA", asignale el valor 250.0.
            answer: |
              int main(){
                const float DISTANCIA_MINIMA = 250.0;
                return 0;
              }
            hint: Las constantes locales comienzan por const.

          - id: p-1-const_decimal
            language: Pseudocode
            week: 1
            prompt: Declara una constante de tipo decimal para la distancia mínima "DISTANCIA_MINIMA", asignale el valor 250.0.
            answer: |-
              const
                DISTANCIA_MINIMA: real = 250.0;
              end const
            hint: No olvides las palabras reservadas const end const y ;

          - id: c-1-const_entera
            language: C
            week: 1
            prompt: Declara una constante local de tipo entera para el puntaje inicial INITIAL_SCORE, asignale el valor 0.
            answer: |
              int main(){
                const int INITIAL_SCORE = 0;
                return 0;
              }
            hint: Las constantes locales comienzan por const.

          - id: p-1-const_entera
            language: C
            week: 1
            prompt: Declara una constante local de tipo entera para el puntaje inicial INITIAL_SCORE, asignale el valor 0.
            answer: |
              const
                INITIAL_SCORE: integer = 0;
              end const
            hint: No olvides las palabras reservadas const end const y ;

          - id: c-1-nombredron_20
            language: C
            week: 1
            prompt: Declara una cadena de caracteres llamada nombreDron con tamaño 20.
            answer: |
              int main(){
                char nombreDron[20];
                return 0;
              }
            hint:

          - id: p-1-nombredron_string
            language: Pseudocode
            week: 1
            prompt: Declara una variable de tipo string llamada nombreDron.
            answer: |-
              algorithm
                var
                  nombreDron: string;
                end var
              end algorithm
            hint: Recuerda las palabras reservadas var end var.

          - id: c-1-nombredron_max_nombre
            language: C
            week: 1
            prompt: Declara una cadena de caracteres llamada nombreDron con tamaño 20, pero esta vez utiliza la constante "MAX_NOMBRE".
            answer: |
              int main(){
                char nombreDron[MAX_NOMBRE];
                return 0;
              }
            hint:


          - id: c-1-iddron_entera
            language: C
            week: 1
            prompt: Declara una variable entera para almacenar el identificador del dron, llamala idDron.
            answer: |
              int main(){
                int idDron;
                return 0;
              }
            hint:

          - id: p-1-iddron_entera
            language: Pseudocode
            week: 1
            prompt: Declara una variable entera para almacenar el identificador del dron, llamala idDron.
            answer: |-
              algorithm
                var 
                  idDron: integer; 
                end var
              end algorithm
            hint:

          - id: c-1-bateriainicial_float
            language: C
            week: 1
            prompt: Declara una variable decimal para la batería inicial del dron, llamala bateriaInicial.
            answer: |
              int main(){
                float bateriaInicial;
                return 0;
              }

            hint:

          - id: p-1-bateriainicial_real
            language: Pseudocode
            week: 1
            prompt: Declara una variable decimal para la batería inicial del dron, llamala bateriaInicial.
            answer: |-
              algorithm
                var 
                  bateriaInicial: real; 
                end var
              end algorithm
            hint:

          - id: c-1-iddron_menos1
            language: C
            week: 1
            prompt: Inicializa la variable idDron en -1.
            answer: |
              int main(){
                idDron = -1;
                return 0;
              }
            hint:

          - id: p-1-iddron_menos1
            language: Pseudocode
            week: 1
            prompt: Inicializa la variable idDron en -1.
            answer: |
              algorithm
                idDron := -1;
              end algorithm
            hint: El operador de asignación en pseudocódigo es diferente al de C.

          - id: c-1-distanciaminima_const
            language: C
            week: 1
            prompt: Declara una variable llamada distanciaMinima e inicializala con la constante "DISTANCIA_MINIMA".
            answer: |-
              int main(){
                float distanciaMinima = DISTANCIA_MINIMA;
                return 0;
              }
            hint:

          - id: p-1-distanciaminima_const
            language: Pseudocode
            week: 1
            prompt: Declara una variable llamada distanciaMinima e inicializala con la constante "DISTANCIA_MINIMA".
            answer: |-
              algorithm
                var
                  distanciaMinima: real;
                end var

                distanciaMinima:= DISTANCIA_MINIMA;

              end algorithm
            hint: Aquí es importante recordar que en pseudocódigo no es posible declarar e inicializar a la vez, primero declara y luego asignale el valor, no olvides las palabras reservadas var end var.

          - id: c-1-dronactivo_true
            language: C
            week: 1
            prompt: Declara una variable booleana llamada dronActivo e inicialízala a true en la misma linea.
            answer: |
              int main(){
                bool dronActivo = true;
                return 0;
              }
            hint:

          - id: p-1-dronactivo_true
            language: Pseudocode
            week: 1
            prompt: Declara una variable booleana llamada dronActivo e inicialízala a true.
            answer: |-
              algorithm
                var 
                  dronActivo: boolean; 
                end var 

                dronActivo := true;
              
              end algorithm
            hint: Recuerda, primero declara (var end var) y luego inicializa.

          - id: c-1-categoriadron_a
            language: C
            week: 1
            prompt: Declara e inicializa una variable char llamada categoriaDron a "A" en la misma linea.
            answer: |
              int main(){
                char categoriaDron = 'A';
                return 0;
              }

            hint: Los caracteres se inicializan entre ''.

          - id: p-1-categoriadron_a
            language: Pseudocode
            week: 1
            prompt: Declara e inicializa una variable char llamada categoriaDron a "A".
            answer: |-
              algorithm
                var
                  categoriaDron: character;
                end var

                categoriaDron := 'A'
              end algorithm
            hint: Recuerda, primero declara y luego inicializa. Los caracteres se inicializan entre ''.

      # Entrada y salida
      - number: 2
        explanation:
          C: |
            En este nivel aprenderás a leer y escribir datos en C utilizando las funciones `scanf` y `printf`.  
            Estas funciones permiten la interacción entre el programa y el jugador: `scanf` captura lo que escribe el usuario, y `printf` muestra información en pantalla.

            ### Lectura de datos con `scanf`
            Se usa para leer información introducida por el jugador.  
            - En variables simples (`int`, `float`, `char`) se pasa la **dirección de memoria** con `&`.  
            - En cadenas (`char[]`), no se usa `&` porque los arrays ya son punteros.

            ```c
            #include <stdio.h>

            int main() {
                char nombreJugador[30];
                int nivel;
                float energia;
                char teclaAccion;

                scanf("%s", nombreJugador); // cadena
                scanf("%d", &nivel);        // entero
                scanf("%f", &energia);      // decimal
                scanf(" %c", &teclaAccion); // carácter
                return 0;
            }
            ```

            También puedes leer datos sobre un string que ya tenga un valor inicial (se reemplaza el contenido):

            ```c
            #include <stdio.h>

            int main() {
                char nombreJugador[30] = "Jugador1";
                printf("Introduce nuevo nombre: ");
                scanf("%s", nombreJugador);
                return 0;
            }
            ```

            #### Formatos comunes en `scanf`
            - `%s` → cadenas  
            - `%d` → enteros  
            - `%f` → decimales  
            - `%c` → caracteres  

            ---

            ### Escritura de datos con `printf`
            Se usa para mostrar información de la partida en pantalla.  
            Los valores se muestran en el mismo orden que aparecen en la cadena de formato.

            ```c
            #include <stdio.h>

            int main() {
                char nombreJugador[30] = "Mario";
                int nivel = 2;
                float energia = 75.5;
                char teclaAccion = 'A';

                printf("Jugador: %s\n", nombreJugador);
                printf("Nivel: %d\n", nivel);
                printf("Energía: %.1f%%\n", energia);
                printf("Tecla de acción: %c\n", teclaAccion);

                return 0;
            }
            ```

            #### Formatos comunes en `printf`
            - `%s` → cadenas  
            - `%d` → enteros  
            - `%f` → decimales  
            - `%.1f` → decimales con 1 cifra  
            - `%c` → caracteres  

            **Notas importantes**
            - En `scanf`, usar `&` para variables simples (int, float, char), pero no para cadenas.  
            - En `printf`, el orden y tipo de las variables deben coincidir con los especificadores.  

            ---

            ### Ejemplo completo
            ```c
            #include <stdio.h>

            int main() {
                char nombreJugador[30];
                int nivel;
                float energia;
                char teclaAccion;

                printf("Introduce tu nombre: ");
                scanf("%s", nombreJugador);

                printf("Introduce nivel inicial: ");
                scanf("%d", &nivel);

                printf("Introduce energía inicial: ");
                scanf("%f", &energia);

                printf("Introduce la tecla de acción: ");
                scanf(" %c", &teclaAccion);

                printf("\n--- Datos del jugador ---\n");
                printf("Nombre: %s\n", nombreJugador);
                printf("Nivel: %d\n", nivel);
                printf("Energía: %.1f\n", energia);
                printf("Tecla de acción: %c\n", teclaAccion);

                return 0;
            }
            ```

            Este programa solicita al jugador sus datos y luego los muestra por pantalla.

          Pseudocode: |
            En este nivel aprenderás a leer y escribir datos en pseudocódigo utilizando las funciones `readTipo()` y `writeTipo()`.  
            Estas funciones permiten la interacción entre el programa y el jugador: `read...` captura lo que escribe el usuario, y `write...` muestra información en pantalla.

            ### Lectura de datos
            Cada tipo de dato tiene su función de lectura `readTipo()`.  
            El valor obtenido debe asignarse a una variable con `:=`.

            ```pseudocode
            algorithm
              var
                nombreJugador: string;
                nivel: integer;
                energia: real;
                teclaAccion: character;
                modoCoop: boolean;
              end var

              nombreJugador := readString();
              nivel := readInteger();
              energia := readReal();
              teclaAccion := readCharacter();
              modoCoop := readBoolean();
            end algorithm
            ```

            También puedes leer sobre un string que ya tenga valor inicial (el contenido anterior se reemplaza):

            ```pseudocode
            algorithm
              var
                nombreJugador: string;
              end var

              nombreJugador := "Jugador1";
              nombreJugador := readString();
            end algorithm
            ```

            #### Funciones más comunes de lectura
            - `readString()` → cadenas  
            - `readInteger()` → enteros  
            - `readReal()` → decimales  
            - `readCharacter()` → caracteres  
            - `readBoolean()` → booleanos (`true` / `false`)  

            ---

            ### Escritura de datos
            Cada tipo de dato tiene su función `writeTipo(valor)`.  
            Solo puedes imprimir un dato por llamada, por lo que debes hacer varias llamadas para mostrar diferentes valores.

            ```pseudocode
            writeString("Jugador: ");
            writeString(nombreJugador);

            writeString(", Nivel: ");
            writeInteger(nivel);

            writeString(", Energía: ");
            writeReal(energia);

            writeString(", Tecla de acción: ");
            writeCharacter(teclaAccion);

            writeString(", Modo cooperativo: ");
            writeBoolean(modoCoop);
            ```

            #### Funciones más comunes de escritura
            - `writeString(valor)` → cadenas  
            - `writeInteger(valor)` → enteros  
            - `writeReal(valor)` → decimales  
            - `writeCharacter(valor)` → caracteres  
            - `writeBoolean(valor)` → booleanos  

            **Notas importantes**
            - Cada llamada `write...` imprime un único dato o texto.  
            - Los booleanos se muestran como `true` o `false`.  
            - El orden de las llamadas determina el orden en pantalla.  

            ---

            ### Ejemplo completo
            ```pseudocode
            algorithm datosJugador
              var
                nombreJugador: string;
                nivel: integer;
                energia: real;
                teclaAccion: character;
              end var

              writeString("Introduce tu nombre: ");
              nombreJugador := readString();

              writeString("Introduce nivel inicial: ");
              nivel := readInteger();

              writeString("Introduce energía inicial: ");
              energia := readReal();

              writeString("Introduce la tecla de acción: ");
              teclaAccion := readCharacter();

              writeString("--- Datos del jugador --- ");
              writeString("Nombre: ");
              writeString(nombreJugador);
              writeString(", Nivel: ");
              writeInteger(nivel);
              writeString(", Energía: ");
              writeReal(energia);
              writeString(", Tecla: ");
              writeCharacter(teclaAccion);
            end algorithm
            ```

            Este algoritmo solicita al jugador sus datos y luego los muestra en pantalla.

        questions:
          - id: c-1-scanf_nombredron
            language: C
            week: 1
            prompt: Lee el nombre del dron desde teclado usando scanf y guardalo en nombreDron.
            answer: |
              int main(){
                scanf("%s", nombreDron);
                return 0;
              }

            hint: El especificador de formato de string es %s.

          - id: p-1-readstring_nombredron
            language: Pseudocode
            week: 1
            prompt: Lee el nombre del dron desde teclado y guardalo en nombreDron.
            answer: |
              algorithm
                nombreDron := readString();
              end algorithm
            hint: Recuerda que cada tipo tiene una función de lectura que comienza por read. El formato es similar al de una inicialización.

          - id: c-1-scanf_iddron
            language: C
            week: 1
            prompt: Lee el identificador del dron desde teclado usando scanf y guardalo en idDron.
            answer: |
              int main(){
                scanf("%d", &idDron);
                return 0;
              }

            hint: El especificador de formato de integer es %d.

          - id: p-1-readinteger_iddron
            language: Pseudocode
            week: 1
            prompt: Lee el identificador del dron desde teclado y guardalo en idDron.
            answer: |
              algorithm
                idDron := readInteger();
              end algorithm

            hint: Recuerda que cada tipo tiene una función de lectura que comienza por read. El formato es similar al de una inicialización.

          - id: c-1-scanf_bateriai
            language: C
            week: 1
            prompt: Lee el valor de la batería inicial desde teclado usando scanf y guárdalo en bateriaInicial.
            answer: |
              int main(){
                scanf("%f", &bateriaInicial);
                return 0;
              }

            hint: El especificador de formato de float es %f.

          - id: p-1-readreal_bateriai
            language: Pseudocode
            week: 1
            prompt: Lee el valor de la batería inicial desde teclado y guárdalo en bateriaInicial.
            answer: |
              algorithm
                bateriaInicial := readReal();
              end algorithm

            hint: Recuerda que cada tipo tiene una función de lectura que comienza por read. El formato es similar al de una inicialización.

          - id: c-1-scanf_categoriadron
            language: C
            week: 1
            prompt: Lee un carácter del usuario desde teclado usando scanf y guárdalo en categoriaDron.
            answer: |
              int main(){
                scanf(" %c", &categoriaDron);
                return 0;
              }

            hint: El especificador de formato de char es %c.

          - id: p-1-readcharacter_categoriadron
            language: Pseudocode
            week: 1
            prompt: Lee un character del usuario desde teclado y guárdalo en categoriaDron.
            answer: |
              algorithm
                categoriaDron := readCharacter();
              end algorithm

            hint: Recuerda que cada tipo tiene una función de lectura que comienza por read. El formato es similar al de una inicialización.

          - id: c-1-printf_nombre_id
            language: C
            week: 1
            prompt: 'Imprime el nombre del dron y su identificador. Usa "Dron: x, ID: x" para la impresión, siendo "x" el especificador de formato.'
            answer: |
              int main(){
                printf("Dron: %s, ID: %d", nombreDron, idDron);
                return 0;
              }

            hint: 'Ejemplo de ejecución: "Dron: dron001, ID: 1"'

          - id: p-1-writestring_nombre_id
            language: Pseudocode
            week: 1
            prompt: 'Imprime el nombre del dron y su identificador. Usa "Dron: x, ID: x" para la impresión, siendo "x" el valor pertinente.'
            answer: |-
              algorithm
                writeString("Dron: "); 
                writeString(nombreDron); 
                writeString(", ID: "); 
                writeInteger(idDron);'
              end algorithm
            hint: 'Ejemplo de ejecución: "Dron: dron001, ID: 1". Recuerda que en pseudocódigo no puedes imprimir mas de un dato por linea.'

          - id: c-1-printf_bateria
            language: C
            week: 1
            prompt: 'Imprime la batería inicial del dron con un decimal. Usa "Batería: x" para la impresión, siendo "x" el especificador de formato.'
            answer: |
              int main(){
                printf("Batería: %.1f", bateriaInicial);
                return 0;
              }

            hint: Para imprimir cierto numero de decimales utiliza %.xf, siendo x el numero de decimales.

          - id: p-1-writestring_bateria
            language: Pseudocode
            week: 1
            prompt: 'Imprime la batería inicial del dron. Usa "Batería: x" para la impresión, siendo "x" el valor pertinente.'
            answer: |-
              algorithm
                writeString("Batería: ");
                writeReal(bateriaInicial);
              end algorithm
            hint:

          - id: c-1-printf_categoria
            language: C
            week: 1
            prompt: 'Imprime la categoría del dron como carácter. Usa "Categoría: x" para la impresión, siendo "x" el especificador de formato.'
            answer: |
              int main(){
                printf("Categoría: %c", categoriaDron);
                return 0;
              }

            hint:

          - id: p-1-writestring_categoria
            language: Pseudocode
            week: 1
            prompt: 'Imprime la categoría del dron como carácter. Usa "Categoría: x" para la impresión, siendo "x" el valor pertinente.'
            answer: |-
              algorithm
                writeString("Categoría: ");
                writeCharacter(categoriaDron);
              end algorithm
            hint:


      - number: 3
        explanation:
          C: |
            En este nivel aprenderás a trabajar con **enumerativos, operadores aritméticos, relacionales y lógicos, el operador ternario y conversiones de tipo en C**.  
            Estos conceptos son muy útiles para representar estados de un videojuego, calcular puntuaciones o decidir acciones en el juego.

            ### Enumerativos (enum)
            Un `enum` define un conjunto finito de etiquetas con valores enteros subyacentes (normalmente `int` empezando en 0).  
            Son ideales para representar estados del juego con nombres claros en lugar de números.

            ```c
            #include <stdio.h>

            typedef enum {
              IDLE, ATACANDO, KO
            } tEstadoJugador;

            int main() {
                tEstadoJugador estado = ATACANDO;   // inicialización

                // Lectura como entero sin signo
                scanf("%u", &estado);   // %u es el especificador para enumerativos

                // Impresión del valor numérico
                printf("Estado (0=IDLE,1=ATACANDO,2=KO): %u\n", estado);
                return 0;
            }
            ```

            ---

            ### Operadores aritméticos y compuestos
            - Básicos: `+ - * / %`  
            - Compuestos: `+= -= *= /= %=` (operación + asignación).  
            - `++` y `--` incrementan/decrementan en 1.

            ```c
            #include <stdio.h>

            int main() {
                int puntuacion = 900;
                puntuacion += 50;    // ahora 950
                int vidas = 3;
                vidas--;             // ahora 2
                float energia = 87.5f;
                energia -= 12.5f;    // ahora 75.0
                return 0;
            }
            ```

            ---

            ### Operadores relacionales y lógicos
            - Comparaciones: `== != < <= > >=` → devuelven `bool`.  
            - Lógicos: `&&` (AND), `||` (OR), `!` (NOT).  

            ```c
            #include <stdio.h>
            #include <stdbool.h>

            int main() {
                bool activo = true;
                bool averiado = false;
                float bateria = 22.0f;
                int vidas = 3;

                bool suficiente = (bateria >= 20.0f);
                bool enServicio = activo && !averiado;
                bool puedeJugar = suficiente && (vidas > 0);

                return 0;
            }
            ```

            ---

            ### Operador ternario `?:`
            Selecciona entre dos expresiones según una condición.

            ```c
            #include <stdio.h>
            #include <stdbool.h>

            int main() {
                int puntuacion = 1050;
                bool enServicio = true;

                printf("%s\n", enServicio ? "En servicio" : "Fuera de servicio");
                int bonus = (puntuacion >= 1000) ? 100 : 0;

                printf("Bonus: %d\n", bonus);
                return 0;
            }
            ```

            ---

            ### Conversiones (casts)
            ```c
            #include <stdio.h>

            int main() {
                float energia = 73.8f;
                int energiaEntera = (int)energia;    // 73
                int vidas = 2;
                float vidasF = (float)vidas;         // 2.0

                printf("Energía entera: %d\n", energiaEntera);
                printf("Vidas como real: %.1f\n", vidasF);

                return 0;
            }
            ```

            ---

            ### Ejemplo completo
            ```c
            #include <stdio.h>
            #include <stdbool.h>

            typedef enum {
              IDLE, ATACANDO, KO
            } tEstadoJugador;

            int main() {
                int puntuacion = 950;
                int vidas = 3;
                float energia = 73.8f;
                bool activo = true;
                bool averiado = false;
                tEstadoJugador estado = ATACANDO;

                // Relacionales y lógicos
                bool suficiente = (energia >= 50.0f);
                bool enServicio = activo && !averiado;

                // Operador ternario
                int bonus = (puntuacion >= 1000) ? 100 : 0;

                // Conversiones
                int energiaEntera = (int)energia;

                printf("Estado del jugador: %u\n", estado);
                printf("Puntuación: %d (+%d bonus)\n", puntuacion, bonus);
                printf("Vidas: %d\n", vidas);
                printf("Energía: %.1f (entera: %d)\n", energia, energiaEntera);
                printf("En servicio: %s\n", enServicio ? "Sí" : "No");
                return 0;
            }
            ```

            Este programa combina enumerativos, operadores y conversiones para simular el estado de un jugador en un videojuego.

          Pseudocode: |
            En este nivel aprenderás a trabajar con **enumerativos, operadores aritméticos, relacionales y lógicos, además de conversiones de tipo en pseudocódigo**.  
            Estos conceptos son muy útiles para representar estados de un videojuego, actualizar puntuaciones o decidir acciones.

            ### Enumerativos
            ```pseudocode
            type
              tEstadoJugador = { IDLE, ATACANDO, KO }
            end type

            algorithm
              var
                estado: tEstadoJugador;
              end var

              estado := ATACANDO;
              estado := readEnum();
              writeString("Estado actual: ");
              writeEnum(estado);
            end algorithm
            ```

            ---

            ### Operadores aritméticos
            ```pseudocode
            algorithm
              var
                puntuacion: integer;
                vidas: integer;
                energia: real;
              end var

              puntuacion := 900;
              puntuacion := puntuacion + 50;   { ahora 950 }
              vidas := 3;
              vidas := vidas - 1;              { ahora 2 }
              energia := 87.5;
              energia := energia - 12.5;       { ahora 75.0 }
            end algorithm
            ```

            ---

            ### Operadores relacionales y lógicos
            ```pseudocode
            algorithm
              var
                bateria: real;
                vidas: integer;
                activo: boolean;
                averiado: boolean;
                suficiente: boolean;
                puedeJugar: boolean;
              end var

              bateria := 22.0;
              vidas := 3;
              activo := true;
              averiado := false;

              suficiente := bateria ≥ 20.0;
              puedeJugar := suficiente y (vidas > 0);
              activo := no averiado;
            end algorithm
            ```

            ---

            ### Conversiones de tipo
            ```pseudocode
            algorithm
              var
                energia: real;
                energiaEntera: integer;
                vidas: integer;
                vidasF: real;
              end var

              energia := 73.8;
              energiaEntera := realToInteger(energia);
              vidas := 2;
              vidasF := integerToReal(vidas);

              writeString("Energía entera: ");
              writeInteger(energiaEntera);
              writeString(", Vidas como real: ");
              writeReal(vidasF);
            end algorithm
            ```

            ---

            ### Ejemplo completo
            ```pseudocode
            type
              tEstadoJugador = { IDLE, ATACANDO, KO }
            end type

            algorithm estadoJugador
              var
                puntuacion: integer;
                vidas: integer;
                energia: real;
                activo: boolean;
                averiado: boolean;
                estado: tEstadoJugador;
                suficiente: boolean;
                enServicio: boolean;
                energiaEntera: integer;
                bonus: integer;
              end var

              puntuacion := 950;
              vidas := 3;
              energia := 73.8;
              activo := true;
              averiado := false;
              estado := ATACANDO;

              suficiente := energia ≥ 50.0;
              enServicio := activo y (no averiado);

              { Operador ternario simulado con asignación condicional }
              si puntuacion ≥ 1000 entonces
                bonus := 100;
              si no
                bonus := 0;
              fin si

              energiaEntera := realToInteger(energia);

              writeString("Estado del jugador: ");
              writeEnum(estado);
              writeString(", Puntuación: ");
              writeInteger(puntuacion);
              writeString(" (+");
              writeInteger(bonus);
              writeString(" bonus)");
              writeString(", Vidas: ");
              writeInteger(vidas);
              writeString(", Energía: ");
              writeReal(energia);
              writeString(" (entera: ");
              writeInteger(energiaEntera);
              writeString(")");
              writeString(", En servicio: ");
              writeBoolean(enServicio);
            end algorithm
            ```

            Este algoritmo combina enumerativos, operadores y conversiones para simular el estado de un jugador en un videojuego.

        questions:
          - id: c-1-enum_tdrone
            language: C
            week: 1
            prompt: Declara un enumerado tDronEstado con los valores PARADO, EN_VUELO y ESTRELLADO.
            answer: |-
              typedef enum { 
                PARADO, 
                EN_VUELO, 
                ESTRELLADO 
              } tDronEstado;
            hint: la palabra reservada es typedef enum, recuerda poner ; a continuación del nombre del enum.

          - id: p-1-type_tdrone
            language: Pseudocode
            week: 1
            prompt: Declara un enumerado tDronEstado con los valores PARADO, EN_VUELO y ESTRELLADO.
            answer: |-
              type
                tDronEstado = { PARADO, EN_VUELO y ESTRELLADO }
              end type
            hint: No olvides las palabras reservadas type end type.

          - id: c-1-estado_en_vuelo
            language: C
            week: 1
            prompt: Declara una variable tDronEstado llamada estado e inicialízala a EN_VUELO.
            answer: |
              int main(){
                tDronEstado estado = EN_VUELO;
                return 0;
              }

            hint:

          - id: p-1-estado_en_vuelo
            language: Pseudocode
            week: 1
            prompt: Declara una variable tDronEstado llamada estado e inicialízala a EN_VUELO.
            answer: |-
              algorithm
                var
                  estado: tDronEstado;
                end var

              estado := EN_VUELO;
              
              end algorithm
            hint: 'Recuerda: primero declara, luego inicializa.'

          - id: c-1-lee_estado_enum
            language: C
            week: 1
            prompt: Lee el valor del estado del dron desde teclado usando scanf y guárdalo en estado.
            answer: |
              int main(){
                scanf("%u", &estado);
                return 0;
              }

            hint: El especificador de formato para leer enumerativos es %u

          - id: p-1-readenum_estado
            language: Pseudocode
            week: 1
            prompt: Lee el valor del estado del dron desde teclado usando scanf y guárdalo en estado.
            answer: |
              algorithm
                estado := readEnum();
              end algorithm
            hint: La función que se encarga de leer un enumerativo es readEnum.

          - id: c-1-printf_estado_num
            language: C
            week: 1
            prompt: 'Imprime el valor numérico del estado del dron con una explicación. Usa "Estado (0=PARADO, 1=EN_VUELO, 2=ESTRELLADO): x" para la impresión, siendo "x" el especificador de formato.'
            answer: |
              int main(){
                printf("Estado (0=PARADO, 1=EN_VUELO, 2=ESTRELLADO): %d", estado);
                return 0;
              }
              

            hint: 'Ejemplo de ejecución: "Estado (0=PARADO, 1=EN_VUELO, 2=ESTRELLADO): 1"'

          - id: p-1-writestring_estado_num
            language: Pseudocode
            week: 1
            prompt: 'Imprime el valor del estado del dron con una explicación. Usa "Estado: x" para la impresión, siendo "x" el valor a enseñar.'
            answer: |-
              algorithm
                writeString("Estado: ");
                writeEnum(estado);
              end algorithm
            hint: 'Ejemplo de ejecución: Estado: 1'

          - id: c-1-incremento_iddron
            language: C
            week: 1
            prompt: Incrementa la variable idDron en 1 usando el operador de incremento al finalizar la carrera.
            answer: |
              int main(){
                idDron++;
                return 0;
              }
            hint:

          - id: p-1-incrementa_iddron
            language: Pseudocode
            week: 1
            prompt: Incrementa la variable idDron en 1 al finalizar la carrera.
            answer: |
              algorithm
                idDron := idDron +1;
              end algorithm
            hint: Recuerda que en pseudocódigo no existe el operador ++ o -- .

          - id: c-1-compuesto_bateria
            language: C
            week: 1
            prompt: Resta 10.5 a la bateríaInicial usando operador compuesto.
            answer: |
              int main(){
                bateriaInicial -= 10.5;
                return 0;
              }

            hint:

          - id: p-1-resta_bateria
            language: Pseudocode
            week: 1
            prompt: Resta 10.5 a la bateríaInicial .
            answer: |
              algorithm
                bateriaInicial := bateriaInicial - 10.5;
              end algorithm
            hint:

          - id: c-1-suficiente_bool
            language: C
            week: 1
            prompt: Calcula si la batería es suficiente usando un operador relacional y guarda el resultado en en una variable booleana "suficiente". Diremos que la batería es suficiente si tiene al menos un 20%
            answer: |
              int main(){
                bool suficiente = bateriaInicial >= 20.0;
                return 0;
              }

            hint: batería mayor o igual a 20.0

          - id: p-1-suficiente_bool
            language: Pseudocode
            week: 1
            prompt: Calcula si la batería es suficiente usando un operador relacional y guarda el resultado en en una variable booleana "suficiente". Diremos que la batería es suficiente si tiene al menos un 20%. Necesitarás este operador "≥".
            answer: |-
              algorithm
                var
                  suficiente: boolean;
                end var

                suficiente := bateriaInicial ≥ 20.0;
              
              end algorithm
            hint: 'Ten en cuenta que una comparación con operadores relacionales, siempre devuelven un resultado booleano de verdadero o falso, por eso podemos guardar el resultado en una variable booleana. Extra: bateria ≥ a 20.0.'

          - id: c-1-ternario_en_servicio
            language: C
            week: 1
            prompt: Usa el operador ternario para imprimir "En servicio" si dronActivo es verdadero, si no imprime "Fuera de servicio".
            answer: |
              int main(){
                printf("%s", dronActivo ? "En servicio" : "Fuera de servicio");
                return 0;
              }

            hint: 'recuerda que printf acepta como argumento cualquier expresión que devuelva un valor, por eso podemos usar el operador ternario. Ejemplo: printf("%s", variable o condición ? "output1"" : ""output2"");"'

          - id: c-1-ternario_apto
            language: C
            week: 1
            prompt: Imprime "Apto para siguiente ronda" si suficiente es verdadero, si no imprime "No apto", usando ternario.
            answer: |
              int main(){
                printf("%s", suficiente ? "Apto para siguiente ronda" : "No apto");
                return 0;
              }
            hint:

          - id: c-1-cast_bateriaentera
            language: C
            week: 1
            prompt: Convierte bateriaInicial a entero y guárdalo en bateriaEntera.
            answer: |
      
              int main(){
                int bateriaEntera = (int)bateriaInicial;              
                return 0;
              }

            hint: Recuerda que para castear una variable utilizas (tipo)variable.

          - id: p-1-cast_bateriaentera
            language: Pseudocode
            week: 1
            prompt: Convierte bateriaInicial a entero y guárdalo en bateriaEntera.
            answer: |-
              algorithm
                var
                  bateriaEntera: integer;
                end var

                bateriaEntera := realToInteger(bateriaInicial);
              end algorithm
            hint: Recuerda que para castear una variable decimal a una entera usamos realToInteger().
              También recuerda que primero debes declarar la variable bateriaEntera.

          - id: c-1-cast_nuevabateria
            language: C
            week: 1
            prompt: Convierte bateriaEntera otra vez a decimal y guárdalo en nuevaBateria.
            answer: |
              int main(){
                float nuevaBateria = (float)bateriaEntera;
                return 0;
              }
            hint:

          - id: p-1-cast_nuevabateria
            language: Pseudocode
            week: 1
            prompt: Convierte bateriaEntera otra vez a decimal y guárdalo en nuevaBateria.
            answer: |-
              algorithm
                var
                  nuevaBateria: integer;
                end var
  
                nuevaBateria := integerToReal(bateriaInicial);
              end algorithm
            hint:

  - number: 2
    explanation: |
      Explicación de semana 2
    levels:
      - number: 1
        explanation:
          C: |
            En este nivel aprenderás a trabajar con **arrays en C**, tanto de números como de cadenas.  
            Los arrays son fundamentales en videojuegos para guardar puntuaciones de enemigos, inventarios o niveles.

            ### Arrays en C
            Un **array** es una colección de elementos del mismo tipo almacenados en posiciones consecutivas de memoria.  
            El tamaño del array debe ser fijo y conocerse en tiempo de compilación.

            ---

            ### Tamaño con número fijo o con constante
            ```c
            #define MAX_ENEMIGOS 5

            int main() {
                int puntosEnemigos[5];                 // tamaño fijo
                int puntosEnemigosConst[MAX_ENEMIGOS]; // con constante
                return 0;
            }
            ```

            ---

            ### Inicialización de arrays de tipos primitivos
            Puedes inicializar al declarar:
            ```c
            int main() {
                int puntosEnemigos[5] = {100, 200, 150, 300, 500};
                return 0;
            }
            ```

            O asignar después elemento por elemento:
            ```c
            int main() {
                int puntosEnemigos[5];
                puntosEnemigos[0] = 100;
                puntosEnemigos[1] = 200;
                puntosEnemigos[2] = 150;
                puntosEnemigos[3] = 300;
                puntosEnemigos[4] = 500;
                return 0;
            }
            ```

            *Recuerda*: en C los índices empiezan en **0**.

            ---

            ### Arrays de cadenas
            Una cadena es un array de `char` terminado con `'\0'`.  
            Para guardar varias cadenas se usan arrays bidimensionales:

            ```c
            #define MAX_OBJETOS 3
            #define MAX_LONGITUD 20

            int main() {
                char inventario[MAX_OBJETOS][MAX_LONGITUD];
                return 0;
            }
            ```

            Inicialización directa:
            ```c
            int main() {
                char inventario[3][20] = {"Espada", "Escudo", "Poción"};
                return 0;
            }
            ```

            O asignación posterior:
            ```c
            #include <string.h>

            int main() {
                char inventario[3][20];
                strcpy(inventario[0], "Espada");
                strcpy(inventario[1], "Escudo");
                strcpy(inventario[2], "Poción");
                return 0;
            }
            ```

            ---

            ### Acceso a elementos
            ```c
            int main() {
                int puntosEnemigos[5] = {100, 200, 150, 300, 500};
                int valor = puntosEnemigos[2]; // devuelve 150

                char inventario[3][20] = {"Espada", "Escudo", "Poción"};
                // inventario[1] → "Escudo"

                return 0;
            }
            ```

            ---

            ### Ejemplo completo
            ```c
            #include <stdio.h>
            #include <string.h>
            #define MAX_ENEMIGOS 5
            #define MAX_OBJETOS 3
            #define MAX_LONGITUD 20

            int main() {
                int puntosEnemigos[MAX_ENEMIGOS] = {100, 200, 150, 300, 500};
                char inventario[MAX_OBJETOS][MAX_LONGITUD] = {"Espada", "Escudo", "Poción"};

                printf("Puntos del tercer enemigo: %d\n", puntosEnemigos[2]);
                printf("Objeto en la segunda ranura: %s\n", inventario[1]);

                // Actualizar inventario
                strcpy(inventario[2], "Llave mágica");
                printf("Nuevo objeto en la tercera ranura: %s\n", inventario[2]);
                return 0;
            }
            ```

            Este programa muestra cómo inicializar arrays, acceder a sus elementos y modificarlos, simulando un sistema de enemigos y objetos en un videojuego.

          Pseudocode: |
            En este nivel aprenderás a trabajar con **arrays en pseudocódigo**, tanto de números como de cadenas.  
            Son muy útiles para representar puntuaciones de enemigos o inventarios en videojuegos.

            ### Arrays en pseudocódigo
            Un **array** es una colección de elementos del mismo tipo.  
            El tamaño es fijo y se define al crearlo.

            ---

            ### Tamaño con número fijo o constante
            ```pseudocode
            algorithm
              var
                puntosEnemigos: vector[5] of integer;
              end var
            end algorithm
            ```

            ```pseudocode
            const
              MAX_ENEMIGOS: integer = 5;
            end const

            algorithm
              var
                puntosEnemigos: vector[MAX_ENEMIGOS] of integer;
              end var
            end algorithm
            ```

            ---

            ### Inicialización de arrays de tipos primitivos
            En pseudocódigo no se permiten llaves `{}`.  
            Se asigna elemento por elemento:

            ```pseudocode
            const
              MAX_ENEMIGOS: integer = 5;
            end const

            algorithm
              var
                puntosEnemigos: vector[MAX_ENEMIGOS] of integer;
              end var

              puntosEnemigos[1] := 100;
              puntosEnemigos[2] := 200;
              puntosEnemigos[3] := 150;
              puntosEnemigos[4] := 300;
              puntosEnemigos[5] := 500;
            end algorithm
            ```

            *Recuerda*: en pseudocódigo los índices empiezan en **1**.

            ---

            ### Arrays de cadenas
            ```pseudocode
            const
              MAX_OBJETOS: integer = 3;
            end const

            algorithm
              var
                inventario: vector[MAX_OBJETOS] of string;
              end var

              inventario[1] := "Espada";
              inventario[2] := "Escudo";
              inventario[3] := "Poción";
            end algorithm
            ```

            ---

            ### Acceso a elementos
            ```pseudocode
            valor := puntosEnemigos[3];
            objeto := inventario[2];
            ```

            ---

            ### Ejemplo completo
            ```pseudocode
            const
              MAX_ENEMIGOS: integer = 5;
              MAX_OBJETOS: integer = 3;
            end const

            algorithm arraysVideojuego
              var
                puntosEnemigos: vector[MAX_ENEMIGOS] of integer;
                inventario: vector[MAX_OBJETOS] of string;
                valor: integer;
                objeto: string;
              end var

              puntosEnemigos[1] := 100;
              puntosEnemigos[2] := 200;
              puntosEnemigos[3] := 150;
              puntosEnemigos[4] := 300;
              puntosEnemigos[5] := 500;

              inventario[1] := "Espada";
              inventario[2] := "Escudo";
              inventario[3] := "Poción";

              valor := puntosEnemigos[3];
              objeto := inventario[2];

              writeString("Puntos del tercer enemigo: ");
              writeInteger(valor);
              writeString(", Objeto en la segunda ranura: ");
              writeString(objeto);
            end algorithm
            ```

            Este algoritmo muestra cómo usar arrays para almacenar y consultar puntuaciones de enemigos y un inventario de objetos en un videojuego.

        questions:
          - id: c-2-include_stdio
            language: C
            week: 2
            prompt: Incluye la biblioteca estándar de entrada/salida en C para poder usar printf y scanf.
            answer: |
              #include <stdio.h>
            hint: 'Empieza por #include'

          - id: c-2-include_stdbool
            language: C
            week: 2
            prompt: Incluye la biblioteca necesaria para poder usar variables booleanas en C.
            answer: |
              #include <stdbool.h>
            hint: 'El nombre contiene "std"'

          - id: c-2-include_string
            language: C
            week: 2
            prompt: Incluye la biblioteca necesaria para trabajar con cadenas de caracteres (funciones como strcpy, strcat, strcmp, strlen).
            answer: |
              #include <string.h>
            hint: 'La biblioteca clásica para manipulación de strings, el nombre acaba con .h .'

          - id: c-2-max_plants_define
            language: C
            week: 2
            prompt: Declara una constante MAX_PLANTS con valor 5 usando define.
            answer: |
              #define MAX_PLANTS 5
            hint:

          - id: p-2-max_plants_const
            language: Pseudocode
            week: 2
            prompt: Declara una constante MAX_PLANTS con valor 5.
            answer: |
              const
                MAX_PLANTS: integer = 5;
              end const
            hint:

          - id: c-2-max_name_define
            language: C
            week: 2
            prompt: Declara una constante MAX_NAME con valor 25 usando define.
            answer: |
              #define MAX_NAME 25
            hint:

          - id: c-2-const_temp_minima
            language: C
            week: 2
            prompt: Dentro de la función main, declara una constante local de tipo float llamada TEMP_MINIMA con valor 15.0.
            answer: |
              int main() {
                  const float TEMP_MINIMA = 15.0;
                  return 0;
              }
            hint: |
              int main(){

                // Código

                return 0;
              }

          - id: p-2-const_temp_minima
            language: Pseudocode
            week: 2
            prompt: Declara una constante de tipo decimal llamada TEMP_MINIMA con valor 15.0.
            answer: |
              const
                TEMP_MINIMA: real = 15.0;
              end const
            hint: Los decimales en pseudocódigo son el tipo real.

          - id: c-2-array-nombres-solo
            language: C
            week: 2
            prompt: Declara un array de cadenas nombrePlantas para 5 plantas, cada nombre de 20 caracteres.
            answer: |
              int main() {
                  char nombrePlantas[5][20];
                  return 0;
              }
            hint: Primero va el número de elementos, luego el tamaño de cada string.

          - id: p-2-array-nombres-solo
            language: Pseudocode
            week: 2
            prompt: Declara un array de strings nombrePlantas para 5 plantas.
            answer: |
              algorithm
                var
                  nombrePlantas: vector[5] of string;
                end var
              end algorithm
            hint:


          - id: c-2-arr_nombreplanta
            language: C
            week: 2
            prompt: |
              Declara las constantes MAX_PLANTS = 5 y MAX_NAME = 25.

              Dentro de main, declara un array de cadenas nombrePlanta para los nombres de las plantas usando ambas constantes.
            answer: |
              #define MAX_PLANTS 5
              #define MAX_NAME 25

              int main() {
                  char nombrePlanta[MAX_PLANTS][MAX_NAME];
                  return 0;
              }
            hint: Después del nombre del array va primero el maximo de plantas y después el de los nombres

          - id: p-2-arr_nombreplanta
            language: Pseudocode
            week: 2
            prompt: |
              Declara la constante MAX_PLANTS = 5.

              Dentro del algoritmo principal, declara un array de strings nombrePlanta para los nombres de las plantas usando dicha constante.
            answer: |
              const
                MAX_PLANTS: integer = 5;
              end const

              algorithm
                var
                  nombrePlanta: vector[MAX_PLANTS] of string;
                end var
              end algorithm
            hint: No olvides todas las palabras reservadas como const, algorithm y var.

          - id: c-2-arr_sensoresactivos
            language: C
            week: 2
            prompt: |
              Incluye la biblioteca necesaria para booleanos.

              Declara la constante MAX_PLANTS = 5 y un array booleano sensoresActivos usando MAX_PLANTS dentro de main.
            answer: |
              #include <stdbool.h>
              #define MAX_PLANTS 5

              int main() {
                  bool sensoresActivos[MAX_PLANTS];
                  return 0;
              }
            hint: Incluye stdbool y usa bool, no int.

          - id: p-2-arr_sensoresactivos
            language: Pseudocode
            week: 2
            prompt: |
              Declara la constante MAX_PLANTS = 5.

              Dentro del algoritmo principal, declara un array de booleanos sensoresActivos usando dicha constante.
            answer: |
              const
                MAX_PLANTS: integer = 5;
              end const

              algorithm
                var
                   sensoresActivos: vector[MAX_PLANTS] of boolean;
                end var
              end algorithm
            hint: No olvides todas las palabras reservadas como const, algorithm y var.

          - id: c-2-array-alturas
            language: C
            week: 2
            prompt: Declara la constante MAX_PLANTAS = 5 y un array float alturas usando la constante.
            answer: |
              #define MAX_PLANTAS 5

              int main() {
                  float alturas[MAX_PLANTAS];
                  return 0;
              }
            hint:

          - id: p-2-array-alturas
            language: Pseudocode
            week: 2
            prompt: Declara la constante MAX_PLANTAS = 5 y un array real alturas usando la constante.
            answer: |
              const
                MAX_PLANTAS: integer = 5;
              end const

              algorithm
                var
                  alturas: vector[MAX_PLANTAS] of real;
                end var
              end algorithm
            hint:

          - id: c-2-array-nombres-alturas
            language: C
            week: 2
            prompt: Declara las constantes MAX_PLANTAS = 5 y MAX_NOMBRE = 20. Declara un array de cadenas nombrePlantas y un array float alturas, ambos usando MAX_PLANTAS.
            answer: |
              #define MAX_PLANTAS 5
              #define MAX_NOMBRE 20

              int main() {
                  char nombrePlantas[MAX_PLANTAS][MAX_NOMBRE];
                  float alturas[MAX_PLANTAS];
                  return 0;
              }
            hint:

          - id: p-2-array-nombres-alturas
            language: Pseudocode
            week: 2
            prompt: Declara la constante MAX_PLANTAS = 5. Declara un array de strings nombrePlantas y un array de reales alturas usando la constante.
            answer: |
              const
                MAX_PLANTAS: integer = 5;
              end const

              algorithm
                var
                  nombrePlantas: vector[MAX_PLANTAS] of string;
                  alturas: vector[MAX_PLANTAS] of real;
                end var
              end algorithm
            hint:

          - id: c-2-arr_humedad
            language: C
            week: 2
            prompt: |
              Declara la constante MAX_PLANTS = 5 y un array de enteros humedad con MAX_PLANTS,

              inicializado con los valores "60, 85, 72, 91, 65" en la misma linea dentro de main.
            answer: |
              #define MAX_PLANTS 5

              int main() {
                  int humedad[MAX_PLANTS] = {60, 85, 72, 91, 65};
                  return 0;
              }
            hint: Los valores deben estar entre llaves, separados por comas.

          - id: p-2-arr_humedad
            language: Pseudocode
            week: 2
            prompt: |
              Declara la constante MAX_PLANTS = 5.

              Dentro del algoritmo principal, declara un array de enteros humedad con MAX_PLANTS.

              Inicializa el array con los valores "60, 85, 72, 91, 65".
            answer: |
              const
                MAX_PLANTS: integer = 5;
              end const

              algorithm
                var
                   humedad: vector[MAX_PLANTS] of integer;
                end var

                humedad[1] := 60;
                humedad[2] := 85;
                humedad[3] := 72;
                humedad[4] := 91;
                humedad[5] := 65;
              end algorithm
            hint: Recuerda que en pseudocódigo, primero declaramos las variables y después las inicializamos.

          - id: c-2-inicializa-alturas
            language: C
            week: 2
            prompt: Declara la constante MAX_PLANTAS = 5 y un array float alturas, inicializándolo con los valores 11.2, 18.4, 13.0, 17.5, 15.1.
            answer: |
              #define MAX_PLANTAS 5

              int main() {
                  float alturas[MAX_PLANTAS] = {11.2, 18.4, 13.0, 17.5, 15.1};
                  return 0;
              }
            hint:

          - id: p-2-inicializa-alturas
            language: Pseudocode
            week: 2
            prompt: Declara la constante MAX_PLANTAS = 5 y un array real alturas. Inicializa los 5 valores a 11.2, 18.4, 13.0, 17.5, 15.1.
            answer: |
              const
                MAX_PLANTAS: integer = 5;
              end const

              algorithm
                var
                  alturas: vector[MAX_PLANTAS] of real;
                end var

                alturas[1] := 11.2;
                alturas[2] := 18.4;
                alturas[3] := 13.0;
                alturas[4] := 17.5;
                alturas[5] := 15.1;
              end algorithm
            hint:

      - number: 2
        explanation:
          C: |
            En este nivel aprenderás a trabajar con **matrices (arrays bidimensionales)** en C.  
            Las matrices son muy útiles en videojuegos para representar mapas, tableros o zonas de juego.

            ### ¿Qué es una matriz?
            Una **matriz** es un array con **filas** y **columnas**.  
            La forma general es:  
            ```c
            tipo nombre[FILAS][COLUMNAS];
            ```
            *Primero se escriben las filas y después las columnas*.  
            Los índices en C empiezan en **0**.

            ---

            ### Declaración con constantes fuera de `main`
            ```c
            #define FILAS 3
            #define COLUMNAS 4

            int main() {
                int tablero[FILAS][COLUMNAS];
                return 0;
            }
            ```

            ---

            ### Inicialización con llaves `{}` al declarar
            ```c
            #define FILAS 2
            #define COLUMNAS 3

            int main() {
                int mapa[FILAS][COLUMNAS] = {
                    {1, 0, 0},
                    {0, 1, 0}
                };
                return 0;
            }
            ```

            ---

            ### Inicialización manual elemento a elemento
            ```c
            #define FILAS 2
            #define COLUMNAS 3

            int main() {
                int zonas[FILAS][COLUMNAS];
                zonas[0][0] = 1;
                zonas[0][1] = 0;
                zonas[0][2] = 0;

                zonas[1][0] = 0;
                zonas[1][1] = 1;
                zonas[1][2] = 0;
                return 0;
            }
            ```

            ---

            ### Matrices booleanas
            ```c
            #include <stdbool.h>
            #define FILAS 2
            #define COLUMNAS 3

            int main() {
                bool zonaActiva[FILAS][COLUMNAS];

                zonaActiva[0][0] = true;
                zonaActiva[0][1] = false;
                zonaActiva[0][2] = false;

                zonaActiva[1][0] = false;
                zonaActiva[1][1] = true;
                zonaActiva[1][2] = false;
                return 0;
            }
            ```

            ---

            ### Acceso a un elemento concreto
            ```c
            #define FILAS 2
            #define COLUMNAS 3

            int main() {
                float valores[FILAS][COLUMNAS] = {
                    {6.1f, 6.3f, 6.0f},
                    {7.1f, 7.0f, 6.9f}
                };
                float x = valores[1][0]; // fila 2, columna 1 → 7.1
                return 0;
            }
            ```

            ---

            ### Ejemplo completo
            ```c
            #include <stdio.h>
            #include <stdbool.h>
            #define FILAS 2
            #define COLUMNAS 3

            int main() {
                // Matriz de enteros para un mapa
                int mapa[FILAS][COLUMNAS] = {
                    {1, 0, 0},
                    {0, 1, 0}
                };

                // Matriz booleana para zonas activas
                bool zonaActiva[FILAS][COLUMNAS];
                zonaActiva[0][0] = true;
                zonaActiva[0][1] = false;
                zonaActiva[0][2] = false;
                zonaActiva[1][0] = false;
                zonaActiva[1][1] = true;
                zonaActiva[1][2] = false;

                // Acceso a valores
                int casilla = mapa[0][0]; // 1
                bool activa = zonaActiva[1][1]; // true

                printf("Casilla inicial: %d\n", casilla);
                printf("Zona (2,2) activa: %s\n", activa ? "sí" : "no");

                return 0;
            }
            ```

            Este programa muestra cómo declarar, inicializar y acceder a matrices, simulando un mapa de un videojuego con zonas activas o inactivas.

          Pseudocode: |
            En este nivel aprenderás a trabajar con **matrices (vectores bidimensionales)** en pseudocódigo.  
            Sirven para representar mapas, tableros o zonas en videojuegos.

            ### ¿Qué es una matriz?
            Una **matriz** es un vector con dos dimensiones: **filas** y **columnas**.  
            En pseudocódigo los índices empiezan en **1**.

            ---

            ### Declaración con constantes
            ```pseudocode
            const
              FILAS: integer = 3;
              COLUMNAS: integer = 4;
            end const

            algorithm
              var
                tablero: vector[FILAS][COLUMNAS] of integer;
              end var
            end algorithm
            ```

            ---

            ### Inicialización manual
            En pseudocódigo no se permiten llaves `{}`, se hace elemento por elemento:
            ```pseudocode
            const
              FILAS: integer = 2;
              COLUMNAS: integer = 3;
            end const

            algorithm
              var
                zonas: vector[FILAS][COLUMNAS] of integer;
              end var

              zonas[1][1] := 1;
              zonas[1][2] := 0;
              zonas[1][3] := 0;

              zonas[2][1] := 0;
              zonas[2][2] := 1;
              zonas[2][3] := 0;
            end algorithm
            ```

            ---

            ### Matrices booleanas
            ```pseudocode
            const
              FILAS: integer = 2;
              COLUMNAS: integer = 3;
            end const

            algorithm
              var
                activo: vector[FILAS][COLUMNAS] of boolean;
              end var

              activo[1][1] := true;
              activo[1][2] := false;
              activo[1][3] := false;

              activo[2][1] := false;
              activo[2][2] := true;
              activo[2][3] := false;
            end algorithm
            ```

            ---

            ### Acceso a un elemento concreto
            ```pseudocode
            dato := valores[2][1];  { fila 2, columna 1 }
            ```

            ---

            ### Ejemplo completo
            ```pseudocode
            const
              FILAS: integer = 2;
              COLUMNAS: integer = 3;
            end const

            algorithm matrizVideojuego
              var
                mapa: vector[FILAS][COLUMNAS] of integer;
                zonaActiva: vector[FILAS][COLUMNAS] of boolean;
                casilla: integer;
                activa: boolean;
              end var

              mapa[1][1] := 1;
              mapa[1][2] := 0;
              mapa[1][3] := 0;
              mapa[2][1] := 0;
              mapa[2][2] := 1;
              mapa[2][3] := 0;

              zonaActiva[1][1] := true;
              zonaActiva[1][2] := false;
              zonaActiva[1][3] := false;
              zonaActiva[2][1] := false;
              zonaActiva[2][2] := true;
              zonaActiva[2][3] := false;

              casilla := mapa[1][1];
              activa := zonaActiva[2][2];

              writeString("Casilla inicial: ");
              writeInteger(casilla);
              writeString(", Zona (2,2) activa: ");
              writeBoolean(activa);
            end algorithm
            ```

            Este algoritmo muestra cómo declarar, inicializar y acceder a matrices, simulando un mapa de un videojuego con zonas activas o inactivas.

        questions:
          - id: c-2-mat_sensorestemp
            language: C
            week: 2
            prompt: |
              Declara las constantes FILAS = 3 y COLUMNAS = 4.

              Dentro de main, declara una matriz de enteros sensoresTemperatura con FILAS Y COLUMNAS.
            answer: |
              #define FILAS 3
              #define COLUMNAS 4

              int main() {
                  int sensoresTemperatura[FILAS][COLUMNAS];
                  return 0;
              }
            hint: En una matriz van siempre primero las filas y luego las columnas

          - id: p-2-mat_sensorestemp
            language: Pseudocode
            week: 2
            prompt: |
              Declara las constantes FILAS = 3 y COLUMNAS = 4.

              Dentro del algoritmo principal, declara una matriz de enteros sensoresTemperatura con FILAS Y COLUMNAS.
            answer: |
              const
                FILAS: integer = 3;
                COLUMNAS: integer = 4;
              end const

              algorithm
                var
                   sensoresTemperatura: vector[FILAS][COLUMNAS] of integer;
                end var
              end algorithm
            hint: En una matriz van siempre primero las filas y luego las columnas, no olvides todas las palabras reservadas para declarar los datos.


          - id: c-2-mat_zonas_bool
            language: C
            week: 2
            prompt: |
              Declara las constantes FILAS = 2 y COLUMNAS = 3.

              Dentro de main, declara una matriz booleana zonas con FILAS Y COLUMNAS.

              Inicialízala con los valores: 
              fila 1: true, false, false 
              fila 2: false, true, false.
            answer: |
              #include <stdbool.h>
              #define FILAS 2
              #define COLUMNAS 3

              int main() {
                  bool zonas[FILAS][COLUMNAS];

                  zonas[0][0] = true;
                  zonas[0][1] = false;
                  zonas[0][2] = false;

                  zonas[1][0] = false;
                  zonas[1][1] = true;
                  zonas[1][2] = false;

                  return 0;
              }
            hint: Recuerda la biblioteca para el tipo booleano.

          - id: p-2-mat_zonas_bool
            language: Pseudocode
            week: 2
            prompt: |
              Declara las constantes FILAS = 2 y COLUMNAS = 3.

              Dentro del algoritmo principal, declara una matriz booleana zonas con FILAS Y COLUMNAS. 

              Inicialízala con los valores: 
              fila 1: true, false, false 
              fila 2: false, true, false.
            answer: |
              const
                FILAS: integer = 2;
                COLUMNAS: integer = 3;
              end const

              algorithm
                var
                   zonas: vector[FILAS][COLUMNAS] of boolean;
                end var

                zonas[1][1] := true;
                zonas[1][2] := false;
                zonas[1][3] := false;

                zonas[2][1] := false;
                zonas[2][2] := true;
                zonas[2][3] := false;
              end algorithm
            hint: No olvides las palabras reservadas para declarar los datos y el algoritmo principal.

          - id: c-2-matriz-inicializa-llaves
            language: C
            week: 2
            prompt: |
              Declara las constantes FILAS = 2 y COLUMNAS = 3. 

              Dentro de la función main, declara e inicializa una matriz de enteros llamada `zonas` con los siguientes valores usando llaves `{}`:
              - fila 1: 1, 0, 0
              - fila 2: 0, 1, 0
            answer: |
              #define FILAS 2
              #define COLUMNAS 3

              int main() {
                  int zonas[FILAS][COLUMNAS] = {
                      {1, 0, 0},
                      {0, 1, 0}
                  };
                  return 0;
              }
            hint: |
              Ejemplo: 
                tipo matriz[2][3] = { {a, b, c}, {d, e, f} };

          - id: c-2-matriz-inicializa-manual
            language: C
            week: 2
            prompt: |
              Declara las constantes FILAS = 2 y COLUMNAS = 3.

              Dentro de la función main, declara una matriz de enteros llamada `zonas` y asigna manualmente los siguientes valores:
              - fila 1: 1, 0, 0
              - fila 2: 0, 1, 0
            answer: |
              #define FILAS 2
              #define COLUMNAS 3

              int main() {
                  int zonas[FILAS][COLUMNAS];
                  zonas[0][0] = 1;
                  zonas[0][1] = 0;
                  zonas[0][2] = 0;

                  zonas[1][0] = 0;
                  zonas[1][1] = 1;
                  zonas[1][2] = 0;
                  return 0;
              }
            hint: |
              Asigna cada elemento individualmente con zonas[fila][columna].
              Recuerda: en C los índices empiezan en 0.

          - id: p-2-matriz-inicializa-const
            language: Pseudocode
            week: 2
            prompt: |
              Declara las constantes FILAS = 2 y COLUMNAS = 3.

              Dentro del algoritmo principal, declara una matriz de enteros zonas de tamaño FILAS x COLUMNAS.

              Inicializa la matriz manualmente con los valores siguientes:
              - fila 1: 1, 0, 0
              - fila 2: 0, 1, 0
            answer: |
              const
                FILAS: integer = 2;
                COLUMNAS: integer = 3;
              end const

              algorithm
                var
                  zonas: vector[FILAS][COLUMNAS] of integer;
                end var

                zonas[1][1] := 1;
                zonas[1][2] := 0;
                zonas[1][3] := 0;
                zonas[2][1] := 0;
                zonas[2][2] := 1;
                zonas[2][3] := 0;
              end algorithm
            hint: |
              En pseudocódigo la inicialización de matrices es siempre manual, elemento a elemento.
              Los índices comienzan en 1.

          - id: c-2-matriz-ph
            language: C
            week: 2
            prompt: |
              Incluye stdio.

              Declara las constantes FILAS = 2 y COLUMNAS = 3.

              Declara una matriz float phSuelo.

              Inicializa utilizando {} con los valores:
              fila 1: 6.1, 6.3, 6.0
              fila 2: 7.1, 7.0, 6.9

              Imprime el valor de la posición fila 2, columna 1 con el formato "pH: x".
            answer: |
              #include <stdio.h>

              #define FILAS 2
              #define COLUMNAS 3

              int main() {
                  float phSuelo[FILAS][COLUMNAS] = {
                      {6.1, 6.3, 6.0},
                      {7.1, 7.0, 6.9}
                  };
                  printf("pH: %.1f\n", phSuelo[1][0]);
                  return 0;
              }
            hint: |
              Ejemplo de ejecución: 
                pH: 7.1

          - id: p-2-matriz-ph
            language: Pseudocode
            week: 2
            prompt: |
              Declara las constantes FILAS = 2 y COLUMNAS = 3.

              Declara una matriz real phSuelo.

              Inicializa los valores:
              fila 1: 6.1, 6.3, 6.0
              fila 2: 7.1, 7.0, 6.9

              Imprime el valor de la posición fila 2, columna 1 el formato "pH: x".
            answer: |
              const
                FILAS: integer = 2;
                COLUMNAS: integer = 3;
              end const

              algorithm
                var
                  phSuelo: vector[FILAS][COLUMNAS] of real;
                end var

                phSuelo[1][1] := 6.1;
                phSuelo[1][2] := 6.3;
                phSuelo[1][3] := 6.0;
                phSuelo[2][1] := 7.1;
                phSuelo[2][2] := 7.0;
                phSuelo[2][3] := 6.9;

                writeString("pH: ");
                writeReal(phSuelo[2][1]);
              end algorithm
            hint: |
              Recuerda que en pseudocódigo no puedes imprimir mas de un dato por linea.

              Ejemplo de ejecución: 
              pH: 7.1


      - number: 3
        explanation:
          C: |
            En este nivel aprenderás a leer y escribir datos en arrays, y también a copiar y comparar cadenas de caracteres en C.  
            Esto es útil en videojuegos para guardar puntuaciones de rondas o nombres de objetos en un inventario.

            ### Leer datos numéricos en arrays
            Puedes leer enteros o reales uno por uno usando `scanf`:

            ```c
            #include <stdio.h>
            #define MAX_PUNTOS 3

            int main() {
                int puntos[MAX_PUNTOS];

                printf("Puntos ronda 1: ");
                scanf("%d", &puntos[0]);

                printf("Puntos ronda 2: ");
                scanf("%d", &puntos[1]);

                printf("Puntos ronda 3: ");
                scanf("%d", &puntos[2]);

                return 0;
            }
            ```

            ---

            ### Mostrar datos de un array
            ```c
            printf("Ronda 1: %d\n", puntos[0]);
            printf("Ronda 2: %d\n", puntos[1]);
            printf("Ronda 3: %d\n", puntos[2]);
            ```

            ---

            ### Arrays de cadenas: copiar con `strncpy`
            Las cadenas se almacenan en arrays bidimensionales.  
            Para copiar texto en cada posición, se usa `strncpy`:

            ```c
            #include <stdio.h>
            #include <string.h>
            #define MAX_ARMAS 2
            #define MAX_NOMBRE 20

            int main() {
                char armas[MAX_ARMAS][MAX_NOMBRE];

                strncpy(armas[0], "Espada de fuego", MAX_NOMBRE);
                strncpy(armas[1], "Arco helado", MAX_NOMBRE);

                printf("Arma 1: %s\n", armas[0]);
                printf("Arma 2: %s\n", armas[1]);
                return 0;
            }
            ```

            ---

            ### Comparar cadenas con `strcmp`
            Para saber si dos cadenas son iguales, se usa `strcmp`, que devuelve 0 si son iguales:

            ```c
            int esIgual;
            esIgual = strcmp(armas[0], "Espada de fuego") == 0 ? 1 : 0;
            ```

            *Si `esIgual` vale 1, las cadenas son iguales.*

            ---

            ### Ejemplo completo
            ```c
            #include <stdio.h>
            #include <string.h>
            #define MAX_PUNTOS 3
            #define MAX_ARMAS 2
            #define MAX_NOMBRE 20

            int main() {
                int puntos[MAX_PUNTOS];
                char armas[MAX_ARMAS][MAX_NOMBRE];
                int esIgual;

                // Lectura de puntos
                printf("Introduce los puntos de 3 rondas:\n");
                scanf("%d", &puntos[0]);
                scanf("%d", &puntos[1]);
                scanf("%d", &puntos[2]);

                // Mostrar puntos
                printf("Ronda 1: %d\n", puntos[0]);
                printf("Ronda 2: %d\n", puntos[1]);
                printf("Ronda 3: %d\n", puntos[2]);

                // Copiar nombres de armas
                strncpy(armas[0], "Espada de fuego", MAX_NOMBRE);
                strncpy(armas[1], "Arco helado", MAX_NOMBRE);

                // Mostrar armas
                printf("Arma 1: %s\n", armas[0]);
                printf("Arma 2: %s\n", armas[1]);

                // Comparar cadenas
                esIgual = strcmp(armas[0], "Espada de fuego") == 0 ? 1 : 0;
                printf("¿Arma 1 es 'Espada de fuego'? %s\n", esIgual ? "Sí" : "No");

                return 0;
            }
            ```

            Este programa combina lectura y escritura de arrays numéricos con el manejo de cadenas en un inventario de armas.

          Pseudocode: |
            En este nivel aprenderás a leer y mostrar datos en arrays, y también a copiar y comparar cadenas en pseudocódigo.  
            Esto es útil en videojuegos para guardar puntuaciones de rondas o nombres de objetos.

            ### Leer datos numéricos
            ```pseudocode
            const
              MAX_PUNTOS: integer = 3;
            end const

            algorithm leerPuntos
              var
                puntos: vector[MAX_PUNTOS] of integer;
              end var

              writeString("Puntos ronda 1: ");
              puntos[1] := readInteger();

              writeString("Puntos ronda 2: ");
              puntos[2] := readInteger();

              writeString("Puntos ronda 3: ");
              puntos[3] := readInteger();
            end algorithm
            ```

            ---

            ### Escribir datos
            ```pseudocode
            algorithm mostrarPuntos
              var
                puntos: vector[3] of integer;
              end var

              writeString("Ronda 1: ");
              writeInteger(puntos[1]);

              writeString("Ronda 2: ");
              writeInteger(puntos[2]);

              writeString("Ronda 3: ");
              writeInteger(puntos[3]);
            end algorithm
            ```

            ---

            ### Leer cadenas
            ```pseudocode
            const
              MAX_ARMAS: integer = 2;
            end const

            algorithm leerArmas
              var
                armas: vector[MAX_ARMAS] of string;
              end var

              writeString("Nombre del arma 1: ");
              armas[1] := readString();

              writeString("Nombre del arma 2: ");
              armas[2] := readString();
            end algorithm
            ```

            ---

            ### Comparar cadenas
            En pseudocódigo se comparan directamente con `=`:

            ```pseudocode
            algorithm compararArma
              var
                armas: vector[2] of string;
                esIgual: boolean;
              end var

              armas[1] := "Espada de fuego";
              esIgual := (armas[1] = "Espada de fuego");
              writeBoolean(esIgual);
            end algorithm
            ```

            ---

            ### Ejemplo completo
            ```pseudocode
            const
              MAX_PUNTOS: integer = 3;
              MAX_ARMAS: integer = 2;
            end const

            algorithm arraysVideojuego
              var
                puntos: vector[MAX_PUNTOS] of integer;
                armas: vector[MAX_ARMAS] of string;
                esIgual: boolean;
              end var

              writeString("Introduce los puntos de 3 rondas:");
              puntos[1] := readInteger();
              puntos[2] := readInteger();
              puntos[3] := readInteger();

              writeString("Puntos registrados:");
              writeInteger(puntos[1]);
              writeInteger(puntos[2]);
              writeInteger(puntos[3]);

              armas[1] := "Espada de fuego";
              armas[2] := "Arco helado";

              writeString("Arma 1: ");
              writeString(armas[1]);
              writeString(", Arma 2: ");
              writeString(armas[2]);

              esIgual := (armas[1] = "Espada de fuego");
              writeString("¿Arma 1 es 'Espada de fuego'? ");
              writeBoolean(esIgual);
            end algorithm
            ```

            Este algoritmo combina lectura y escritura de arrays de enteros y cadenas para simular un marcador de rondas y un inventario de armas.

        questions:
          - id: c-2-inicializa-nombreplanta
            language: C
            week: 2
            prompt: |
              Incluye string

              Declara las constantes MAX_PLANTS = 5 y MAX_NAME = 25.

              Dentro de main, declara un array de cadenas nombrePlanta para los nombres de las plantas y 
              usa strncpy para inicializar el primer elemento a "Margarita".
            answer: |
              #include <string.h>
              #define MAX_PLANTS 5
              #define MAX_NAME 25

              int main() {
                  char nombrePlanta[MAX_PLANTS][MAX_NAME];
                  strncpy(nombrePlanta[0], "Margarita", MAX_NAME);
                  return 0;
              }
            hint: Usa strncpy para copiar la cadena al array de strings. No olvides pasar el tamaño máximo.

          - id: p-2-inicializa-nombreplanta
            language: Pseudocode
            week: 2
            prompt: |
              Declara la constante MAX_PLANTS = 5. 

              Dentro del algoritmo principal, declara un array de strings nombrePlanta y asigna "Margarita" al primer elemento.
            answer: |
              const
                MAX_PLANTS: integer = 5;
              end const
              algorithm
                var
                  nombrePlanta: vector[MAX_PLANTS] of string;
                end var

                nombrePlanta[1] := "Margarita";
              end algorithm
            hint: En pseudocódigo los índices empiezan en 1.

          - id: c-2-inicializa-varios-nombres
            language: C
            week: 2
            prompt: |
              Incluye string.

              Declara las constantes MAX_PLANTS = 5 y MAX_NAME = 25.

              Dentro de main, declara un array de cadenas nombrePlanta y usa strncpy para inicializar los nombres 
              "Margarita", "Rosa", "Lirio", "Orquídea", "Girasol" en el array.
            answer: |
              #include <string.h>
              #define MAX_PLANTS 5
              #define MAX_NAME 25

              int main() {
                  char nombrePlanta[MAX_PLANTS][MAX_NAME];
                  strncpy(nombrePlanta[0], "Margarita", MAX_NAME);
                  strncpy(nombrePlanta[1], "Rosa", MAX_NAME);
                  strncpy(nombrePlanta[2], "Lirio", MAX_NAME);
                  strncpy(nombrePlanta[3], "Orquídea", MAX_NAME);
                  strncpy(nombrePlanta[4], "Girasol", MAX_NAME);
                  return 0;
              }
            hint: Siempre que copies un string, usa strncpy y el tamaño máximo como tercer argumento.

          - id: p-2-inicializa-varios-nombres
            language: Pseudocode
            week: 2
            prompt: |
              Declara la constante MAX_PLANTS = 5. 
              Declara un array de strings nombrePlanta y asigna los nombres 
              "Margarita", "Rosa", "Lirio", "Orquídea", "Girasol" en el array.
            answer: |
              const
                MAX_PLANTS: integer = 5;
              end const
              algorithm
                var
                  nombrePlanta: vector[MAX_PLANTS] of string;
                end var

                nombrePlanta[1] := "Margarita";
                nombrePlanta[2] := "Rosa";
                nombrePlanta[3] := "Lirio";
                nombrePlanta[4] := "Orquídea";
                nombrePlanta[5] := "Girasol";
              end algorithm
            hint: Recuerda, índices desde 1 en pseudocódigo.

          - id: c-2-muestra-primer-nombre
            language: C
            week: 2
            prompt: |
              Incluye stdio y string.

              Declara las constantes MAX_PLANTS = 5 y MAX_NAME = 25.

              Declara un array de cadenas nombrePlanta, inicializa el primer elemento con "Margarita" usando strncpy,
              y muestra el primer nombre con printf.
            answer: |
              #include <stdio.h>
              #include <string.h>

              #define MAX_PLANTS 5
              #define MAX_NAME 25

              int main() {
                  char nombrePlanta[MAX_PLANTS][MAX_NAME];
                  strncpy(nombrePlanta[0], "Margarita", MAX_NAME);
                  printf("%s\n", nombrePlanta[0]);
                  return 0;
              }
            hint: Usa printf, recuerda el especificador de string y el salto de linea. También recuerda las bibliotecas necesarias.

          - id: p-2-muestra-primer-nombre
            language: Pseudocode
            week: 2
            prompt: |
              Declara la constante MAX_PLANTS = 5. 

              Declara un array de strings nombrePlanta, asigna "Margarita" al primer elemento 
              y muestra ese nombre con writeString.
            answer: |
              const
                MAX_PLANTS: integer = 5;
              end const
              algorithm
                var
                  nombrePlanta: vector[MAX_PLANTS] of string;
                end var

                nombrePlanta[1] := "Margarita";
                writeString(nombrePlanta[1]);
              end algorithm
            hint: Primero declaramos, después asignamos valor y finalmente imprimimos.

          - id: c-2-copia-nombre-a-otro
            language: C
            week: 2
            prompt: |
              Incluye string.

              Declara las constantes MAX_PLANTS = 5 y MAX_NAME = 25. Declara un array de cadenas nombrePlanta.

              Usa strncpy para copiar el nombre "Margarita" en el primer elemento y después usa strncpy para copiar ese mismo nombre
              al segundo elemento.
            answer: |
              #include <string.h>
              #define MAX_PLANTS 5
              #define MAX_NAME 25

              int main() {
                  char nombrePlanta[MAX_PLANTS][MAX_NAME];
                  strncpy(nombrePlanta[0], "Margarita", MAX_NAME);
                  strncpy(nombrePlanta[1], nombrePlanta[0], MAX_NAME);
                  return 0;
              }
            hint: strncpy sirve para copiar tanto un literal como de un array a otro.

          - id: p-2-copia-nombre-a-otro
            language: Pseudocode
            week: 2
            prompt: |
              Declara la constante MAX_PLANTS = 5. 

              Declara un array de strings nombrePlanta, asigna "Margarita" al primer elemento
              y copia ese nombre al segundo elemento.
            answer: |
              const
                MAX_PLANTS: integer = 5;
              end const
              algorithm
                var
                  nombrePlanta: vector[MAX_PLANTS] of string;
                end var

                nombrePlanta[1] := "Margarita";
                nombrePlanta[2] := nombrePlanta[1];
              end algorithm
            hint: En pseudocódigo puedes asignar directamente un string a otro.

          - id: c-2-array-temp
            language: C
            week: 2
            prompt: |
              Incluye stdio.

              Declara la constante MAX_PLANTAS = 4 y un array float tempPlantas.

              Inicializa los valores a 19.2, 20.5, 22.1 y 18.9 usando {}. 

              Imprime el tercer valor con el formato "Temp: x".
            answer: |
              #include <stdio.h>

              #define MAX_PLANTAS 4

              int main() {
                  float tempPlantas[MAX_PLANTAS] = {19.2, 20.5, 22.1, 18.9};
                  printf("Temp: %.1f\n", tempPlantas[2]);
                  return 0;
              }
            hint: |
              Ejemplo de ejecución: 
              Temp: 22.1
              Fijate que solo hay un decimal.

          - id: p-2-array-temp
            language: Pseudocode
            week: 2
            prompt: |
              Declara la constante MAX_PLANTAS = 4.

              Declara un array real tempPlantas.

              Inicializa los valores a 19.2, 20.5, 22.1 y 18.9. 

              Imprime el tercer valor.
            answer: |
              const
                MAX_PLANTAS: integer = 4;
              end const

              algorithm
                var
                  tempPlantas: vector[MAX_PLANTAS] of real;
                end var

                tempPlantas[1] := 19.2;
                tempPlantas[2] := 20.5;
                tempPlantas[3] := 22.1;
                tempPlantas[4] := 18.9;

                writeReal(tempPlantas[3]);
              end algorithm
            hint: |
              Ejemplo de ejecución: 
              22.1
              

          - id: c-2-acceso-paralelos
            language: C
            week: 2
            prompt: |
              Incluye stdio y string.
              
              Declara las constantes MAX_PLANTAS = 3, MAX_NOMBRE = 10.
              
              Declara nombrePlantas (cadenas) y alturaPlantas (float).
              
              Inicializa con "Loto", "Boj", "Tejo" y 1.2, 0.4, 4.8.
              
              Imprime el nombre y altura de la primera planta, cada uno en su línea.
            answer: |
              #include <stdio.h>
              #include <string.h>
              #define MAX_PLANTAS 3
              #define MAX_NOMBRE 10
          
              int main() {
                  char nombrePlantas[MAX_PLANTAS][MAX_NOMBRE];
                  float alturaPlantas[MAX_PLANTAS];
                  strncpy(nombrePlantas[0], "Loto", MAX_NOMBRE);
                  strncpy(nombrePlantas[1], "Boj", MAX_NOMBRE);
                  strncpy(nombrePlantas[2], "Tejo", MAX_NOMBRE);
                  alturaPlantas[0] = 1.2;
                  alturaPlantas[1] = 0.4;
                  alturaPlantas[2] = 4.8;
                  printf("%s\n", nombrePlantas[0]);
                  printf("%.1f\n", alturaPlantas[0]);
                  return 0;
              }
            hint: |
              Recuerda importar las bibliotecas necesarias. Y no olvides los saltos de linea y fijate que el numero solo tiene
              un decimal.
              
              Ejemplo de ejecución:
                Loto
                1.2

          - id: p-2-acceso-paralelos
            language: Pseudocode
            week: 2
            prompt: |
              Declara la constante MAX_PLANTAS = 3.
              
              Declara nombrePlantas (strings) y alturaPlantas (reales).
              
              Inicializa con "Loto", "Boj", "Tejo" y 1.2, 0.4, 4.8.
              
              Imprime el nombre y altura de la primera planta, cada uno en su línea.
            answer: |
              const
                MAX_PLANTAS: integer = 3;
              end const
              
              algorithm
                var
                  nombrePlantas: vector[MAX_PLANTAS] of string;
                  alturaPlantas: vector[MAX_PLANTAS] of real;
                end var
              
                nombrePlantas[1] := "Loto";
                nombrePlantas[2] := "Boj";
                nombrePlantas[3] := "Tejo";
                alturaPlantas[1] := 1.2;
                alturaPlantas[2] := 0.4;
                alturaPlantas[3] := 4.8;
              
                writeString(nombrePlantas[1]);
                writeReal(alturaPlantas[1]);
              end algorithm
            hint: |
              Ejemplo de ejecución:
              Loto
              1.2

          - id: c-2-leer-string
            language: C
            week: 2
            prompt: |
              Incluye stdio.
              
              Declara la constante MAX_NOMBRE = 15.
              
              Dentro de main, declara la cadena nombrePlanta y lee su valor por teclado usando scanf. Imprime el nombre en el formato "Nombre: x".
            answer: |
              #include <stdio.h>
              
              #define MAX_NOMBRE 15
          
              int main() {
                  char nombrePlanta[MAX_NOMBRE];
                  scanf("%s", nombrePlanta);
                  printf("Nombre: %s\n", nombrePlanta);
                  return 0;
              }
            hint: |
              Recuerda la biblioteca y el salto de linea en el print.
              
              Ejemplo de ejecución: 
              
              Nombre: Jacinto

          - id: p-2-leer-string
            language: Pseudocode
            week: 2
            prompt: |
              Dentro del algoritmo principal, declara una variable nombrePlanta de tipo string.
              
              Lee su valor usando readString y después imprímelo.
            answer: |
              algorithm
                var
                  nombrePlanta: string;
                end var
              
                nombrePlanta := readString();
                writeString(nombrePlanta);
              end algorithm
            hint: Recuerda usar readString para leer el dato.

          - id: c-2-leer-array-int
            language: C
            week: 2
            prompt: |
              Incluye stdio.
              
              Declara la constante MAX_PLANTAS = 3.
              
              Declara el array edadPlantas.
              
              Lee 3 valores enteros por teclado y guárdalos en el array. Imprime el segundo valor leído.
            answer: |
              #include <stdio.h>
              
              #define MAX_PLANTAS 3
              
              int main() {
                  int edadPlantas[MAX_PLANTAS];
                  scanf("%d", &edadPlantas[0]);
                  scanf("%d", &edadPlantas[1]);
                  scanf("%d", &edadPlantas[2]);
                  printf("%d\n", edadPlantas[1]);
                  return 0;
              }
            hint: |
              El usuario debe escribir 3 números. 
              
              Ejemplo entrada: 7 8 10
              
              Ejemplo salida: 8

          - id: p-2-leer-array-int
            language: Pseudocode
            week: 2
            prompt: |
              Declara la constante MAX_PLANTAS = 3.
              
              Declara el array edadPlantas.
              
              Lee 3 valores enteros usando readInteger y guárdalos en el array. Imprime el segundo valor.
            answer: |
              const
                MAX_PLANTAS: integer = 3;
              end const
              
              algorithm
                var
                  edadPlantas: vector[MAX_PLANTAS] of integer;
                end var
              
                edadPlantas[1] := readInteger();
                edadPlantas[2] := readInteger();
                edadPlantas[3] := readInteger();
              
                writeInteger(edadPlantas[2]);
              end algorithm
            hint: Recuerda, cada readInteger debe ir en línea.

  - number: 3
    explanation: |
      Explicación de semana 3
    levels:
      - number: 1
        explanation:
          C: |
            En este nivel aprenderás a representar información de videojuegos como **tipos de enemigos, nombres de personajes, vidas, estados y mapas**, utilizando enumerados, cadenas, arrays paralelos y matrices en C.  
            Estos conceptos permiten organizar datos del juego de forma clara y estructurada.

            ### Enumerados (enum)
            Sirven para definir categorías con nombres.  
            Por ejemplo, los **tipos de enemigo**:

            ```c
            typedef enum {
                ZOMBIE,
                ALIEN,
                ROBOT
            } tTipoEnemigo;

            int main() {
                tTipoEnemigo tipo = ALIEN;  // Inicialización
                return 0;
            }
            ```

            ---

            ### Arrays de enumerados
            Puedes crear un array con el tipo de cada enemigo:

            ```c
            #include <stdio.h>

            #define MAX_ENEMIGOS 3

            typedef enum {
                ZOMBIE,
                ALIEN,
                ROBOT
            } tTipoEnemigo;

            int main() {
                tTipoEnemigo enemigos[MAX_ENEMIGOS] = { ZOMBIE, ALIEN, ROBOT };
                printf("Primer enemigo: %d\n", enemigos[0]); // 0 → ZOMBIE
                return 0;
            }
            ```

            ---

            ### Cadenas con `strncpy`
            Para guardar nombres de personajes se usa un array de `char`:

            ```c
            #include <string.h>
            #define MAX_NOMBRE 20

            int main() {
                char nombre1[MAX_NOMBRE];
                char nombre2[MAX_NOMBRE];

                strncpy(nombre1, "Link", MAX_NOMBRE);
                strncpy(nombre2, "Zelda", MAX_NOMBRE);

                return 0;
            }
            ```

            ---

            ### Arrays paralelos
            Son arrays diferentes relacionados por posición.  
            Por ejemplo, un array de nombres y otro de vidas:

            ```c
            #include <stdio.h>
            #define MAX_JUGADORES 3
            #define MAX_NOMBRE 20

            int main() {
                char personaje[MAX_JUGADORES][MAX_NOMBRE] = { "Mario", "Luigi", "Peach" };
                int vidas[MAX_JUGADORES] = { 3, 2, 5 };

                printf("%s tiene %d vidas\n", personaje[0], vidas[0]);
                return 0;
            }
            ```

            Cada índice representa un jugador:
            - `personaje[0] = "Mario"` y `vidas[0] = 3`  
            - `personaje[1] = "Luigi"` y `vidas[1] = 2`  
            - `personaje[2] = "Peach"` y `vidas[2] = 5`  

            ---

            ### Booleanos y ternario
            Puedes guardar si una misión está completada:

            ```c
            #include <stdio.h>
            #include <stdbool.h>

            #define MAX_MISIONES 2

            int main() {
                bool misionCompletada[MAX_MISIONES] = { true, false };

                printf("%s\n", misionCompletada[0] ? "Completada" : "Pendiente");
                return 0;
            }
            ```

            ---

            ### Matriz booleana
            Las matrices permiten representar una cuadrícula.  
            Por ejemplo, casillas de un mapa exploradas o no:

            ```c
            #include <stdio.h>
            #include <stdbool.h>

            int main() {
                bool mapa[2][3] = {
                    { true, false, true },
                    { false, true, false }
                };

                printf("Fila 0, Col 1: %d\n", mapa[0][1]);
                return 0;
            }
            ```

            ---

            ### Entrada con `scanf`
            Puedes pedir al jugador que introduzca la salud de un personaje:

            ```c
            #include <stdio.h>

            int main() {
                int salud[2];
                printf("Introduce la salud de Link: ");
                scanf("%d", &salud[0]);

                printf("Salud de Link: %d\n", salud[0]);
                return 0;
            }
            ```

            ---

            ### Ejemplo completo
            ```c
            #include <stdio.h>
            #include <stdbool.h>
            #include <string.h>

            #define MAX_JUGADORES 3
            #define MAX_NOMBRE 20
            #define MAX_MISIONES 2

            typedef enum {
                ZOMBIE, ALIEN, ROBOT
            } tTipoEnemigo;

            int main() {
                // Arrays paralelos
                char personaje[MAX_JUGADORES][MAX_NOMBRE] = { "Mario", "Luigi", "Peach" };
                int vidas[MAX_JUGADORES] = { 3, 2, 5 };

                // Estado de misiones
                bool misionCompletada[MAX_MISIONES] = { true, false };

                // Matriz booleana de mapa
                bool mapa[2][3] = {
                    { true, false, true },
                    { false, true, false }
                };

                // Entrada de datos
                int salud[2];
                printf("Introduce la salud de Link: ");
                scanf("%d", &salud[0]);

                // Salidas
                printf("%s tiene %d vidas\n", personaje[0], vidas[0]);
                printf("Misión 1: %s\n", misionCompletada[0] ? "Completada" : "Pendiente");
                printf("Mapa Fila 0, Col 1: %d\n", mapa[0][1]);
                printf("Salud de Link: %d\n", salud[0]);

                return 0;
            }
            ```

            Este programa combina enumerados, cadenas, arrays paralelos y matrices para representar un estado de videojuego.

          Pseudocode: |
            En este nivel aprenderás a representar información de videojuegos como **enemigos, nombres de personajes, vidas y mapas**, utilizando enumerados, cadenas, arrays paralelos y matrices en pseudocódigo.  
            Esto permite organizar datos del juego de manera clara.

            ### Enumerados
            ```pseudocode
            type
              tTipoEnemigo = { ZOMBIE, ALIEN, ROBOT }
            end type

            algorithm
              var
                estado: tTipoEnemigo;
              end var

              estado := ALIEN;
              writeEnum(estado);
            end algorithm
            ```

            ---

            ### Cadenas
            ```pseudocode
            algorithm
              var
                personaje: vector[2] of string;
              end var

              personaje[1] := "Mario";
              personaje[2] := "Peach";

              writeString(personaje[1]);
              writeString(personaje[2]);
            end algorithm
            ```

            ---

            ### Arrays paralelos
            ```pseudocode
            algorithm
              var
                personaje: vector[2] of string;
                vidas: vector[2] of integer;
              end var

              personaje[1] := "Mario";
              vidas[1] := 3;

              personaje[2] := "Luigi";
              vidas[2] := 2;

              writeString(personaje[1]);
              writeInteger(vidas[1]);
            end algorithm
            ```

            ---

            ### Booleanos
            ```pseudocode
            algorithm
              var
                mision: vector[2] of boolean;
              end var

              mision[1] := true;
              mision[2] := false;

              writeBoolean(mision[1]);
            end algorithm
            ```

            ---

            ### Matriz booleana
            ```pseudocode
            algorithm
              var
                mapa: vector[2][2] of boolean;
              end var

              mapa[1][1] := true;
              mapa[1][2] := false;
              mapa[2][1] := true;
              mapa[2][2] := false;

              writeBoolean(mapa[1][2]);
            end algorithm
            ```

            ---

            ### Lectura de datos
            ```pseudocode
            algorithm
              var
                vidas: vector[2] of integer;
              end var

              writeString("Introduce las vidas del jugador 1: ");
              vidas[1] := readInteger();

              writeString("Vidas del jugador 1: ");
              writeInteger(vidas[1]);
            end algorithm
            ```

            ---

            ### Ejemplo completo
            ```pseudocode
            type
              tTipoEnemigo = { ZOMBIE, ALIEN, ROBOT }
            end type

            algorithm estadoJuego
              var
                personaje: vector[2] of string;
                vidas: vector[2] of integer;
                mision: vector[2] of boolean;
                mapa: vector[2][2] of boolean;
                salud: vector[2] of integer;
                estado: tTipoEnemigo;
              end var

              personaje[1] := "Mario";
              vidas[1] := 3;

              personaje[2] := "Luigi";
              vidas[2] := 2;

              mision[1] := true;
              mision[2] := false;

              mapa[1][1] := true;
              mapa[1][2] := false;
              mapa[2][1] := true;
              mapa[2][2] := false;

              writeString("Introduce la salud de Mario: ");
              salud[1] := readInteger();

              estado := ALIEN;

              writeString(personaje[1]);
              writeString(" tiene ");
              writeInteger(vidas[1]);
              writeString(" vidas");

              writeString(", Misión 1: ");
              writeBoolean(mision[1]);

              writeString(", Casilla (1,2): ");
              writeBoolean(mapa[1][2]);

              writeString(", Salud de Mario: ");
              writeInteger(salud[1]);

              writeString(", Estado enemigo: ");
              writeEnum(estado);
            end algorithm
            ```

            Este algoritmo combina enumerados, cadenas, arrays paralelos y matrices para representar un estado de videojuego.

        questions:
          - id: c-3-enum-declaracion
            language: C
            week: 3
            prompt: |
              Declara la constante MAX_ANIMALES = 3.

              Declara un enumerado tTipoAnimal con los valores PERRO, GATO y AVE.

              Dentro de main, declara un array tipoAnimal de tipo tTipoAnimal inicializado con PERRO, GATO y AVE usando llaves {}.
            answer: |
              #define MAX_ANIMALES 3

              typedef enum {
                  PERRO,
                  GATO,
                  AVE
              } tTipoAnimal;

              int main() {
                  tTipoAnimal tipoAnimal[MAX_ANIMALES] = { PERRO, GATO, AVE };
                  return 0;
              }
            hint: Los enumerativos se inicializan igual que los enteros usando sus etiquetas. No olvides la función main y el return 0.

          - id: p-3-enum-declaracion
            language: Pseudocode
            week: 3
            prompt: |
              Declara la constante MAX_ANIMALES = 3.

              Declara el tipo enumerado tTipoAnimal con los valores PERRO, GATO y AVE.

              Dentro del algoritmo principal, declara un array tipoAnimal de tTipoAnimal, inicializado con PERRO, GATO y AVE.
            answer: |
              const
                MAX_ANIMALES: integer = 3;
              end const

              type
                tTipoAnimal = { PERRO, GATO, AVE }
              end type

              algorithm
                var
                  tipoAnimal: vector[MAX_ANIMALES] of tTipoAnimal;
                end var

                tipoAnimal[1] := PERRO;
                tipoAnimal[2] := GATO;
                tipoAnimal[3] := AVE;
              end algorithm
            hint: Enum en pseudocódigo siempre van entre { }.

          - id: c-3-nombres-strncpy
            language: C
            week: 3
            prompt: |
              Incluye string y stdio

              Declara las constantes MAX_ANIMALES = 2 y MAX_NOMBRE = 15.

              Dentro de main, declara dos cadenas de caracteres usando MAX_NOMBRE: nombre1 y nombre2.

              Inicializa nombre1 y nombre2 con "Nina" y "Rocky" respectivamente usando strncpy.
            answer: |
              #include <stdio.h>
              #include <string.h>

              #define MAX_ANIMALES 2
              #define MAX_NOMBRE 15

              int main() {
                  char nombre1[MAX_NOMBRE];
                  char nombre2[MAX_NOMBRE];
                  strncpy(nombre1, "Nina", MAX_NOMBRE);
                  strncpy(nombre2, "Rocky", MAX_NOMBRE);
                  return 0;
              }
            hint: strncpy(destino, origen, tamaño) para inicializar strings.

          - id: p-3-nombres-strings
            language: Pseudocode
            week: 3
            prompt: |
              Declara la constante MAX_ANIMALES = 2.

              Dentro del algoritmo principal, declara un array nombre de strings para dos animales.

              Inicializa nombre[1] con "Nina" y nombre[2] con "Rocky".
            answer: |
              const
                MAX_ANIMALES: integer = 2;
              end const

              algorithm
                var
                  nombre: vector[MAX_ANIMALES] of string;
                end var

                nombre[1] := "Nina";
                nombre[2] := "Rocky";
              end algorithm
            hint:

          - id: c-3-ternario-vacunado
            language: C
            week: 3
            prompt: |
              Incluye stdio y stdbool.
              
              Declara la constante MAX_ANIMALES = 2 y un array booleano vacunado inicializado con true y false con {}.
              
              Imprime usando printf y el operador ternario: "Vacunado" si el primer animal está vacunado, "No vacunado" si no lo está.
              
              Ejemplo de salida: "Vacunado"
            answer: |
              #include <stdio.h>
              #include <stdbool.h>
              
              #define MAX_ANIMALES 2
              
              int main() {
                  bool vacunado[MAX_ANIMALES] = { true, false };
                  printf("%s\n", vacunado[0] ? "Vacunado" : "No vacunado");
                  return 0;
              }
            hint: "Recuerda la sintaxis del operador ternario: condicion ? valor_si_true : valor_si_false"

          - id: c-3-arrays-paralelos
            language: C
            week: 3
            prompt: |
              Incluye stdio.
              
              Declara las constantes MAX_ANIMALES = 3 y MAX_NOMBRE = 15.
              
              Dentro de main, declara un array de cadenas de caracteres con MAX_ANIMALES y MAX_NOMBRE y un array de enteros edad con (MAX_ANIMALES).
              
              Inicializa los arrays usando llaves {}, con los nombres "Bobby", "Lili", "Rex" y las edades 2, 5, 3.
              
              Imprime en diferentes líneas cada nombre seguido de la edad, usando printf, en el formato: "Nombre: Bobby, Edad: 2".
            answer: |
              #include <stdio.h>
              
              #define MAX_ANIMALES 3
              #define MAX_NOMBRE 15
              
              int main() {
                  char nombre[MAX_ANIMALES][MAX_NOMBRE] = { "Bobby", "Lili", "Rex" };
                  int edad[MAX_ANIMALES] = { 2, 5, 3 };
                  printf("Nombre: %s, Edad: %d\n", nombre[0], edad[0]);
                  printf("Nombre: %s, Edad: %d\n", nombre[1], edad[1]);
                  printf("Nombre: %s, Edad: %d\n", nombre[2], edad[2]);
                  return 0;
              }
            hint: Cada printf debe estar en una línea diferente y no olvides el salto de linea.

          - id: p-3-arrays-paralelos
            language: Pseudocode
            week: 3
            prompt: |
              Declara la constante MAX_ANIMALES = 3.
              
              Dentro del algoritmo principal, declara un array nombre de strings y un array edad de enteros para tres animales.
              
              Inicializa nombre con "Bobby", "Lili", "Rex" y edad con 2, 5, 3.
              
              Imprime el nombre y la edad de cada animal, uno por línea, usando writeString y writeInteger.
              
              Ejemplo de salida:
                Nombre: Bobby
                Edad: 2
                Nombre: Lili
                Edad: 5
                Nombre: Rex
                Edad: 3
            answer: |
              const
                MAX_ANIMALES: integer = 3;
              end const
              
              algorithm
                var
                  nombre: vector[MAX_ANIMALES] of string;
                  edad: vector[MAX_ANIMALES] of integer;
                end var
              
                nombre[1] := "Bobby";
                nombre[2] := "Lili";
                nombre[3] := "Rex";
              
                edad[1] := 2;
                edad[2] := 5;
                edad[3] := 3;
              
                writeString("Nombre: ");
                writeString(nombre[1]);
                writeString("Edad: ");
                writeInteger(edad[1]);
                writeString("Nombre: ");
                writeString(nombre[2]);
                writeString("Edad: ");
                writeInteger(edad[2]);
                writeString("Nombre: ");
                writeString(nombre[3]);
                writeString("Edad: ");
                writeInteger(edad[3]);
              end algorithm
            hint: Cada writeString/writeInteger en su línea.

          - id: c-3-matriz-booleana
            language: C
            week: 3
            prompt: |
              Incluye stdio y stdbool.
              
              Declara las constantes FILAS = 2 y COLUMNAS = 3.
              
              Dentro de main, declara una matriz de booleanos estadoVacuna con FILAS x COLUMNAS e inicialízala manualmente con: 
                fila 0: true, false, true
                fila 1: false, true, false
              
              Imprime el valor de cada casilla en una línea con printf. 
              
              Ejemplo: "Fila 0, Col 0: 1" (donde 1 es true y 0 es false)
            answer: |
              #include <stdio.h>
              #include <stdbool.h>
              
              #define FILAS 2
              #define COLUMNAS 3
              
              int main() {
                  bool estadoVacuna[FILAS][COLUMNAS];
                  estadoVacuna[0][0] = true;
                  estadoVacuna[0][1] = false;
                  estadoVacuna[0][2] = true;
                  estadoVacuna[1][0] = false;
                  estadoVacuna[1][1] = true;
                  estadoVacuna[1][2] = false;
              
                  printf("Fila 0, Col 0: %d\n", estadoVacuna[0][0]);
                  printf("Fila 0, Col 1: %d\n", estadoVacuna[0][1]);
                  printf("Fila 0, Col 2: %d\n", estadoVacuna[0][2]);
                  printf("Fila 1, Col 0: %d\n", estadoVacuna[1][0]);
                  printf("Fila 1, Col 1: %d\n", estadoVacuna[1][1]);
                  printf("Fila 1, Col 2: %d\n", estadoVacuna[1][2]);
                  return 0;
              }
            hint: Imprime todos los valores de la matriz, un dato por línea.

          - id: p-3-matriz-booleana
            language: Pseudocode
            week: 3
            prompt: |
              Declara las constantes FILAS = 2 y COLUMNAS = 3.
              
              Dentro del algoritmo principal, declara una matriz booleana estadoVacuna con FILAS x COLUMNAS e inicialízala manualmente con: 
                fila 1: true, false, true
                fila 2: false, true, false
              
              Imprime el valor de cada casilla, uno por línea, usando writeBoolean.
              
              Ejemplo de salida:
                true
                false
                true
                ...
            answer: |
              const
                FILAS: integer = 2;
                COLUMNAS: integer = 3;
              end const
              
              algorithm
                var
                  estadoVacuna: vector[FILAS][COLUMNAS] of boolean;
                end var
              
                estadoVacuna[1][1] := true;
                estadoVacuna[1][2] := false;
                estadoVacuna[1][3] := true;
                estadoVacuna[2][1] := false;
                estadoVacuna[2][2] := true;
                estadoVacuna[2][3] := false;
              
                writeBoolean(estadoVacuna[1][1]);
                writeBoolean(estadoVacuna[1][2]);
                writeBoolean(estadoVacuna[1][3]);
                writeBoolean(estadoVacuna[2][1]);
                writeBoolean(estadoVacuna[2][2]);
                writeBoolean(estadoVacuna[2][3]);
              end algorithm
            hint: Escribe un dato por línea, usando writeBoolean.

          - id: c-3-lee-edad
            language: C
            week: 3
            prompt: |
              Incluye stdio.
              
              Declara la constante MAX_ANIMALES = 2.
              
              Dentro de main, declara un array de enteros edad. 
              
              Pide al usuario que introduzca las edades usando scanf, guardando los valores en el primer y segundo elemento del array.
              
              Usa el siguiente formato:
                "Introduce la edad del animal 1: "
                "Introduce la edad del animal 2: "
            answer: |
              #include <stdio.h>
              
              #define MAX_ANIMALES 2
              
              int main() {
                  int edad[MAX_ANIMALES];
                  printf("Introduce la edad del animal 1: ");
                  scanf("%d", &edad[0]);
                  printf("Introduce la edad del animal 2: ");
                  scanf("%d", &edad[1]);
                  return 0;
              }
            hint: recuerda el especificador de formato de los enteros para leer el dato.

          - id: p-3-lee-edad
            language: Pseudocode
            week: 3
            prompt: |
              Declara la constante MAX_ANIMALES = 2.
              
              Dentro del algoritmo principal, declara un array edad de enteros.
              
              Pide al usuario que introduzca las edades con readInteger y guarda los valores en el primer y segundo elemento del array.
            answer: |
              const
                MAX_ANIMALES: integer = 2;
              end const
              
              algorithm
                var
                  edad: vector[MAX_ANIMALES] of integer;
                end var
              
                writeString("Introduce la edad del animal 1: ");
                edad[1] := readInteger();
                writeString("Introduce la edad del animal 2: ");
                edad[2] := readInteger();
              end algorithm
            hint: Lee y guarda cada valor por separado. Los indices empiezan en 1.

      - number: 2
        explanation:
          C: |
            En este nivel aprenderás a **tomar decisiones en tus programas** usando estructuras condicionales como `if`, `else`, `else if`, `strcmp`, el operador ternario y `switch`.  
            Estas herramientas son fundamentales en los videojuegos para decidir acciones, comparar valores o controlar estados.

            ### if
            El `if` permite ejecutar una acción si una condición es verdadera.  
            Por ejemplo, decidir si un Pokémon está en forma para la batalla:

            ```c
            #include <stdio.h>

            int main() {
                int salud;
                printf("Introduce la salud del Pokémon: ");
                scanf("%d", &salud);

                if (salud > 50) {
                    printf("Listo para luchar\n");
                }
                return 0;
            }
            ```

            ---

            ### if...else
            Con `else` puedes ejecutar una alternativa si la condición no se cumple:

            ```c
            #include <stdio.h>
            #include <stdbool.h>

            int main() {
                bool tienePocion;
                printf("¿Tienes poción? (1 = sí, 0 = no): ");
                scanf("%d", &tienePocion);

                if (tienePocion) {
                    printf("Usas la poción\n");
                } else {
                    printf("No puedes curarte\n");
                }
                return 0;
            }
            ```

            ---

            ### if...else if...else
            Para múltiples condiciones, puedes usar `else if`:

            ```c
            #include <stdio.h>

            int main() {
                int nivel;
                printf("Nivel del jugador: ");
                scanf("%d", &nivel);

                if (nivel < 5) {
                    printf("Novato\n");
                } else if (nivel <= 10) {
                    printf("Intermedio\n");
                } else {
                    printf("Experto\n");
                }
                return 0;
            }
            ```

            ---

            ### strcmp
            `strcmp(cadena1, cadena2)` compara dos cadenas. Devuelve **0 si son iguales**:

            ```c
            #include <stdio.h>
            #include <string.h>

            int main() {
                char nombre1[10];
                char nombre2[10];

                strncpy(nombre1, "Link", 10);
                strncpy(nombre2, "Zelda", 10);

                printf("%s\n", strcmp(nombre1, nombre2) == 0 ? "Mismos personajes" : "Distintos personajes");
                return 0;
            }
            ```

            ---

            ### Operador ternario anidado para enums
            Puedes convertir un enum a texto usando ternarios:

            ```c
            #include <stdio.h>
            #include <string.h>

            typedef enum { MAGE, WARRIOR, ROGUE } tClase;

            int main() {
                tClase claseJugador = MAGE;
                char claseStr[20];

                strncpy(claseStr,
                    (claseJugador == MAGE) ? "Mago" :
                    (claseJugador == WARRIOR) ? "Guerrero" : "Pícaro",
                    20);

                printf("Clase: %s\n", claseStr);
                return 0;
            }
            ```

            ---

            ### switch
            Cuando tienes varios casos posibles para un mismo valor, puedes usar `switch`:

            ```c
            #include <stdio.h>

            int main() {
                int opcion;
                printf("Elige tu clase (1-Mago, 2-Guerrero, 3-Arquero): ");
                scanf("%d", &opcion);

                switch (opcion) {
                    case 1:
                        printf("Has elegido Mago\n");
                        break;
                    case 2:
                        printf("Has elegido Guerrero\n");
                        break;
                    case 3:
                        printf("Has elegido Arquero\n");
                        break;
                    default:
                        printf("Opción no válida\n");
                }
                return 0;
            }
            ```

            ---

            ### Ejemplo completo
            ```c
            #include <stdio.h>
            #include <stdbool.h>
            #include <string.h>

            typedef enum { MAGE, WARRIOR, ROGUE } tClase;

            int main() {
                int salud = 60;
                bool tienePocion = true;
                char nombre1[10] = "Link";
                char nombre2[10] = "Zelda";
                tClase claseJugador = WARRIOR;
                int opcion = 2;
                char claseStr[20];

                // if simple
                if (salud > 50) {
                    printf("Listo para luchar\n");
                }

                // if...else
                if (tienePocion) {
                    printf("Usas la poción\n");
                } else {
                    printf("No puedes curarte\n");
                }

                // strcmp con ternario
                printf("%s\n", strcmp(nombre1, nombre2) == 0 ? "Mismos personajes" : "Distintos personajes");

                // Enum a string con ternario
                strncpy(claseStr,
                    (claseJugador == MAGE) ? "Mago" :
                    (claseJugador == WARRIOR) ? "Guerrero" : "Pícaro",
                    20);
                printf("Clase: %s\n", claseStr);

                // switch
                switch (opcion) {
                    case 1:
                        printf("Has elegido Mago\n");
                        break;
                    case 2:
                        printf("Has elegido Guerrero\n");
                        break;
                    case 3:
                        printf("Has elegido Arquero\n");
                        break;
                    default:
                        printf("Opción no válida\n");
                }
                return 0;
            }
            ```

            Este programa combina todas las estructuras condicionales para simular distintas decisiones de un videojuego.

          Pseudocode: |
            En este nivel aprenderás a **tomar decisiones en tus algoritmos** usando `if`, `else`, `else if` y `switch`.  
            Son muy útiles en videojuegos para controlar acciones, comparar valores o traducir estados a texto.

            ### if
            Ejecuta una acción si se cumple una condición:

            ```pseudocode
            algorithm
              var
                salud: integer;
              end var

              writeString("Introduce la salud del personaje: ");
              salud := readInteger();

              if salud > 50 then
                writeString("Listo para luchar");
              end if
            end algorithm
            ```

            ---

            ### if...else
            Ejecuta una alternativa si no se cumple la condición:

            ```pseudocode
            algorithm
              var
                tieneEspada: boolean;
              end var

              writeString("¿Tienes espada? (true/false): ");
              tieneEspada := readBoolean();

              if tieneEspada then
                writeString("Puedes atacar");
              else
                writeString("Necesitas un arma");
              end if
            end algorithm
            ```

            ---

            ### if...else if...else
            Puedes verificar varias condiciones:

            ```pseudocode
            algorithm
              var
                nivel: integer;
              end var

              writeString("Introduce el nivel del monstruo: ");
              nivel := readInteger();

              if nivel < 5 then
                writeString("Fácil");
              else
                if nivel <= 10 then
                  writeString("Normal");
                else
                  writeString("Difícil");
                end if
              end if
            end algorithm
            ```

            ---

            ### Comparar cadenas
            En pseudocódigo se comparan directamente con `=`:

            ```pseudocode
            algorithm
              var
                nombre1: string;
                nombre2: string;
              end var

              nombre1 := "Mario";
              nombre2 := "Luigi";

              if nombre1 = nombre2 then
                writeString("Iguales");
              else
                writeString("Distintos");
              end if
            end algorithm
            ```

            ---

            ### Convertir enums a texto con if anidado
            ```pseudocode
            type
              tClase = { MAGO, GUERRERO, ARQUERO }
            end type

            algorithm
              var
                claseJugador: tClase;
                claseStr: string;
              end var

              claseJugador := MAGO;

              if claseJugador = MAGO then
                claseStr := "Mago";
              else
                if claseJugador = GUERRERO then
                  claseStr := "Guerrero";
                else
                  claseStr := "Arquero";
                end if
              end if

              writeString(claseStr);
            end algorithm
            ```

            ---

            ### switch
            Elige una acción según el número introducido por el usuario:

            ```pseudocode
            algorithm
              var
                clase: integer;
              end var

              writeString("Elige una clase (1-Mago, 2-Guerrero, 3-Arquero): ");
              clase := readInteger();

              switch clase
                case 1 then
                  writeString("Has elegido Mago");
                end case
                case 2 then
                  writeString("Has elegido Guerrero");
                end case
                case 3 then
                  writeString("Has elegido Arquero");
                end case
                case default then
                  writeString("Opción no válida");
                end case
              end switch
            end algorithm
            ```

            ---

            ### Ejemplo completo
            ```pseudocode
            type
              tClase = { MAGO, GUERRERO, ARQUERO }
            end type

            algorithm decisionesJuego
              var
                salud: integer;
                tienePocion: boolean;
                nombre1: string;
                nombre2: string;
                claseJugador: tClase;
                clase: integer;
                claseStr: string;
              end var

              salud := 60;
              tienePocion := true;
              nombre1 := "Link";
              nombre2 := "Zelda";
              claseJugador := GUERRERO;
              clase := 2;

              if salud > 50 then
                writeString("Listo para luchar");
              end if

              if tienePocion then
                writeString(", Usas la poción");
              else
                writeString(", No puedes curarte");
              end if

              if nombre1 = nombre2 then
                writeString(", Mismos personajes");
              else
                writeString(", Distintos personajes");
              end if

              if claseJugador = MAGO then
                claseStr := "Mago";
              else
                if claseJugador = GUERRERO then
                  claseStr := "Guerrero";
                else
                  claseStr := "Arquero";
                end if
              end if

              writeString(", Clase: ");
              writeString(claseStr);

              switch clase
                case 1 then
                  writeString(", Has elegido Mago");
                end case
                case 2 then
                  writeString(", Has elegido Guerrero");
                end case
                case 3 then
                  writeString(", Has elegido Arquero");
                end case
                case default then
                  writeString(", Opción no válida");
                end case
              end switch
            end algorithm
            ```

            Este algoritmo combina todas las estructuras condicionales para simular distintas decisiones de un videojuego.

        questions:

          - id: c-3-if-simple
            language: C
            week: 3
            prompt: |
              Incluye stdio.
              
              Dentro de main, declara una variable edad y pídele al usuario que la introduzca.
              
              Usa el formato de pregunta: "Introduce la edad del animal: ".
              
              Usa un if para comprobar si la edad es mayor que 10. Si lo es, imprime "Mayor que 10".
            answer: |
              #include <stdio.h>
              
              int main() {
                  int edad;
              
                  printf("Introduce la edad del animal: ");
                  scanf("%d", &edad);
              
                  if(edad > 10) {
                      printf("Mayor que 10\n");
                  }
              
                  return 0;
              }
            hint: Usa if y no olvides el salto de linea. Recuerda que para leer cualquier dato que no sea un string necesitamos el operador &.

          - id: p-3-if-simple
            language: Pseudocode
            week: 3
            prompt: |
              Dentro del algoritmo principal, declara una variable edad, pide el valor al usuario.
              
              Usa el formato de pregunta: "Introduce la edad del animal: ".
              
              Usa un if para comprobar si la edad es mayor que 10. Si lo es, imprime "Mayor que 10".
            

            answer: |
              
              algorithm
                var
                  edad: integer;
                end var
              
                writeString("Introduce la edad del animal: ");
                edad := readInteger();
              
                if edad > 10 then
                  writeString("Mayor que 10");
                end if
              end algorithm
            hint: No hace falta else.

          - id: c-3-if-else
            language: C
            week: 3
            prompt: |
              Incluye stdio.h.
              
              Dentro de main, declara una variable vacunado (bool) y pide al usuario un número (0 para no vacunado, 1 para vacunado).
              
              Usa un if else para imprimir "Vacunado" o "No vacunado". 
              
              Usa este formato de pregunta: "¿El animal está vacunado? (1 = sí, 0 = no): "
            answer: |
              #include <stdio.h>
              #include <stdbool.h>
              
              int main() {
                  bool vacunado;
              
                  printf("¿El animal está vacunado? (1 = sí, 0 = no): ");
                  scanf("%d", &vacunado);
              
                  if(vacunado) {
                      printf("Vacunado\n");
                  } else {
                      printf("No vacunado\n");
                  }
                  return 0;
              }
            hint: El valor 0 es false, 1 es true.

          - id: p-3-if-else
            language: Pseudocode
            week: 3
            prompt: |
              Dentro del algoritmo principal, declara una variable vacunado (boolean).
              
              Pide al usuario que introduzca true o false (usa readBoolean). 
              
              Usa un if else para imprimir "Vacunado" o "No vacunado".
              
              Usa este formato de pregunta: "¿El animal está vacunado? (true/false): "
            answer: |
              algorithm
                var
                  vacunado: boolean;
                end var
              
                writeString("¿El animal está vacunado? (true/false): ");
                vacunado := readBoolean();
              
                if vacunado then
                  writeString("Vacunado");
                else
                  writeString("No vacunado");
                end if
              end algorithm
            hint: Usa readBoolean para leer el dato.

          - id: c-3-compara-strcmp
            language: C
            week: 3
            prompt: |
              Incluye string y stdio.
              
              Declara la constante MAX_NOMBRE = 10.
              
              Dentro de main, declara dos cadenas de caracteres nombre1 y nombre2 inicializados con "Kira" y "Max" usando strncpy.
              
              Usa strcmp para comparar si son iguales. Si lo son, imprime "Nombres iguales", si no, imprime "Nombres diferentes".
            answer: |
              #include <stdio.h>
              #include <string.h>
              
              #define MAX_NOMBRE 10
              
              int main() {
                  char nombre1[MAX_NOMBRE];
                  char nombre2[MAX_NOMBRE];
              
                  strncpy(nombre1, "Kira", MAX_NOMBRE);
                  strncpy(nombre2, "Max", MAX_NOMBRE);
              
                  if(strcmp(nombre1, nombre2) == 0) {
                      printf("Nombres iguales\n");
                  } else {
                      printf("Nombres diferentes\n");
                  }
                  return 0;
              }
            hint: strcmp devuelve 0 si las cadenas son iguales. No olvides los saltos de linea.

          - id: p-3-compara-strings
            language: Pseudocode
            week: 3
            prompt: |
              Declara la constante MAX_ANIMALES = 2.
              
              Dentro del algoritmo principal, declara un array nombre de strings para dos animales.
              
              Inicializa nombre[1] con "Kira" y nombre[2] con "Max".
              
              Si los nombres son iguales, imprime "Nombres iguales", si no, imprime "Nombres diferentes".
            answer: |
              const
                MAX_ANIMALES: integer = 2;
              end const
              
              algorithm
                var
                  nombre: vector[MAX_ANIMALES] of string;
                end var
              
                nombre[1] := "Kira";
                nombre[2] := "Max";
              
                if nombre[1] = nombre[2] then
                  writeString("Nombres iguales");
                else
                  writeString("Nombres diferentes");
                end if
              end algorithm
            hint: En pseudocódigo puedes comparar strings con = .


          - id: c-3-if-else-encadenado
            language: C
            week: 3
            prompt: |
              Incluye stdio.
              
              Dentro de main, declara una variable edad y pide al usuario una edad y usa if, else if y else para imprimir:
              - "Joven" si la edad es menor que 5,
              - "Adulto" si es entre 5 y 10 (ambos inclusive),
              - "Senior" si es mayor de 10.
              
              Usa el siguiente formato de pregunta: "Introduce la edad del animal: "
            answer: |
              #include <stdio.h>
              
              int main() {
                  int edad;
              
                  printf("Introduce la edad del animal: ");
                  scanf("%d", &edad);
              
                  if(edad < 5) {
                      printf("Joven\n");
                  } else if(edad <= 10) {
                      printf("Adulto\n");
                  } else {
                      printf("Senior\n");
                  }
                  return 0;
              }
            hint: Usa ifs encadenados. No olvides los saltos de linea.

          - id: p-3-if-else-encadenado
            language: Pseudocode
            week: 3
            prompt: |
              Dentro del algoritmo principal, declara una variable edad, pide una edad al usuario y usa if, else, if anidados para imprimir:
              - "Joven" si la edad es menor que 5,
              - "Adulto" si es entre 5 y 10 (ambos inclusive),
              - "Senior" si es mayor de 10.
              
              Usa el siguiente formato de pregunta: "Introduce la edad del animal: "

            answer: |
              algorithm
                var
                  edad: integer;
                end var
              
                writeString("Introduce la edad del animal: ");
                edad := readInteger();
              
                if edad < 5 then
                  writeString("Joven");
                else
                  if edad <= 10 then
                    writeString("Adulto");
                  else
                    writeString("Senior");
                  end if
                end if
              end algorithm
            hint: Usa if anidados.


          - id: c-3-enum-to-string-ternario
            language: C
            week: 3
            prompt: |
              Incluye string y stdio.

              Declara la constante MAX_ANIMALES = 3

              Declara un enumerado tTipoAnimal con PERRO, GATO y AVE.

              Declara un array tipoAnimal de tTipoAnimal inicializado con PERRO, GATO y AVE usando {}.

              Declara una cadena de caracteres tipoStr de longitud 20 (Usa el valor directo).

              Copia en tipoStr el nombre del primer animal usando strncpy y el operador ternario anidado para convertir el enum a string ("Perro", "Gato" o "Ave").

              Resumiendo, debes guardar el tipo de animal en un formato string. Para convertir el enumerativo en string, usaras el operador ternario.
            answer: |
              #include <stdio.h>
              #include <string.h>

              #define MAX_ANIMALES 3

              typedef enum {
                  PERRO, GATO, AVE
              } tTipoAnimal;

              int main() {
                  tTipoAnimal tipoAnimal[MAX_ANIMALES] = { PERRO, GATO, AVE };
                  char tipoStr[20];
                  strncpy(tipoStr,
                      (tipoAnimal[0] == PERRO) ? "Perro" :
                      (tipoAnimal[0] == GATO) ? "Gato" : "Ave",
                      20);
                  return 0;
              }
            hint: Usa strncpy siempre y pon el tamaño como tercer parámetro. En el segundo parametro debe ir el operador ternario anidado.

          - id: p-3-enum-to-string-anidado
            language: Pseudocode
            week: 3
            prompt: |
              Declara la constante MAX_ANIMALES = 3.

              Declara el tipo enumerado tTipoAnimal con PERRO, GATO y AVE.

              Dentro del algoritmo principal, declara un array tipoAnimal de tTipoAnimal inicializado con PERRO, GATO y AVE.

              Declara una variable tipoStr de tipo string.

              Si tipoAnimal[1] es PERRO, tipoStr debe ser "Perro"; si es GATO, "Gato"; si es AVE, "Ave".

              Para lograrlo deberás usar if else if anidados.
            answer: |
              const
                MAX_ANIMALES: integer = 3;
              end const

              type
                tTipoAnimal = { PERRO, GATO, AVE }
              end type

              algorithm
                var
                  tipoAnimal: vector[MAX_ANIMALES] of tTipoAnimal;
                  tipoStr: string;
                end var

                tipoAnimal[1] := PERRO;
                tipoAnimal[2] := GATO;
                tipoAnimal[3] := AVE;

                if tipoAnimal[1] = PERRO then
                  tipoStr := "Perro";
                else
                  if tipoAnimal[1] = GATO then
                    tipoStr := "Gato";
                  else
                    tipoStr := "Ave";
                  end if
                end if
              end algorithm
            hint: Deberas usar if else if... Los anidados son if dentro de else.


          - id: c-3-switch
            language: C
            week: 3
            prompt: |
              Incluye stdio.h.
              
              Dentro de main, crea una variable entera opcion y pide al usuario un entero entre 1 y 3.
              
              Usa el siguiente formato: "Introduce el tipo de animal (1-Perro, 2-Gato, 3-Ave): 1"
              
              Usa switch para imprimir:
                1 → "Perro"
                2 → "Gato"
                3 → "Ave"
                cualquier otro → "Opción inválida"

            answer: |
              #include <stdio.h>
              
              int main() {
                  int opcion;
              
                  printf("Introduce el tipo de animal (1-Perro, 2-Gato, 3-Ave): ");
                  scanf("%d", &opcion);
              
                  switch(opcion) {
                      case 1:
                          printf("Perro\n");
                          break;
                      case 2:
                          printf("Gato\n");
                          break;
                      case 3:
                          printf("Ave\n");
                          break;
                      default:
                          printf("Opción inválida\n");
                  }
                  return 0;
              }
            hint: Usa switch...case...break. Y recuerda los saltos de linea.

          - id: p-3-switch
            language: Pseudocode
            week: 3
            prompt: |
              Dentro del algoritmo principal, crea una variable entera opcion y pide al usuario un entero entre 1 y 3.
              
              Usa el siguiente formato: "Introduce el tipo de animal (1-Perro, 2-Gato, 3-Ave): 1"
              
              Usa switch para imprimir:
                1 → "Perro"
                2 → "Gato"
                3 → "Ave"
                cualquier otro → "Opción inválida"
            answer: |
              algorithm
                var
                  opcion: integer;
                end var
              
                writeString("Introduce el tipo de animal (1-Perro, 2-Gato, 3-Ave): ");
                opcion := readInteger();
              
                switch opcion
                  case 1 then
                    writeString("Perro");
                  end case
                  case 2 then
                    writeString("Gato");
                  end case
                  case 3 then
                    writeString("Ave");
                  end case
                  case default then
                    writeString("Opción inválida");
                  end case
                end switch
              end algorithm
            hint: Recuerda la estructura del switch en pseudocódigo.
              switch
              case    then
              end case

              case default then
              end case
              end switch

      - number: 3
        explanation:
          C: |
            En este nivel aprenderás a **repetir instrucciones** usando bucles `for`, `while` y `do while`, para recorrer arrays y matrices relacionados con videojuegos.  
            Estos bucles permiten procesar listas de datos como niveles, puntos de experiencia o mapas.

            ### Bucle `for` básico
            El `for` sirve para repetir una acción un número fijo de veces.  
            Ejemplo: mostrar los primeros 10 niveles de un personaje:

            ```c
            #include <stdio.h>
            #define MAX_NIVELES 10

            int main() {
                int i;
                for (i = 0; i < MAX_NIVELES; i++) {
                    printf("%d\n", i + 1);
                }
                return 0;
            }
            ```

            ---

            ### Recorrer un array con `for`
            Puedes recorrer un array de puntos de experiencia ganados en misiones:

            ```c
            #include <stdio.h>
            #define MAX_MISIONES 4

            int main() {
                int experiencia[MAX_MISIONES] = {150, 300, 200, 400};
                int i;

                for (i = 0; i < MAX_MISIONES; i++) {
                    printf("%d\n", experiencia[i]);
                }
                return 0;
            }
            ```

            ---

            ### Leer datos en un array con `for`
            Puedes usar `scanf` en un bucle para leer datos del usuario.  
            Por ejemplo, el tiempo que tardó en cada misión:

            ```c
            #include <stdio.h>

            int main() {
                float tiempo[3];
                int i;

                for (i = 0; i < 3; i++) {
                    printf("Tiempo en misión %d: ", i + 1);
                    scanf("%f", &tiempo[i]);
                }
                return 0;
            }
            ```

            ---

            ### `while` y `do while`
            - `while` se ejecuta mientras se cumpla una condición.  
            - `do while` se ejecuta al menos una vez.

            ```c
            #include <stdio.h>

            int main() {
                int i = 0;

                while (i < 5) {
                    printf("%d\n", i);
                    i++;
                }

                i = 0;
                do {
                    printf("%d\n", i);
                    i++;
                } while (i < 5);

                return 0;
            }
            ```

            ---

            ### Suma de elementos en un array
            Puedes sumar los puntos conseguidos en varios niveles:

            ```c
            #include <stdio.h>

            int main() {
                int puntos[4] = {10, 20, 30, 40};
                int suma = 0;
                int i;

                for (i = 0; i < 4; i++) {
                    suma += puntos[i];
                }

                printf("Total: %d\n", suma);
                return 0;
            }
            ```

            ---

            ### strncpy en bucle
            Puedes copiar nombres de enemigos usando un bucle y `strncpy`:

            ```c
            #include <stdio.h>
            #include <string.h>
            #define MAX 3
            #define MAX_NOMBRE 12

            int main() {
                char enemigos[MAX][MAX_NOMBRE];
                char nombresBase[MAX][MAX_NOMBRE] = {"Goblin", "Orco", "Troll"};
                int i;

                for (i = 0; i < MAX; i++) {
                    strncpy(enemigos[i], nombresBase[i], MAX_NOMBRE);
                }

                for (i = 0; i < MAX; i++) {
                    printf("%s\n", enemigos[i]);
                }
                return 0;
            }
            ```

            ---

            ### Recorrer matrices
            Puedes recorrer mapas, inventarios o zonas con bucles anidados:

            ```c
            #include <stdio.h>

            int main() {
                int mapa[2][3] = {
                    {1, 0, 1},
                    {0, 1, 0}
                };
                int i, j;

                for (i = 0; i < 2; i++) {
                    for (j = 0; j < 3; j++) {
                        printf("%d ", mapa[i][j]);
                    }
                    printf("\n");
                }
                return 0;
            }
            ```

            ---

            ### Suma de una matriz
            Para sumar el daño de cada ataque en un campo de batalla:

            ```c
            #include <stdio.h>

            int main() {
                int dano[2][2] = {
                    {5, 3},
                    {7, 1}
                };
                int suma = 0;
                int i, j;

                for (i = 0; i < 2; i++) {
                    for (j = 0; j < 2; j++) {
                        suma += dano[i][j];
                    }
                }

                printf("Daño total: %d\n", suma);
                return 0;
            }
            ```

            ---

            ### Ejemplo completo
            ```c
            #include <stdio.h>
            #include <string.h>
            #define MAX 3
            #define MAX_NOMBRE 12

            int main() {
                // Recorrer array
                int experiencia[4] = {150, 300, 200, 400};
                int i, j;
                for (i = 0; i < 4; i++) {
                    printf("Experiencia misión %d: %d\n", i + 1, experiencia[i]);
                }

                // Sumar array
                int puntos[4] = {10, 20, 30, 40};
                int suma = 0;
                for (i = 0; i < 4; i++) {
                    suma += puntos[i];
                }
                printf("Puntos totales: %d\n", suma);

                // Copiar nombres
                char enemigos[MAX][MAX_NOMBRE];
                char nombresBase[MAX][MAX_NOMBRE] = {"Goblin", "Orco", "Troll"};
                for (i = 0; i < MAX; i++) {
                    strncpy(enemigos[i], nombresBase[i], MAX_NOMBRE);
                }

                // Recorrer matriz
                int mapa[2][3] = {
                    {1, 0, 1},
                    {0, 1, 0}
                };
                for (i = 0; i < 2; i++) {
                    for (j = 0; j < 3; j++) {
                        printf("%d ", mapa[i][j]);
                    }
                    printf("\n");
                }
                return 0;
            }
            ```

            Este programa muestra cómo usar bucles para recorrer arrays y matrices en un videojuego.

          Pseudocode: |
            En este nivel aprenderás a **usar bucles** `for`, `while` y `do while` en pseudocódigo para recorrer arrays y matrices.  
            Son muy útiles en videojuegos para repetir acciones, calcular sumas o recorrer mapas.

            ### Bucle `for` básico
            ```pseudocode
            algorithm
              var 
                i: integer;
              end var

              for i = 1 to 10 do
                writeInteger(i);
              end for
            end algorithm
            ```

            ---

            ### Recorrer un array
            ```pseudocode
            algorithm
              var
                experiencia: vector[4] of integer;
                i: integer;
              end var

              experiencia[1] := 150;
              experiencia[2] := 300;
              experiencia[3] := 200;
              experiencia[4] := 400;

              for i = 1 to 4 do
                writeInteger(experiencia[i]);
              end for
            end algorithm
            ```

            ---

            ### Leer un array con `for`
            ```pseudocode
            algorithm
              var
                tiempo: vector[3] of real;
                i: integer;
              end var

              for i = 1 to 3 do
                writeString("Tiempo misión ");
                writeInteger(i);
                writeString(": ");
                tiempo[i] := readReal();
              end for
            end algorithm
            ```

            ---

            ### `while` y `do while`
            ```pseudocode
            algorithm
              var i: integer;
              end var

              i := 1;
              while i <= 5 do
                writeInteger(i);
                i := i + 1;
              end while

              i := 1;
              do
                writeInteger(i);
                i := i + 1;
              while i <= 5;
            end algorithm
            ```

            ---

            ### Sumar los puntos obtenidos
            ```pseudocode
            algorithm
              var
                puntos: vector[4] of integer;
                suma: integer;
                i: integer;
              end var

              puntos[1] := 10;
              puntos[2] := 20;
              puntos[3] := 30;
              puntos[4] := 40;
              suma := 0;

              for i = 1 to 4 do
                suma := suma + puntos[i];
              end for

              writeString("Total: ");
              writeInteger(suma);
            end algorithm
            ```

            ---

            ### Imprimir nombres
            ```pseudocode
            algorithm
              var
                enemigos: vector[3] of string;
                i: integer;
              end var

              enemigos[1] := "Goblin";
              enemigos[2] := "Orco";
              enemigos[3] := "Troll";

              for i = 1 to 3 do
                writeString(enemigos[i]);
              end for
            end algorithm
            ```

            ---

            ### Matrices
            ```pseudocode
            algorithm
              var
                mapa: vector[2][3] of integer;
                i, j: integer;
              end var

              mapa[1][1] := 1;
              mapa[1][2] := 0;
              mapa[1][3] := 1;
              mapa[2][1] := 0;
              mapa[2][2] := 1;
              mapa[2][3] := 0;

              for i = 1 to 2 do
                for j = 1 to 3 do
                  writeInteger(mapa[i][j]);
                end for
              end for
            end algorithm
            ```

            ---

            ### Sumar los valores de una matriz
            ```pseudocode
            algorithm
              var
                dano: vector[2][2] of integer;
                suma, i, j: integer;
              end var

              dano[1][1] := 5;
              dano[1][2] := 3;
              dano[2][1] := 7;
              dano[2][2] := 1;
              suma := 0;

              for i = 1 to 2 do
                for j = 1 to 2 do
                  suma := suma + dano[i][j];
                end for
              end for

              writeString("Daño total: ");
              writeInteger(suma);
            end algorithm
            ```

            ---

            ### Ejemplo completo
            ```pseudocode
            algorithm buclesVideojuego
              var
                experiencia: vector[4] of integer;
                puntos: vector[4] of integer;
                enemigos: vector[3] of string;
                mapa: vector[2][3] of integer;
                suma, i, j: integer;
              end var

              experiencia[1] := 150;
              experiencia[2] := 300;
              experiencia[3] := 200;
              experiencia[4] := 400;

              for i = 1 to 4 do
                writeString("Experiencia misión ");
                writeInteger(i);
                writeString(": ");
                writeInteger(experiencia[i]);
              end for

              puntos[1] := 10;
              puntos[2] := 20;
              puntos[3] := 30;
              puntos[4] := 40;
              suma := 0;

              for i = 1 to 4 do
                suma := suma + puntos[i];
              end for
              writeString("Puntos totales: ");
              writeInteger(suma);

              enemigos[1] := "Goblin";
              enemigos[2] := "Orco";
              enemigos[3] := "Troll";
              for i = 1 to 3 do
                writeString(enemigos[i]);
              end for

              mapa[1][1] := 1;
              mapa[1][2] := 0;
              mapa[1][3] := 1;
              mapa[2][1] := 0;
              mapa[2][2] := 1;
              mapa[2][3] := 0;
              for i = 1 to 2 do
                for j = 1 to 3 do
                  writeInteger(mapa[i][j]);
                end for
              end for
            end algorithm
            ```

            Este algoritmo muestra cómo recorrer arrays y matrices con diferentes bucles en un videojuego.

        questions:
          - id: c-3-for-indice-basico
            language: C
            week: 3
            prompt: |
              Incluye stdio.h.

              Declara la constante MAXIMO = 10.

              Dentro de main, declara una variable i.

              Utiliza un bucle for para que i tome valores de 0 a 9, ambos incluidos, e imprime el valor de i en cada iteración.

              La salida debe ser una línea por número, ejemplo:
                0
                1
                2
                ...
                9
            answer: |
              #include <stdio.h>
              #define MAXIMO 10

              int main() {
                  int i;

                  for(i = 0; i < MAXIMO; i++) {
                      printf("%d\n", i);
                  }
                  return 0;
              }
            hint: "El for clásico en C es: for(inicio; condicion; incremento)"

          - id: p-3-for-indice-basico
            language: Pseudocode
            week: 3
            prompt: |
              Declara la constante MAXIMO = 10.

              Dentro del algoritmo principal, declara una variable i.

              Utiliza un bucle for para que i tome valores de 1 a MAXIMO e imprime el valor de i en cada iteración.

              La salida debe ser una línea por número del 1 al 10. Ejemplo
              1
              2
              3
              ...
              10

            answer: |
              const
                MAXIMO: integer = 10;
              end const

              algorithm
                var
                  i: integer;
                end var

                for i := 1 to MAXIMO do
                  writeInteger(i);
                end for
              end algorithm
            hint: En pseudocódigo los arrays y los índices empiezan en 1.

          - id: c-3-for-array-imprimir
            language: C
            week: 3
            prompt: |
              Incluye stdio.

              Declara la constante MAX_DATOS = 4.

              Dentro de main, declara un array de enteros datos con MAX_DATOS inicializado con a 7, 2, 5, 8 usando { }.

              Usa un bucle for para imprimir cada dato, uno por línea. Necesitaras una variable i.

              Ejemplo de ejecución:
                7
                2
                5
                8
            answer: |
              #include <stdio.h>
              #define MAX_DATOS 4

              int main() {
                  int datos[MAX_DATOS] = {7, 2, 5, 8};
                  int i;
                  for(i = 0; i < MAX_DATOS; i++) {
                      printf("%d\n", datos[i]);
                  }
                  return 0;
              }
            hint: Recuerda que los arrays en C empiezan en 0.

          - id: p-3-for-array-imprimir
            language: Pseudocode
            week: 3
            prompt: |
              Declara la constante MAX_DATOS = 4.

              Dentro del algoritmo principal, declara un array de enteros datos con MAX_DATOS.

              Inicialízalo a mano con los valores 7, 2, 5, 8.

              Usa un bucle for para imprimir cada dato, uno por línea. Necesitarás una variable i.

              Ejemplo de ejecución:
                7
                2
                5
                8
            answer: |
              const
                MAX_DATOS: integer = 4;
              end const

              algorithm
                var
                  datos: vector[MAX_DATOS] of integer;
                  i: integer;
                end var

                datos[1] := 7;
                datos[2] := 2;
                datos[3] := 5;
                datos[4] := 8;

                for i := 1 to MAX_DATOS do
                  writeInteger(datos[i]);
                end for
              end algorithm
            hint: El índice comienza en 1 en pseudocódigo.

          - id: c-3-for-leer-array
            language: C
            week: 3
            prompt: |
              Incluye stdio.

              Declara la constante MAXIMO = 3.

              Dentro de main, declara un array de decimales valores con MAXIMO.

              Usa un bucle for para pedir al usuario que ingrese 3 decimales y guardarlos en el array.

              Necesitarás una variable i para usar de iterador.

              Luego imprime los valores, uno por línea utilizando otro for.

              Ejemplo de ejecución:
                Ingresa valor 1: 3.2
                Ingresa valor 2: 1.0
                Ingresa valor 3: 4.8
                3.2
                1.0
                4.8
            answer: |
              #include <stdio.h>
              #define MAXIMO 3

              int main() {
                  float valores[MAXIMO];
                  int i;
                  for(i = 0; i < MAXIMO; i++) {
                      printf("Ingresa valor %d: ", i+1);
                      scanf("%f", &valores[i]);
                  }
                  for(i = 0; i < MAXIMO; i++) {
                      printf("%.1f\n", valores[i]);
                  }
                  return 0;
              }
            hint: Usa dos bucles for, uno para leer y otro para imprimir. Imprime los valores con 1 solo decimal.

          - id: p-3-for-leer-array
            language: Pseudocode
            week: 3
            prompt: |
              Declara la constante MAXIMO = 3.

              Dentro del algoritmo principal, declara un array de reales valores con MAXIMO.

              Usa un bucle for para leer 3 decimales del usuario y guardarlos en el array.

              Necesitarás una variable i para usar de iterador.

              Luego usa otro bucle for para imprimir los valores, uno por línea.

              Ejemplo de ejecución:
                Ingresa valor 1: 3.2
                Ingresa valor 2: 1.0
                Ingresa valor 3: 4.8
                3.2
                1.0
                4.8

              El numero seguido de valor toma el valor del indice en cada iteración.
            answer: |
              const
                MAXIMO: integer = 3;
              end const

              algorithm
                var
                  valores: vector[MAXIMO] of real;
                  i: integer;
                end var

                for i := 1 to MAXIMO do
                  writeString("Ingresa valor ");
                  writeInteger(i);
                  writeString(": ");
                  valores[i] := readReal();
                end for

                for i := 1 to MAXIMO do
                  writeReal(valores[i]);
                end for
              end algorithm
            hint: Usa dos bucles for, uno para leer y otro para imprimir. Recuerda que en pseudocodigo debes imprimir los datos en diferentes lineas.



          - id: c-3-while-indice-basico
            language: C
            week: 3
            prompt: |
              Incluye stdio.

              Declara la constante MAXIMO = 10.

              Dentro de main, declara una variable i inicializada a 0.

              Utiliza un bucle while para imprimir el valor de i mientras i sea menor que MAXIMO.

              La salida debe ser una línea por número, del 0 al 9.
            answer: |
              #include <stdio.h>
              #define MAXIMO 10

              int main() {
                  int i = 0;
                  while(i < MAXIMO) {
                      printf("%d\n", i);
                      i++;
                  }
                  return 0;
              }
            hint: Recuerda inicializar i antes del while e incrementarla antes de finalizar cada iteración para no crear un bucle infinito.

          - id: p-3-while-indice-basico
            language: Pseudocode
            week: 3
            prompt: |
              Declara la constante MAXIMO = 10.

              Dentro del algoritmo principal, declara una variable i inicializada a 1.

              Usa un bucle while para imprimir el valor de i mientras i sea menor o igual que MAXIMO.

              La salida debe ser una línea por número del 1 al 10.
            answer: |
              const
                MAXIMO: integer = 10;
              end const

              algorithm
                var
                  i: integer;
                end var

                i := 1;
                while i <= MAXIMO do
                  writeInteger(i);
                  i := i + 1;
                end while
              end algorithm
            hint: En pseudocódigo los índices empiezan en 1 y se incrementan manualmente. No olvides incrementar el indice.



          - id: c-3-do-while-indice-basico
            language: C
            week: 3
            prompt: |
              Incluye stdio.

              Declara la constante MAXIMO = 10.

              Dentro de main, declara una variable i inicializada a 0.

              Usa un bucle do while para imprimir el valor de i mientras i sea menor que MAXIMO.

              La salida debe ser una línea por número, del 0 al 9.
            answer: |
              #include <stdio.h>
              #define MAXIMO 10

              int main() {
                  int i = 0;
                  do {
                      printf("%d\n", i);
                      i++;
                  } while(i < MAXIMO);
                  return 0;
              }
            hint: El cuerpo de do while siempre se ejecuta al menos una vez. No olvides el salto de linea en el print.

          - id: p-3-do-while-indice-basico
            language: Pseudocode
            week: 3
            prompt: |
              Declara la constante MAXIMO = 10.

              Dentro del algoritmo principal, declara una variable e inicializala a 1.

              Usa un bucle do while para imprimir el valor de i mientras i sea menor o igual que MAXIMO.

              La salida debe ser una línea por número del 1 al 10.
            answer: |
              const
                MAXIMO: integer = 10;
              end const

              algorithm
                var
                  i: integer;
                end var

                i := 1;
                do
                  writeInteger(i);
                  i := i + 1;
                while i <= MAXIMO;
              end algorithm
            hint: En pseudocódigo los índices empiezan en 1.

          - id: c-3-for-suma-array
            language: C
            week: 3
            prompt: |
              Incluye stdio.

              Declara la constante MAX = 4.

              Dentro de main, declara un array de enteros valores con MAX inicializado a 1, 2, 3, 4 usando { }.

              Declara una variable suma para almacenar la suma de todos los elementos del array e inicializala en 0.

              También necesitarás una variable i para utilizar en el bucle.

              Usa un bucle for para calcular la suma de todos los elementos y al final imprime el resultado así:

              Suma: x

              Para la suma utiliza el operador compuesto.

              Ejemplo de ejecución:
                Suma: 10
            answer: |
              #include <stdio.h>
              #define MAX 4

              int main() {
                  int valores[MAX] = {1, 2, 3, 4};
                  int suma = 0;
                  int i;
                  for(i = 0; i < MAX; i++) {
                      suma += valores[i];
                  }
                  printf("Suma: %d\n", suma);
                  return 0;
              }
            hint: Acumula la suma con suma += . Imprime el resultado fuera del bucle y no olvides el salto de linea.

          - id: p-3-for-suma-array
            language: Pseudocode
            week: 3
            prompt: |
              Declara la constante MAX = 4.

              Declara un array de enteros valores con MAX.

              Inicialízalo a mano con los valores 1, 2, 3, 4.

              Declara una variable suma para almacenar la suma de todos los elementos del array e inicializala en 0.

              También necesitarás una variable i para utilizar en el bucle.

              Usa un bucle for para calcular la suma de todos los elementos y al final imprime el resultado así:

              Suma: x

              Ejemplo de ejecución:
                Suma: 10
            answer: |
              const
                MAX: integer = 4;
              end const

              algorithm
                var
                  valores: vector[MAX] of integer;
                  suma: integer;
                  i: integer;
                end var

                valores[1] := 1;
                valores[2] := 2;
                valores[3] := 3;
                valores[4] := 4;
                suma := 0;

                for i := 1 to MAX do
                  suma := suma + valores[i];
                end for

                writeString("Suma: ");
                writeInteger(suma);
              end algorithm
            hint: Recuerda inicializar suma a 0. Imprime el resultado fuera del bucle. Los indices empiezan en 1.

          - id: c-3-for-strncpy-paralelo
            language: C
            week: 3
            prompt: |
              Incluye stdio y string.

              Declara la constante MAX = 3 y MAX_NOMBRE = 12.

              Dentro de main, declara un array de cadenas nombres con MAX y MAX_NOMBRE.

              Declara otro array de cadenas ejemplos con MAX y MAX_NOMBRE e inicializalo con los siguientes nombres usando { }: 
              Ana", "Luis" y "Eva"

              Declara una variable i para utilizar en los bucles.

              Usa strncpy para inicializar los nombres con "Ana", "Luis" y "Eva" usando un bucle for.

              Después, imprime cada nombre, uno por línea con otro bucle for.

              Ejemplo de ejecución:
                Ana
                Luis
                Eva
            answer: |
              #include <stdio.h>
              #include <string.h>
              #define MAX 3
              #define MAX_NOMBRE 12

              int main() {
                  char nombres[MAX][MAX_NOMBRE];
                  char ejemplos[MAX][MAX_NOMBRE]; = {"Ana", "Luis", "Eva"};
                  int i;
                  for(i = 0; i < MAX; i++) {
                      strncpy(nombres[i], ejemplos[i], MAX_NOMBRE);
                  }
                  for(i = 0; i < MAX; i++) {
                      printf("%s\n", nombres[i]);
                  }
                  return 0;
              }
            hint: Usa strncpy(destino, origen, tamaño).

          - id: p-3-for-array-paralelo
            language: Pseudocode
            week: 3
            prompt: |
              Declara la constante MAX = 3.

              Declara un array de strings nombres con MAX.

              Inicialízalos a mano como "Ana", "Luis" y "Eva".

              Usa un bucle for para imprimir cada nombre, uno por línea.

              Ejemplo de ejecución:
                Ana
                Luis
                Eva
            answer: |
              const
                MAX: integer = 3;
              end const

              algorithm
                var
                  nombres: vector[MAX] of string;
                  i: integer;
                end var

                nombres[1] := "Ana";
                nombres[2] := "Luis";
                nombres[3] := "Eva";

                for i := 1 to MAX do
                  writeString(nombres[i]);
                end for
              end algorithm
            hint: Los índices empiezan en 1.

          - id: c-3-for-matriz-manual
            language: C
            week: 3
            prompt: |
              Incluye stdio.

              Declara las constantes FILAS = 2 y COLUMNAS = 3.

              Dentro de main, declara una matriz de enteros tabla con FILAS x COLUMNAS e inicialízala manualmente usando asignaciones.

              Declara dos variables i j para utilizar en los bucles.

              Asigna manualmente los valores siguientes:
                fila 1: 2, 4, 6
                fila 2: 1, 3, 5

              Usa dos bucles for anidados para imprimir la matriz como una tabla.

              Después de cada bucle interno, imprime un salto de linea para lograr el output facilitado.

              Ejemplo de ejecución:
                2 4 6
                1 3 5
            answer: |
              #include <stdio.h>
              #define FILAS 2
              #define COLUMNAS 3

              int main() {
                  int tabla[FILAS][COLUMNAS];
                  int i, j;

                  tabla[0][0] = 2; 
                  tabla[0][1] = 4; 
                  tabla[0][2] = 6;
                  tabla[1][0] = 1; 
                  tabla[1][1] = 3; 
                  tabla[1][2] = 5;

                  for(i = 0; i < FILAS; i++) {
                      for(j = 0; j < COLUMNAS; j++) {
                          printf("%d ", tabla[i][j]);
                      }
                      printf("\n");
                  }
                  return 0;
              }
            hint: Inicializa cada elemento manualmente.

          - id: p-3-for-matriz-manual
            language: Pseudocode
            week: 3
            prompt: |
              Declara las constantes FILAS = 2 y COLUMNAS = 3.

              Declara una matriz de enteros tabla con FILAS x COLUMNAS.

              Declara dos variables i j para utilizar en los bucles.

              Asigna manualmente los valores:
                fila 1: 2, 4, 6
                fila 2: 1, 3, 5

              Usa dos bucles for anidados para imprimir la matriz como una tabla.

              Ejemplo de ejecución:
                2 4 6
                1 3 5
            answer: |
              const
                FILAS: integer = 2;
                COLUMNAS: integer = 3;
              end const

              algorithm
                var
                  tabla: vector[FILAS][COLUMNAS] of integer;
                  i: integer;
                  j: integer;
                end var

                tabla[1][1] := 2; 
                tabla[1][2] := 4; 
                tabla[1][3] := 6;
                tabla[2][1] := 1; 
                tabla[2][2] := 3; 
                tabla[2][3] := 5;

                for i := 1 to FILAS do
                  for j := 1 to COLUMNAS do
                    writeInteger(tabla[i][j]);
                  end for
                end for
              end algorithm
            hint: Los bucles anidados recorren filas y columnas.

          - id: c-3-for-matriz-inicializa-llaves
            language: C
            week: 3
            prompt: |
              Incluye stdio.

              Declara las constantes FILAS = 2 y COLUMNAS = 2.

              Dentro de main, declara una matriz de decimales temp con FILAS x COLUMNAS e inicialízala con { } con los valores:
                22.1, 18.3 y 19.5, 20.0 (fila1 y fila2)

              Declara dos variables i j para utilizar en los bucles.

              Usa dos bucles for anidados para imprimir cada valor con un decimal, uno por línea.

              Ejemplo de ejecución:
                22.1
                18.3
                19.5
                20.0
            answer: |
              #include <stdio.h>
              #define FILAS 2
              #define COLUMNAS 2

              int main() {
                  float temp[FILAS][COLUMNAS] = {
                      {22.1, 18.3},
                      {19.5, 20.0}
                  };
                  int i, j;
                  for(i = 0; i < FILAS; i++) {
                      for(j = 0; j < COLUMNAS; j++) {
                          printf("%.1f\n", temp[i][j]);
                      }
                  }
                  return 0;
              }
            hint: Usa inicialización con llaves y no olvides el salto de linea.

          - id: p-3-for-matriz-inicializa-manual
            language: Pseudocode
            week: 3
            prompt: |
              Declara las constantes FILAS = 2 y COLUMNAS = 2.

              Declara una matriz de reales temp con FILAS x COLUMNAS.

              Asigna manualmente los valores:
                22.1, 18.3 y 19.5,20.0 (fila1 y fila2)

              Declara dos variables i j para utilizar en los bucles.

              Usa dos bucles for anidados para imprimir cada valor, uno por línea.

              Ejemplo de ejecución:
                22.1
                18.3
                19.5
                20.0
            answer: |
              const
                FILAS: integer = 2;
                COLUMNAS: integer = 2;
              end const

              algorithm
                var
                  temp: vector[FILAS][COLUMNAS] of real;
                  i: integer;
                  j: integer;
                end var

                temp[1][1] := 22.1;
                temp[1][2] := 18.3;
                temp[2][1] := 19.5;
                temp[2][2] := 20.0;

                for i := 1 to FILAS do
                  for j := 1 to COLUMNAS do
                    writeReal(temp[i][j]);
                  end for
                end for
              end algorithm
            hint: En pseudocódigo la inicialización es manual.

          - id: c-3-for-suma-matriz
            language: C
            week: 3
            prompt: |
              Incluye stdio.

              Declara las constantes FILAS = 2 y COLUMNAS = 2.

              Dentro de main, declara una matriz de enteros tabla con FILAS x COLUMNAS inicializada con (3, 1) y (5, 2).

              Declara una variable suma e inicializala en 0.

              Declara dos variables i, j en la misma linea para utilizar en los bucles.

              Usa dos bucles for anidados para calcular la suma de todos los elementos y luego imprime:

              Suma: x

              La suma realizala con operador compuesto.

              Ejemplo de ejecución:
                Suma: 11
            answer: |
              #include <stdio.h>
              #define FILAS 2
              #define COLUMNAS 2

              int main() {
                  int tabla[FILAS][COLUMNAS] = {
                      {3, 1},
                      {5, 2}
                  };
                  int suma = 0;
                  int i, j;
                  for(i = 0; i < FILAS; i++) {
                      for(j = 0; j < COLUMNAS; j++) {
                          suma += tabla[i][j];
                      }
                  }
                  printf("Suma: %d\n", suma);
                  return 0;
              }
            hint: Suma con suma += tabla[i][j].

          - id: p-3-for-suma-matriz
            language: Pseudocode
            week: 3
            prompt: |
              Declara las constantes FILAS = 2 y COLUMNAS = 2.

              Dentro del algoritmo principal, declara una matriz de enteros tabla con FILAS x COLUMNAS inicializada con (3, 1) y (5, 2).

              Declara una variable suma e inicializala en 0.

              Declara dos variables i, j para utilizar en los bucles.

              Usa dos bucles for anidados para calcular la suma de todos los elementos y luego imprime:

              Suma: x

              Ejemplo de ejecución:
                Suma: 11
            answer: |
              const
                FILAS: integer = 2;
                COLUMNAS: integer = 2;
              end const

              algorithm
                var
                  tabla: vector[FILAS][COLUMNAS] of integer;
                  suma: integer;
                  i: integer;
                  j: integer;
                end var

                tabla[1][1] := 3;
                tabla[1][2] := 1;
                tabla[2][1] := 5;
                tabla[2][2] := 2;
                suma := 0;

                for i := 1 to FILAS do
                  for j := 1 to COLUMNAS do
                    suma := suma + tabla[i][j];
                  end for
                end for

                writeString("Suma: ");
                writeInteger(suma);
              end algorithm
            hint: Los indices empiezan en 1. Primero declara y luego inicializa

  - number: 4
    explanation: |
      Explicación de semana 4
    levels:
      - number: 1
        explanation:
          C: |
            En este nivel aprenderás a **declarar y utilizar `structs`** para representar datos complejos como una atracción de un parque, además de cómo declarar **arrays de structs** y acceder a sus campos.  
            Los `structs` son muy útiles para modelar entidades en videojuegos o parques temáticos.

            ### ¿Qué es un `struct`?
            Un `struct` permite agrupar múltiples variables relacionadas bajo un solo nombre.  
            Es ideal para representar personajes, ítems o atracciones.

            ```c
            typedef struct {
                char nombre[30];
                int duracionMinutos;
                float alturaMinima;
            } tAtraccion;
            ```

            Esto define un nuevo tipo `tAtraccion` con 3 campos.

            ---

            ### Declarar una variable de tipo struct
            ```c
            int main(){
              tAtraccion torreCaida;
              return 0;
            }
            ```

            ---

            ### Asignar valores a los campos
            Para campos `char[]`, usamos `strncpy`:

            ```c
            #include <string.h>

            int main() {
                tAtraccion torreCaida;
                strncpy(torreCaida.nombre, "Torre de Caída", 30);
                torreCaida.duracionMinutos = 3;
                torreCaida.alturaMinima = 1.40;
                return 0;
            }
            ```

            ---

            ### Array de structs
            Puedes declarar un array de structs para almacenar varias atracciones:

            ```c
            #define MAX_ATRACCIONES 3
            
            int main(){
              tAtraccion atracciones[MAX_ATRACCIONES];
              return 0;
            }
            
            ```

            Para acceder al nombre de la primera atracción:

            ```c
            int main(){
              atracciones[0].nombre;
              return 0;
            }
            ```

            ---

            ### Relación entre arrays paralelos
            Supón que tienes un array de `tAtraccion` y otro array con el número de visitantes.  
            Si el índice es el mismo, representan datos del mismo objeto:

            ```c
            #include <string.h>
            #define MAX_ATRACCIONES 3

            int main() {
                tAtraccion atracciones[MAX_ATRACCIONES];
                int visitantes[MAX_ATRACCIONES];

                strncpy(atracciones[1].nombre, "Looping", 30);
                visitantes[1] = 1234;
                return 0;
            }
            ```

            Aquí el índice `1` se refiere a la misma atracción.

            ---

            ### Ejemplo completo
            ```c
            #include <stdio.h>
            #include <string.h>

            #define MAX_ATRACCIONES 3

            typedef struct {
                char nombre[30];
                int duracionMinutos;
                float alturaMinima;
            } tAtraccion;

            int main() {
                tAtraccion parque[MAX_ATRACCIONES];
                int visitantes[MAX_ATRACCIONES];

                // Asignar valores
                strncpy(parque[0].nombre, "Torre de Caída", 30);
                parque[0].duracionMinutos = 3;
                parque[0].alturaMinima = 1.40;
                visitantes[0] = 1200;

                strncpy(parque[1].nombre, "Looping", 30);
                parque[1].duracionMinutos = 2;
                parque[1].alturaMinima = 1.30;
                visitantes[1] = 1500;

                strncpy(parque[2].nombre, "Tazas Locas", 30);
                parque[2].duracionMinutos = 4;
                parque[2].alturaMinima = 1.10;
                visitantes[2] = 900;

                // Mostrar datos
                for (int i = 0; i < MAX_ATRACCIONES; i++) {
                    printf("Atracción: %s\n", parque[i].nombre);
                    printf("Duración: %d minutos\n", parque[i].duracionMinutos);
                    printf("Altura mínima: %.2f m\n", parque[i].alturaMinima);
                    printf("Visitantes: %d\n\n", visitantes[i]);
                }

                return 0;
            }
            ```

            Este programa muestra cómo declarar structs, guardarlos en arrays y relacionarlos con otros datos como número de visitantes.

          Pseudocode: |
            En este nivel aprenderás a **utilizar `record`** para representar datos compuestos, como atracciones, y cómo trabajar con **arrays de registros**.  
            Los `record` permiten organizar la información de un parque o videojuego de forma clara.

            ### ¿Qué es un `record`?
            Un `record` es como una caja que contiene distintos datos relacionados.  
            Sirve para representar enemigos, jefes o atracciones de parque.

            ```pseudocode
            type
              tAtraccion = record
                nombre: string;
                duracionMinutos: integer;
                alturaMinima: real;
              end record
            end type
            ```

            ---

            ### Declarar una variable de tipo record
            ```pseudocode
            algorithm
              var
                torreCaida: tAtraccion;
              end var
            end algorithm
            ```

            ---

            ### Asignar valores a los campos
            ```pseudocode
            algorithm
              var
                torreCaida: tAtraccion;
              end var

              torreCaida.nombre := "Torre de Caída";
              torreCaida.duracionMinutos := 3;
              torreCaida.alturaMinima := 1.40;
            end algorithm
            ```

            ---

            ### Array de records
            ```pseudocode
            const
              MAX_ATRACCIONES: integer = 3;
            end const

            algorithm
              var
                parque: vector[MAX_ATRACCIONES] of tAtraccion;
              end var
            end algorithm
            ```

            Para acceder al campo de la primera atracción:

            ```pseudocode
            parque[1].nombre
            ```

            ---

            ### Relación entre arrays paralelos
            Si tienes un array `parque` y otro array llamado `visitantes`, puedes almacenar información relacionada en la misma posición:

            ```pseudocode
            algorithm
              var
                parque: vector[3] of tAtraccion;
                visitantes: vector[3] of integer;
              end var

              parque[2].nombre := "Tazas locas";
              parque[2].duracionMinutos := 4;
              parque[2].alturaMinima := 1.10;

              visitantes[2] := 300;
            end algorithm
            ```

            Aquí, el índice 2 representa los datos de la misma atracción.

            ---

            ### Ejemplo completo
            ```pseudocode
            const
              MAX_ATRACCIONES: integer = 3;
            end const

            type
              tAtraccion = record
                nombre: string;
                duracionMinutos: integer;
                alturaMinima: real;
              end record
            end type

            algorithm parqueDiversiones
              var
                parque: vector[MAX_ATRACCIONES] of tAtraccion;
                visitantes: vector[MAX_ATRACCIONES] of integer;
                i: integer;
              end var

              parque[1].nombre := "Torre de Caída";
              parque[1].duracionMinutos := 3;
              parque[1].alturaMinima := 1.40;
              visitantes[1] := 1200;

              parque[2].nombre := "Looping";
              parque[2].duracionMinutos := 2;
              parque[2].alturaMinima := 1.30;
              visitantes[2] := 1500;

              parque[3].nombre := "Tazas Locas";
              parque[3].duracionMinutos := 4;
              parque[3].alturaMinima := 1.10;
              visitantes[3] := 900;

              for i := 1 to MAX_ATRACCIONES do
                writeString("Atracción: ");
                writeString(parque[i].nombre);
                writeString(", Duración: ");
                writeInteger(parque[i].duracionMinutos);
                writeString(" min, Altura mínima: ");
                writeReal(parque[i].alturaMinima);
                writeString(" m, Visitantes: ");
                writeInteger(visitantes[i]);
              end for
            end algorithm
            ```

            Este algoritmo muestra cómo trabajar con registros y arrays paralelos para representar un parque de atracciones.

        questions:
          - id: c-4-atraccion-basica
            language: C
            week: 4
            prompt: |
              Crea un tipo de dato llamado tAtraccion para una atracción de parque con los siguientes campos exactos:
              - Una cadena de caracteres llamada nombre con tamaño máximo definido por la constante MAX_NOMBRE (valor 30).
              - Un número decimal llamado alturaMinima.
              - Un valor lógico llamado enMantenimiento.

              Declara una variable llamada atraccion1 de tipo tAtraccion dentro de la función main.
            answer: |
              #include <stdbool.h>

              #define MAX_NOMBRE 30

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  float alturaMinima;
                  bool enMantenimiento;
              } tAtraccion;

              int main() {
                  tAtraccion atraccion1;
                  return 0;
              }
            hint: Declara primero la constante, luego el typedef del struct y por último la variable atraccion1 dentro de main. No olvides la biblioteca de booleanos

          - id: p-4-atraccion-basica
            language: Pseudocode
            week: 4
            prompt: |
              Crea un tipo de dato llamado tAtraccion para una atracción de parque con los siguientes campos exactos:
              - Un texto llamado nombre.
              - Un número real llamado alturaMinima.
              - Un valor booleano llamado enMantenimiento.

              Declara una variable llamada atraccion1 de tipo tAtraccion dentro del bloque principal.
            answer: |
              type
                tAtraccion = record
                  nombre: string;
                  alturaMinima: real;
                  enMantenimiento: boolean;
                end record
              end type

              algorithm
                var
                  atraccion1: tAtraccion;
                end var
              end algorithm
            hint: En pseudocódigo no se especifica el tamaño del texto; usa string.

          - id: c-4-atraccion-con-tipo
            language: C
            week: 4
            prompt: |
              Crea un tipo enumerado llamado tTipoAtraccion con los valores MONTANA_RUSA, CARRUSEL y SIMULADOR.
              Crea un tipo tAtraccion con:
              - Una cadena de caracteres llamada nombre con tamaño máximo definido por la constante MAX_NOMBRE (valor 30).
              - Un campo llamado tipo de tipo tTipoAtraccion.

              Declara una variable llamada atraccion1 de tipo tAtraccion dentro de la función main.
            answer: |
              #define MAX_NOMBRE 30

              typedef enum {
                  MONTANA_RUSA,
                  CARRUSEL,
                  SIMULADOR
              } tTipoAtraccion;

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  tTipoAtraccion tipo;
              } tAtraccion;

              int main() {
                  tAtraccion atraccion1;
                  return 0;
              }
            hint: Declara primero la constante, luego el typedef del enum y luego el typedef del struct que lo usa.

          - id: p-4-atraccion-con-tipo
            language: Pseudocode
            week: 4
            prompt: |
              Crea un tipo enumerado llamado tTipoAtraccion con los valores MONTANA_RUSA, CARRUSEL y SIMULADOR.
              Crea un tipo tAtraccion con:
              - Un texto llamado nombre.
              - Un campo llamado tipo de tipo tTipoAtraccion.

              Declara una variable llamada atraccion1 de tipo tAtraccion dentro del bloque principal.
            answer: |
              type
                tTipoAtraccion = { MONTANA_RUSA, CARRUSEL, SIMULADOR }
              end type

              type
                tAtraccion = record
                  nombre: string;
                  tipo: tTipoAtraccion;
                end record
              end type

              algorithm
                var
                  atraccion1: tAtraccion;
                end var
              end algorithm
            hint: Declara el tipo enumerado antes del record que lo utiliza utiliza dos bloques type diferentes.

          - id: c-4-atracciones-lista
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_NOMBRE (30) y MAX_ATRACCIONES (5).

              Crea un tipo tAtraccion con:
              - Una cadena de caracteres llamada nombre con tamaño máximo definido por MAX_NOMBRE (valor 30).
              - Un número entero llamado capacidadMaxima.

              Dentro de la función principal, declara un array llamado lista de tipo tAtraccion con MAX_ATRACCIONES elementos.
            answer: |
              #define MAX_NOMBRE 30
              #define MAX_ATRACCIONES 5

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  int capacidadMaxima;
              } tAtraccion;

              int main() {
                  tAtraccion lista[MAX_ATRACCIONES];
                  return 0;
              }
            hint: Las constantes deben definirse antes del typedef del struct.

          - id: p-4-atracciones-lista
            language: Pseudocode
            week: 4
            prompt: |
              Declara la constante MAX_ATRACCIONES con valor 5.

              Crea un tipo tAtraccion con:
              - Un texto llamado nombre.
              - Un número entero llamado capacidadMaxima.

              En el bloque principal, declara un array llamado lista de tipo tAtraccion con MAX_ATRACCIONES elementos.
            answer: |
              const
                MAX_ATRACCIONES: integer = 5;
              end const

              type
                tAtraccion = record
                  nombre: string;
                  capacidadMaxima: integer;
                end record
              end type

              algorithm
                var
                  lista: vector[MAX_ATRACCIONES] of tAtraccion;
                end var
              end algorithm
            hint: Usa vector[MAX_ATRACCIONES] of tAtraccion para el array de registros.

          - id: c-4-atraccion-horario
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_HORA (6) y MAX_NOMBRE (30).
              
              Crea un tipo tHorario con:
              - Una cadena de caracteres llamada apertura con tamaño máximo definido por MAX_HORA (valor 6).
              - Una cadena de caracteres llamada cierre con tamaño máximo definido por MAX_HORA (valor 6).

              Crea un tipo tAtraccion con:
              - Una cadena de caracteres llamada nombre con tamaño máximo definido por MAX_NOMBRE (valor 30).
              - Un campo llamado horario de tipo tHorario.

              
              Declara dentro de main una variable llamada atraccion1 de tipo tAtraccion.
            answer: |
              #define MAX_HORA 6
              #define MAX_NOMBRE 30

              typedef struct {
                  char apertura[MAX_HORA];
                  char cierre[MAX_HORA];
              } tHorario;

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  tHorario horario;
              } tAtraccion;

              int main() {
                  tAtraccion atraccion1;
                  return 0;
              }
            hint: Los structs anidados se declaran con un typedef para cada tipo.

          - id: p-4-atraccion-horario
            language: Pseudocode
            week: 4
            prompt: |
              Crea un tipo tHorario con:
              - Un texto llamado apertura.
              - Un texto llamado cierre.

              Crea un tipo tAtraccion con:
              - Un texto llamado nombre.
              - Un campo llamado horario de tipo tHorario.

              Declara una variable llamada atraccion1 de tipo tAtraccion en el bloque principal.
            answer: |
              type
                tHorario = record
                  apertura: string;
                  cierre: string;
                end record
              
                tAtraccion = record
                  nombre: string;
                  horario: tHorario;
                end record
              end type

              algorithm
                var
                  atraccion1: tAtraccion;
                end var
              end algorithm
            hint: Declara primero tHorario y luego úsalo como campo en tAtraccion, usa un solo bloque type.

          - id: c-4-ficha-seguridad
            language: C
            week: 4
            prompt: |
              Declara la constante MAX_NOMBRE con valor 30.

              Crea un tipo tFichaSeguridad con:
              - Una cadena de caracteres llamada inspector con tamaño máximo definido por MAX_NOMBRE (valor 30).
              - Un número decimal llamado puntaje.
              - Un valor lógico llamado aprobada.

              Declara dentro de main una variable llamada ficha1 de tipo tFichaSeguridad.
            answer: |
              #include <stdbool.h>

              #define MAX_NOMBRE 30

              typedef struct {
                  char inspector[MAX_NOMBRE];
                  float puntaje;
                  bool aprobada;
              } tFichaSeguridad;

              int main() {
                  tFichaSeguridad ficha1;
                  return 0;
              }
            hint: Recuerda incluir <stdbool.h> cuando uses bool en C.

          - id: p-4-ficha-seguridad
            language: Pseudocode
            week: 4
            prompt: |
              Crea un tipo tFichaSeguridad con:
              - Un texto llamado inspector.
              - Un número real llamado puntaje.
              - Un valor booleano llamado aprobada.

              Declara dentro del bloque principal una variable llamada ficha1 de tipo tFichaSeguridad.
            answer: |
              type
                tFichaSeguridad = record
                  inspector: string;
                  puntaje: real;
                  aprobada: boolean;
                end record
              end type

              algorithm
                var
                  ficha1: tFichaSeguridad;
                end var
              end algorithm
            hint: El record agrupa campos de distintos tipos en un solo dato.

          - id: c-4-atraccion-restricciones
            language: C
            week: 4
            prompt: |
              Declara la constante MAX_NOMBRE con valor 30.
              
              Crea un tipo enumerado tDificultad con los valores BAJA, MEDIA y ALTA.
              Crea un tipo tRestriccion con:
              - Un número decimal llamado alturaMinima.
              - Un valor lógico llamado embarazadasProhibido.

              Crea un tipo tAtraccion con:
              - Una cadena de caracteres llamada nombre con tamaño máximo definido por MAX_NOMBRE (valor 30).
              - Un campo llamado dificultad de tipo tDificultad.
              - Un campo llamado restriccion de tipo tRestriccion.

              
              Declara dentro de main una variable llamada atraccion1 de tipo tAtraccion.
            answer: |
              #include <stdbool.h>

              #define MAX_NOMBRE 30

              typedef enum {
                  BAJA, MEDIA, ALTA
              } tDificultad;

              typedef struct {
                  float alturaMinima;
                  bool embarazadasProhibido;
              } tRestriccion;

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  tDificultad dificultad;
                  tRestriccion restriccion;
              } tAtraccion;

              int main() {
                  tAtraccion atraccion1;
                  return 0;
              }
            hint: Declara enum y structs con typedef y en ese orden antes de main.

          - id: p-4-atraccion-restricciones
            language: Pseudocode
            week: 4
            prompt: |
              Crea un tipo enumerado tDificultad con los valores BAJA, MEDIA y ALTA.
              Crea un tipo tRestriccion con:
              - Un número real llamado alturaMinima.
              - Un valor booleano llamado embarazadasProhibido.

              Crea un tipo tAtraccion con:
              - Un texto llamado nombre.
              - Un campo llamado dificultad de tipo tDificultad.
              - Un campo llamado restriccion de tipo tRestriccion.

              Declara dentro del bloque principal una variable llamada atraccion1 de tipo tAtraccion.
            answer: |
              type
                tDificultad = { BAJA, MEDIA, ALTA }
              
                tRestriccion = record
                  alturaMinima: real;
                  embarazadasProhibido: boolean;
                end record
              
                tAtraccion = record
                  nombre: string;
                  dificultad: tDificultad;
                  restriccion: tRestriccion;
                end record
              end type

              algorithm
                var
                  atraccion1: tAtraccion;
                end var
              end algorithm
            hint:
              "Define los tipos en orden: enum, record restricción y luego el record atracción. Utiliza un solo bloque type end type."

          - id: c-4-cartelera-atracciones
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_NOMBRE (20) y MAX_ATRACCIONES (3).
              
              Crea un tipo tAtraccion con:
              - Una cadena de caracteres llamada nombre con tamaño máximo definido por MAX_NOMBRE (valor 20).
              - Un número entero llamado duracionMinutos.
              
              Declara dentro de main un array llamado cartelera de tipo tAtraccion con MAX_ATRACCIONES elementos.
            answer: |
              #define MAX_NOMBRE 20
              #define MAX_ATRACCIONES 3

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  int duracionMinutos;
              } tAtraccion;

              int main() {
                  tAtraccion cartelera[MAX_ATRACCIONES];
                  return 0;
              }
            hint: El array de structs se declara como cualquier array, usando el tipo tAtraccion.

          - id: p-4-cartelera-atracciones
            language: Pseudocode
            week: 4
            prompt: |
              Declara las constantes MAX_NOMBRE (20) y MAX_ATRACCIONES (3).
              
              Crea un tipo tAtraccion con:
              - Un texto llamado nombre.
              - Un número entero llamado duracionMinutos.

              Declara dentro del bloque principal un array llamado cartelera de tipo tAtraccion con MAX_ATRACCIONES elementos.
            answer: |
              const
                MAX_ATRACCIONES: integer = 3;
              end const

              type
                tAtraccion = record
                  nombre: string;
                  duracionMinutos: integer;
                end record
              end type

              algorithm
                var
                  cartelera: vector[MAX_ATRACCIONES] of tAtraccion;
                end var
              end algorithm
            hint: En pseudocódigo los arrays se declaran con vector[tamaño] of tipo.

          - id: c-4-mapa-zona
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_NOMBRE (25), FILAS (2) y COLUMNAS (3).
              
              Crea un tipo tMapaZona con:
              - Una cadena de caracteres llamada nombreZona con tamaño máximo definido por MAX_NOMBRE (valor 25).
              - Una matriz booleana llamada ocupacion con tamaño FILAS x COLUMNAS.

              Declara dentro de main una variable llamada mapa1 de tipo tMapaZona.
            answer: |
              #include <stdbool.h>

              #define MAX_NOMBRE 25
              #define FILAS 2
              #define COLUMNAS 3

              typedef struct {
                  char nombreZona[MAX_NOMBRE];
                  bool ocupacion[FILAS][COLUMNAS];
              } tMapaZona;

              int main() {
                  tMapaZona mapa1;
                  return 0;
              }
            hint: Para usar bool en C incluye <stdbool.h>. La matriz va como campo del struct.

          - id: p-4-mapa-zona
            language: Pseudocode
            week: 4
            prompt: |
              Declara las constantes FILAS con valor 2 y COLUMNAS con valor 3.
              
              Crea un tipo tMapaZona con:
              - Un texto llamado nombreZona.
              - Una matriz booleana llamada ocupacion de tamaño FILAS x COLUMNAS.
              
              Declara dentro del bloque principal una variable llamada mapa1 de tipo tMapaZona.
            answer: |
              const
                FILAS: integer = 2;
                COLUMNAS: integer = 3;
              end const

              type
                tMapaZona = record
                  nombreZona: string;
                  ocupacion: vector[FILAS][COLUMNAS] of boolean;
                end record
              end type

              algorithm
                var
                  mapa1: tMapaZona;
                end var
              end algorithm
            hint: En pseudocódigo, las matrices se representan como vector[FILAS][COLUMNAS] of tipo.

          - id: c-4-snack-categoria
            language: C
            week: 4
            prompt: |
              Declara la constante MAX_NOMBRE con valor 20.
              
              Crea un tipo tSnack con:
              - Una cadena de caracteres llamada nombre con tamaño máximo definido por MAX_NOMBRE (valor 20).
              - Un carácter llamado categoria (por ejemplo 'A', 'B', 'C').

              Declara dentro de main una variable llamada snack1 de tipo tSnack.
            answer: |
              #define MAX_NOMBRE 20

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  char categoria;
              } tSnack;

              int main() {
                  tSnack snack1;
                  return 0;
              }
            hint: Recuerda que un carácter en C es tipo char y ocupa un solo carácter.

          - id: p-4-snack-categoria
            language: Pseudocode
            week: 4
            prompt: |
              Crea un tipo tSnack con:
              - Un texto llamado nombre.
              - Un carácter llamado categoria.

              Declara dentro del bloque principal una variable llamada snack1 de tipo tSnack.
            answer: |
              type
                tSnack = record
                  nombre: string;
                  categoria: character;
                end record
              end type

              algorithm
                var
                  snack1: tSnack;
                end var
              end algorithm
            hint: El campo categoria es de tipo character (un único símbolo).

          - id: c-4-puesto-precios
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_NOMBRE (25) y NUM_PLATOS (4).
              
              Crea un tipo tPuestoComida con:
              - Una cadena de caracteres llamada nombre con tamaño máximo definido por MAX_NOMBRE (valor 25).
              - Un array de números decimales llamado precios con tamaño NUM_PLATOS.

              Declara dentro de main una variable llamada puesto1 de tipo tPuestoComida.
            answer: |
              #define MAX_NOMBRE 25
              #define NUM_PLATOS 4

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  float precios[NUM_PLATOS];
              } tPuestoComida;

              int main() {
                  tPuestoComida puesto1;
                  return 0;
              }
            hint: Declara las constantes antes del typedef; el array precios es de longitud fija.

          - id: p-4-puesto-precios
            language: Pseudocode
            week: 4
            prompt: |
              Declara la constante NUM_PLATOS con valor 4.
              
              Crea un tipo tPuestoComida con:
              - Un texto llamado nombre.
              - Un array de números reales llamado precios con tamaño NUM_PLATOS.

              Declara dentro del bloque principal una variable llamada puesto1 de tipo tPuestoComida.
            answer: |
              const
                NUM_PLATOS: integer = 4;
              end const

              type
                tPuestoComida = record
                  nombre: string;
                  precios: vector[NUM_PLATOS] of real;
                end record
              end type

              algorithm
                var
                  puesto1: tPuestoComida;
                end var
              end algorithm
            hint: En pseudocódigo usa vector[NUM_PLATOS] of real para el campo precios.


      - number: 2
        explanation:
          C: |
            En este nivel aprenderás a **declarar, inicializar y acceder a estructuras (`struct`) en C**, usando ejemplos relacionados con atracciones de parques.  
            Las estructuras son muy útiles para agrupar información variada bajo un mismo nombre.

            ### ¿Qué es un `struct`?
            Una estructura (`struct`) te permite agrupar distintos datos bajo un solo tipo.  
            Por ejemplo, para representar una atracción con un nombre, tipo y duración:

            ```c
            typedef struct {
                char nombre[30];
                int tipo;
                int duracion;
            } tAtraccion;
            ```

            Aquí se definen tres campos:  
            - `nombre`: cadena de caracteres.  
            - `tipo`: número entero que representa la categoría.  
            - `duracion`: entero con la duración en minutos.  

            ---

            ### Declarar y asignar manualmente
            ```c
            #include <string.h>

            int main() {
                tAtraccion a;

                strncpy(a.nombre, "Montaña Rusa", 30);
                a.tipo = 1;
                a.duracion = 5;

                return 0;
            }
            ```

            ---

            ### Declarar e inicializar con llaves
            ```c
            int main() {
                tAtraccion a = { "Torre de Caída", 2, 3 };
                return 0;
            }
            ```

            ---

            ### Acceso a campos
            Para acceder a un campo de una estructura se usa el operador punto (`.`):

            ```c
            #include <stdio.h>
            #include <string.h>

            int main() {
                tAtraccion a = { "Noria", 3, 4 };

                printf("Nombre: %s\n", a.nombre);
                printf("Duración: %d minutos\n", a.duracion);

                return 0;
            }
            ```

            ---

            ### Array de estructuras
            También puedes crear un array de `structs`:

            ```c
            #include <string.h>

            int main() {
                tAtraccion parque[2];

                strncpy(parque[0].nombre, "Noria", 30);
                parque[0].tipo = 3;
                parque[0].duracion = 4;

                strncpy(parque[1].nombre, "Montaña Rusa", 30);
                parque[1].tipo = 1;
                parque[1].duracion = 5;

                return 0;
            }
            ```

            Para acceder a un campo de un elemento concreto:
            ```c
            printf("Nombre primera atracción: %s\n", parque[0].nombre);
            ```

            ---

            ### Ejemplo completo
            ```c
            #include <stdio.h>
            #include <string.h>

            typedef struct {
                char nombre[30];
                int tipo;
                int duracion;
            } tAtraccion;

            int main() {
                tAtraccion parque[2];

                strncpy(parque[0].nombre, "Noria", 30);
                parque[0].tipo = 3;
                parque[0].duracion = 4;

                strncpy(parque[1].nombre, "Montaña Rusa", 30);
                parque[1].tipo = 1;
                parque[1].duracion = 5;

                for (int i = 0; i < 2; i++) {
                    printf("Atracción: %s\n", parque[i].nombre);
                    printf("Tipo: %d\n", parque[i].tipo);
                    printf("Duración: %d minutos\n\n", parque[i].duracion);
                }

                return 0;
            }
            ```

            Este programa muestra cómo definir, inicializar y recorrer un array de estructuras para representar varias atracciones.

          Pseudocode: |
            En pseudocódigo también puedes usar **registros (`record`)** para agrupar datos de una entidad.  
            Son útiles para representar objetos del juego, como atracciones de un parque.

            ### ¿Qué es un `record`?
            Un `record` es una estructura con diferentes campos:

            ```pseudocode
            type
              tAtraccion = record
                nombre: string;
                tipo: integer;
                duracion: integer;
              end record
            end type
            ```

            ---

            ### Declarar y asignar valores
            ```pseudocode
            algorithm
              var
                a: tAtraccion;
              end var

              a.nombre := "Montaña Rusa";
              a.tipo := 1;
              a.duracion := 5;
            end algorithm
            ```

            ---

            ### Acceso a campos
            Para acceder a los campos se usa el punto (`.`):

            ```pseudocode
            algorithm
              var
                a: tAtraccion;
              end var

              a.nombre := "Noria";
              a.tipo := 3;
              a.duracion := 4;

              writeString(a.nombre);
              writeInteger(a.duracion);
            end algorithm
            ```

            ---

            ### Array de registros
            También puedes crear arrays de registros para almacenar varias atracciones:

            ```pseudocode
            algorithm
              var
                parque: vector[2] of tAtraccion;
              end var

              parque[1].nombre := "Noria";
              parque[1].tipo := 3;
              parque[1].duracion := 4;

              parque[2].nombre := "Torre de Caída";
              parque[2].tipo := 2;
              parque[2].duracion := 3;
            end algorithm
            ```

            Para acceder a un campo de un elemento concreto:
            ```pseudocode
            writeString(parque[1].nombre);
            writeInteger(parque[1].duracion);
            ```

            ---

            ### Ejemplo completo
            ```pseudocode
            type
              tAtraccion = record
                nombre: string;
                tipo: integer;
                duracion: integer;
              end record
            end type

            algorithm parqueDiversiones
              var
                parque: vector[2] of tAtraccion;
                i: integer;
              end var

              parque[1].nombre := "Noria";
              parque[1].tipo := 3;
              parque[1].duracion := 4;

              parque[2].nombre := "Montaña Rusa";
              parque[2].tipo := 1;
              parque[2].duracion := 5;

              for i = 1 to 2 do
                writeString("Atracción: ");
                writeString(parque[i].nombre);
                writeString(", Tipo: ");
                writeInteger(parque[i].tipo);
                writeString(", Duración: ");
                writeInteger(parque[i].duracion);
                writeString(" minutos");
              end for
            end algorithm
            ```

            Este algoritmo muestra cómo definir, asignar y recorrer un array de registros que representan varias atracciones del parque.

        questions:
          # Semana 4 — Nivel 2 (Structs: declarar + inicializar + acceder/manipular)

          - id: c-4-atraccion-inicializa-imprime
            language: C
            week: 4
            prompt: |
              Declara la constante MAX_NOMBRE con valor 30.

              Declara el tipo tAtraccion con los campos exactos:
              - nombre: cadena de caracteres de tamaño MAX_NOMBRE
              - alturaMinima: número decimal
              - enMantenimiento: booleano

              Dentro de main, declara la variable atraccion1 de tipo tAtraccion e inicializa:
              - nombre = "Cometa"
              - alturaMinima = 1.20
              - enMantenimiento = false

              Imprime dos líneas:
              - "Nombre: x"
              - "Altura mínima: x" (Con dos decimales)
            answer: |
              #include <stdio.h>
              #include <stdbool.h>
              #include <string.h>

              #define MAX_NOMBRE 30

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  float alturaMinima;
                  bool enMantenimiento;
              } tAtraccion;

              int main() {
                  tAtraccion atraccion1;
                  strncpy(atraccion1.nombre, "Cometa", MAX_NOMBRE);
                  atraccion1.alturaMinima = 1.20;
                  atraccion1.enMantenimiento = false;

                  printf("Nombre: %s\n", atraccion1.nombre);
                  printf("Altura mínima: %.2f\n", atraccion1.alturaMinima);
                  return 0;
              }
            hint: Usa strncpy para copiar al campo nombre y printf en líneas separadas.

          - id: p-4-atraccion-inicializa-imprime
            language: Pseudocode
            week: 4
            prompt: |
              Declara el tipo tAtraccion con los campos exactos:
              - nombre: texto
              - alturaMinima: real
              - enMantenimiento: booleano

              En el bloque principal, declara la variable atraccion1 de tipo tAtraccion e inicializa:
              - nombre := "Cometa"
              - alturaMinima := 1.20
              - enMantenimiento := false

              Imprime dos líneas:
              - "Nombre: x"
              - "Altura mínima: x"
            answer: |
              type
                tAtraccion = record
                  nombre: string;
                  alturaMinima: real;
                  enMantenimiento: boolean;
                end record
              end type

              algorithm
                var
                  atraccion1: tAtraccion;
                end var

                atraccion1.nombre := "Cometa";
                atraccion1.alturaMinima := 1.20;
                atraccion1.enMantenimiento := false;

                writeString("Nombre: ");
                writeString(atraccion1.nombre);
                writeString("Altura mínima: ");
                writeReal(atraccion1.alturaMinima);
              end algorithm
            hint: Cada operación en su propia línea.

          - id: c-4-atraccion-con-enum-imprime
            language: C
            week: 4
            prompt: |
              Declara la constante MAX_NOMBRE con valor 25.

              Declara un tipo enumerado tTipoAtraccion con los valores RUEDA, BARCA y SIMULADOR.
              
              Declara el tipo tAtraccion con:
              - nombre: cadena de caracteres de tamaño MAX_NOMBRE
              - tipo: tTipoAtraccion

              Dentro de main, declara la variable atraccion1 de tipo tAtraccion e inicializa:
              - nombre = "Rueda Panorámica"
              - tipo = RUEDA

              Imprime una sola línea con el formato "Tipo: x" mostrando Rueda, Barca o Simulador en texto.
              
              Debes mapear el enum a string utilizando if else if.
            answer: |
              #include <stdio.h>
              #include <string.h>

              #define MAX_NOMBRE 25

              typedef enum { RUEDA, BARCA, SIMULADOR } tTipoAtraccion;

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  tTipoAtraccion tipo;
              } tAtraccion;

              int main() {
                  tAtraccion atraccion1;
                  strncpy(atraccion1.nombre, "Rueda Panorámica", MAX_NOMBRE);
                  atraccion1.tipo = RUEDA;

                  if (atraccion1.tipo == RUEDA) {
                      printf("Tipo: Rueda\n");
                  } else if (atraccion1.tipo == BARCA) {
                      printf("Tipo: Barca\n");
                  } else {
                      printf("Tipo: Simulador\n");
                  }
                  return 0;
              }
            hint: Hay 3 posibles casos en los que deberás imprimir el mensaje usando if else if.

          - id: p-4-atraccion-con-enum
            language: Pseudocode
            week: 4
            prompt: |
              Declara el tipo enumerado tTipoAtraccion con los valores RUEDA, BARCA y SIMULADOR.
              Declara el tipo tAtraccion con:
              - nombre: texto
              - tipo: tTipoAtraccion

              En el bloque principal, declara la variable atraccion1 de tipo tAtraccion e inicializa:
              - nombre := "Rueda Panorámica"
              - tipo := RUEDA

              Imprime dos líneas:
              - "Nombre: x"
              - "Tipo: x" (imprime el valor del enumerado tal cual)
            answer: |
              type
                tTipoAtraccion = { RUEDA, BARCA, SIMULADOR }
              end type

              type
                tAtraccion = record
                  nombre: string;
                  tipo: tTipoAtraccion;
                end record
              end type

              algorithm
                var
                  atraccion1: tAtraccion;
                end var

                atraccion1.nombre := "Rueda Panorámica";
                atraccion1.tipo := RUEDA;

                writeString("Nombre: ");
                writeString(atraccion1.nombre);
                writeString("Tipo: ");
                writeEnum(atraccion1.tipo);
              end algorithm
            hint: Usa writeEnum para mostrar el enumerado.

          - id: c-4-atraccion-horario-inicializa
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_NOMBRE (30) y MAX_HORA (6).

              Declara tHorario con:
              - apertura: cadena de tamaño MAX_HORA
              - cierre: cadena de tamaño MAX_HORA

              Declara tAtraccion con:
              - nombre: cadena de tamaño MAX_NOMBRE
              - horario: tHorario

              Dentro de main, declara atraccion1 e inicializa:
              - nombre = "Dragón"
              - horario - apertura = "10:00"
              - horario - cierre = "19:30"

              Imprime: "Cierra a: x"
            answer: |
              #include <stdio.h>
              #include <string.h>

              #define MAX_NOMBRE 30
              #define MAX_HORA 6

              typedef struct {
                  char apertura[MAX_HORA];
                  char cierre[MAX_HORA];
              } tHorario;

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  tHorario horario;
              } tAtraccion;

              int main() {
                  tAtraccion atraccion1;
                  strncpy(atraccion1.nombre, "Dragón", MAX_NOMBRE);
                  strncpy(atraccion1.horario.apertura, "10:00", MAX_HORA);
                  strncpy(atraccion1.horario.cierre, "19:30", MAX_HORA);

                  printf("Cierra a: %s\n", atraccion1.horario.cierre);
                  return 0;
              }
            hint: Usa strncpy con el tamaño adecuado para cada campo.

          - id: p-4-atraccion-horario-inicializa
            language: Pseudocode
            week: 4
            prompt: |
              Declara tHorario con:
              - apertura: texto
              - cierre: texto

              Declara tAtraccion con:
              - nombre: texto
              - horario: tHorario

              En el bloque principal, declara atraccion1 e inicializa:
              - nombre := "Dragón"
              - horario - apertura := "10:00"
              - horario - cierre := "19:30"

              Imprime: "Cierra a: x"
            answer: |
              type
                tHorario = record
                  apertura: string;
                  cierre: string;
                end record

                tAtraccion = record
                  nombre: string;
                  horario: tHorario;
                end record
              end type

              algorithm
                var
                  atraccion1: tAtraccion;
                end var

                atraccion1.nombre := "Dragón";
                atraccion1.horario.apertura := "10:00";
                atraccion1.horario.cierre := "19:30";

                writeString("Cierra a: ");
                writeString(atraccion1.horario.cierre);
              end algorithm
            hint: Accede a campos anidados con punto.

          - id: c-4-array-atracciones-suma-capacidad
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_NOMBRE (20) y MAX_ATRACCIONES (2).

              Declara tAtraccion con:
              - nombre: cadena de tamaño MAX_NOMBRE
              - capacidadMaxima: entero

              Dentro de main, declara lista (array de tAtraccion con MAX_ATRACCIONES) e inicializa:
              - lista 0 - nombre = "Lanza" y lista 0 - capacidadMaxima = 12
              - lista 1 - nombre = "Náutica" y lista 1 - capacidadMaxima = 8

              Declara totalCapacidad (entero) y guarda la suma de ambas capacidades. 
              
              Imprime "Total: x".
            answer: |
              #include <stdio.h>
              #include <string.h>

              #define MAX_NOMBRE 20
              #define MAX_ATRACCIONES 2

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  int capacidadMaxima;
              } tAtraccion;

              int main() {
                  tAtraccion lista[MAX_ATRACCIONES];

                  strncpy(lista[0].nombre, "Lanza", MAX_NOMBRE);
                  lista[0].capacidadMaxima = 12;

                  strncpy(lista[1].nombre, "Náutica", MAX_NOMBRE);
                  lista[1].capacidadMaxima = 8;

                  int totalCapacidad = lista[0].capacidadMaxima + lista[1].capacidadMaxima;
                  printf("Total: %d\n", totalCapacidad);
                  return 0;
              }
            hint: Suma campos enteros y muestra el resultado.

          - id: p-4-array-atracciones-suma-capacidad
            language: Pseudocode
            week: 4
            prompt: |
              Declara la constante MAX_ATRACCIONES con valor 2.

              Declara tAtraccion con:
              - nombre: texto
              - capacidadMaxima: entero

              En el bloque principal, declara lista (vector[MAX_ATRACCIONES] de tAtraccion) e inicializa:
              - lista 0 - nombre = "Lanza" y lista 0 - capacidadMaxima = 12
              - lista 1 - nombre = "Náutica"; lista 1 - capacidadMaxima = 8

              Declara totalCapacidad (entero) como la suma de ambas capacidades. 
              
              Imprime "Total: x".
            answer: |
              const
                MAX_ATRACCIONES: integer = 2;
              end const

              type
                tAtraccion = record
                  nombre: string;
                  capacidadMaxima: integer;
                end record
              end type

              algorithm
                var
                  lista: vector[MAX_ATRACCIONES] of tAtraccion;
                  totalCapacidad: integer;
                end var

                lista[1].nombre := "Lanza";
                lista[1].capacidadMaxima := 12;
                lista[2].nombre := "Náutica";
                lista[2].capacidadMaxima := 8;

                totalCapacidad := lista[1].capacidadMaxima + lista[2].capacidadMaxima;

                writeString("Total: ");
                writeInteger(totalCapacidad);
              end algorithm
            hint: Índices desde 1 en pseudocódigo.

          - id: c-4-precios-promedio
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_NOMBRE (25) y NUM_PRECIOS (3).

              Declara tPuestoComida con:
              - nombre: cadena de tamaño MAX_NOMBRE
              - precios: array de decimales de tamaño NUM_PRECIOS

              Dentro de main, declara puesto1 e inicializa:
              - nombre = "Taco Loco"
              - precios = (3.5, 4.0, 2.5)

              Calcula el promedio en la variable promedio (decimal) e imprime "Promedio: x" con un decimal.
            answer: |
              #include <stdio.h>
              #include <string.h>

              #define MAX_NOMBRE 25
              #define NUM_PRECIOS 3

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  float precios[NUM_PRECIOS];
              } tPuestoComida;

              int main() {
                  tPuestoComida puesto1;
                  strncpy(puesto1.nombre, "Taco Loco", MAX_NOMBRE);
                  puesto1.precios[0] = 3.5;
                  puesto1.precios[1] = 4.0;
                  puesto1.precios[2] = 2.5;

                  float promedio = (puesto1.precios[0] + puesto1.precios[1] + puesto1.precios[2]) / 3;
                  printf("Promedio: %.1f\n", promedio);
                  return 0;
              }
            hint: El promedio se calcula con la suma de todos los precios dividido entre 3. Utiliza paréntesis en la suma.

          - id: p-4-precios-promedio
            language: Pseudocode
            week: 4
            prompt: |
              Declara la constante NUM_PRECIOS con valor 3.

              Declara tPuestoComida con:
              - nombre: texto
              - precios: vector[NUM_PRECIOS] de reales

              En el bloque principal, declara puesto1 e inicializa:
              - nombre = "Taco Loco"
              - precios = (3.5, 4.0, 2.5)

              Calcula promedio (real) como la media de los tres precios e imprime "Promedio: x".
            answer: |
              const
                NUM_PRECIOS: integer = 3;
              end const

              type
                tPuestoComida = record
                  nombre: string;
                  precios: vector[NUM_PRECIOS] of real;
                end record
              end type

              algorithm
                var
                  puesto1: tPuestoComida;
                  promedio: real;
                end var

                puesto1.nombre := "Taco Loco";
                puesto1.precios[1] := 3.5;
                puesto1.precios[2] := 4.0;
                puesto1.precios[3] := 2.5;

                promedio := (puesto1.precios[1] + puesto1.precios[2] + puesto1.precios[3]) / 3;

                writeString("Promedio: ");
                writeReal(promedio);
              end algorithm
            hint: Una sentencia por línea.

          - id: c-4-ficha-booleano-ternario
            language: C
            week: 4
            prompt: |
              Declara la constante MAX_NOMBRE con valor 30.

              Declara tFichaSeguridad con:
              - inspector: cadena de tamaño MAX_NOMBRE
              - puntaje: decimal
              - aprobada: booleano

              Dentro de main, declara ficha1 e inicializa:
              - inspector = "María"
              - puntaje = 8.7
              - aprobada = true

              Imprime "Estado: Aprobada" si aprobada es true, o "Estado: Rechazada" si es false usando operador ternario.
            answer: |
              #include <stdio.h>
              #include <stdbool.h>
              #include <string.h>

              #define MAX_NOMBRE 30

              typedef struct {
                  char inspector[MAX_NOMBRE];
                  float puntaje;
                  bool aprobada;
              } tFichaSeguridad;

              int main() {
                  tFichaSeguridad ficha1;
                  strncpy(ficha1.inspector, "María", MAX_NOMBRE);
                  ficha1.puntaje = 8.7;
                  ficha1.aprobada = true;

                  printf("Estado: %s\n", ficha1.aprobada ? "Aprobada" : "Rechazada");
                  return 0;
              }
            hint: Este ejercicio usa ternario.

          - id: p-4-ficha-booleano
            language: Pseudocode
            week: 4
            prompt: |
              Declara tFichaSeguridad con:
              - inspector: texto
              - puntaje: real
              - aprobada: booleano

              En el bloque principal, declara ficha1 e inicializa:
              - inspector := "María"
              - puntaje := 8.7
              - aprobada := true

              Imprime:
              - "Inspector: x"
              - "Aprobada: x" (true o false)
            answer: |
              type
                tFichaSeguridad = record
                  inspector: string;
                  puntaje: real;
                  aprobada: boolean;
                end record
              end type

              algorithm
                var
                  ficha1: tFichaSeguridad;
                end var

                ficha1.inspector := "María";
                ficha1.puntaje := 8.7;
                ficha1.aprobada := true;

                writeString("Inspector: ");
                writeString(ficha1.inspector);
                writeString("Aprobada: ");
                writeBoolean(ficha1.aprobada);
              end algorithm
            hint: No hay operador ternario en pseudocódigo.

          - id: c-4-mapa-ocupacion-contar
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_NOMBRE (20), FILAS (2) y COLUMNAS (2).

              Declara tMapaZona con:
              - nombreZona: cadena de tamaño MAX_NOMBRE
              - ocupacion: matriz booleana de tamaño FILAS x COLUMNAS

              En main, declara mapa1 e inicializa:
              - nombreZona = "Zona A"
              - ocupacion 0-0 = true
              - ocupacion 0-1 = false
              - ocupacion 1-0 = true
              - ocupacion 1-1 = true

              Declara ocupadas (entero), inicializa en 0 y cuenta cuántas casillas true hay con if y sumas ++ (sin bucles ni operador ternario). 
              
              Imprime "Ocupadas: x".
            answer: |
              #include <stdio.h>
              #include <stdbool.h>
              #include <string.h>

              #define MAX_NOMBRE 20
              #define FILAS 2
              #define COLUMNAS 2

              typedef struct {
                  char nombreZona[MAX_NOMBRE];
                  bool ocupacion[FILAS][COLUMNAS];
              } tMapaZona;

              int main() {
                  tMapaZona mapa1;
                  strncpy(mapa1.nombreZona, "Zona A", MAX_NOMBRE);
                  mapa1.ocupacion[0][0] = true;
                  mapa1.ocupacion[0][1] = false;
                  mapa1.ocupacion[1][0] = true;
                  mapa1.ocupacion[1][1] = true;

                  int ocupadas = 0;
                  if (mapa1.ocupacion[0][0]) { 
                    ocupadas++; 
                  }
                  if (mapa1.ocupacion[0][1]) { 
                    ocupadas++; 
                  }
                  if (mapa1.ocupacion[1][0]) { 
                    ocupadas++; 
                  }
                  if (mapa1.ocupacion[1][1]) { 
                    ocupadas++; 
                  }

                  printf("Ocupadas: %d\n", ocupadas);
                  return 0;
              }
            hint: Usa if y acumulación con ++; no uses operador ternario.

          - id: p-4-mapa-ocupacion-contar
            language: Pseudocode
            week: 4
            prompt: |
              Declara las constantes FILAS (2) y COLUMNAS (2).

              Declara tMapaZona con:
              - nombreZona: texto
              - ocupacion: matriz booleana FILAS x COLUMNAS

              En el bloque principal, declara mapa1 e inicializa:
              - nombreZona = "Zona A"
              - ocupacion 0-0 = true
              - ocupacion 0-1 = false
              - ocupacion 1-0 = true
              - ocupacion 1-1 = true

              Declara ocupadas (entero), inicializa en 0 y cuenta cuántas casillas true hay con if (sin bucles). 
              
              Imprime "Ocupadas: x".
            answer: |
              const
                FILAS: integer = 2;
                COLUMNAS: integer = 2;
              end const

              type
                tMapaZona = record
                  nombreZona: string;
                  ocupacion: vector[FILAS][COLUMNAS] of boolean;
                end record
              end type

              algorithm
                var
                  mapa1: tMapaZona;
                  ocupadas: integer;
                end var

                mapa1.nombreZona := "Zona A";
                mapa1.ocupacion[1][1] := true;
                mapa1.ocupacion[1][2] := false;
                mapa1.ocupacion[2][1] := true;
                mapa1.ocupacion[2][2] := true;

                ocupadas := 0;
                if mapa1.ocupacion[1][1] = true then
                  ocupadas := ocupadas + 1;
                end if
                if mapa1.ocupacion[1][2] = true then
                  ocupadas := ocupadas + 1;
                end if
                if mapa1.ocupacion[2][1] = true then
                  ocupadas := ocupadas + 1;
                end if
                if mapa1.ocupacion[2][2] = true then
                  ocupadas := ocupadas + 1;
                end if

                writeString("Ocupadas: ");
                writeInteger(ocupadas);
              end algorithm
            hint: |
              Forma correcta del if en pseudocódigo: if … then / end if.

          - id: c-4-atraccion-dificultad-a-texto
            language: C
            week: 4
            prompt: |
              Declara la constante MAX_NOMBRE con valor 20.

              Declara tDificultad con valores BAJA, MEDIA y ALTA.
              
              Declara tAtraccion con:
              - nombre: cadena de tamaño MAX_NOMBRE
              - dificultad: tDificultad

              Dentro de main, declara atraccion1 e inicializa:
              - nombre = "Vértigo"
              - dificultad = ALTA

              Declara tipoStr (cadena de tamaño 10) y copia "Baja", "Media" o "Alta" según la dificultad de la atracción usando if/else. Imprime "Dif: x".
            answer: |
              #include <stdio.h>
              #include <string.h>

              #define MAX_NOMBRE 20

              typedef enum { BAJA, MEDIA, ALTA } tDificultad;

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  tDificultad dificultad;
              } tAtraccion;

              int main() {
                  tAtraccion atraccion1;
                  strncpy(atraccion1.nombre, "Vértigo", MAX_NOMBRE);
                  atraccion1.dificultad = ALTA;

                  char tipoStr[10];
                  if (atraccion1.dificultad == BAJA) {
                      strncpy(tipoStr, "Baja", 10);
                  } else if (atraccion1.dificultad == MEDIA) {
                      strncpy(tipoStr, "Media", 10);
                  } else {
                      strncpy(tipoStr, "Alta", 10);
                  }

                  printf("Dif: %s\n", tipoStr);
                  return 0;
              }
            hint: Usa if/else para seleccionar la cadena y strncpy para copiarla.

          - id: p-4-atraccion-dificultad-texto
            language: Pseudocode
            week: 4
            prompt: |
              Declara tDificultad con valores BAJA, MEDIA y ALTA.
              Declara tAtraccion con:
              - nombre: texto
              - dificultad: tDificultad

              En el bloque principal, declara atraccion1 e inicializa:
              - nombre := "Vértigo"
              - dificultad := ALTA

              Declara tipoStr (texto) y asígnale:
              - "Baja" si la dificultad es BAJA, "Media" si es MEDIA, o "Alta" si es ALTA.
              Imprime "Dif: x".
            answer: |
              type
                tDificultad = { BAJA, MEDIA, ALTA }
              end type

              type
                tAtraccion = record
                  nombre: string;
                  dificultad: tDificultad;
                end record
              end type

              algorithm
                var
                  atraccion1: tAtraccion;
                  tipoStr: string;
                end var

                atraccion1.nombre := "Vértigo";
                atraccion1.dificultad := ALTA;

                if atraccion1.dificultad = BAJA then
                  tipoStr := "Baja";
                else
                  if atraccion1.dificultad = MEDIA then
                    tipoStr := "Media";
                  else
                      tipoStr := "Alta";
                  end if
                end if

                writeString("Dif: ");
                writeString(tipoStr);
              end algorithm
            hint: Un if por caso también es válido en pseudocódigo.

          - id: c-4-precio-mayor
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_NOMBRE (20) y NUM_PRECIOS (3).

              Declara tPuestoComida con:
              - nombre: cadena de tamaño MAX_NOMBRE
              - precios: array de decimales de tamaño NUM_PRECIOS

              En main, declara puesto1 e inicializa:
              - nombre = "Papas Xpress"
              - precios = (2.5, 3.0, 1.8)

              Declara mayor (decimal) y calcula el mayor de los tres precios usando comparaciones e if (sin bucles ni operador ternario). Imprime "Mayor: x" con un decimal.
            answer: |
              #include <stdio.h>
              #include <string.h>

              #define MAX_NOMBRE 20
              #define NUM_PRECIOS 3

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  float precios[NUM_PRECIOS];
              } tPuestoComida;

              int main() {
                  tPuestoComida puesto1;
                  strncpy(puesto1.nombre, "Papas Xpress", MAX_NOMBRE);
                  puesto1.precios[0] = 2.5;
                  puesto1.precios[1] = 3.0;
                  puesto1.precios[2] = 1.8;

                  float mayor = puesto1.precios[0];
                  if (puesto1.precios[1] > mayor) { 
                    mayor = puesto1.precios[1]; 
                  }
                  if (puesto1.precios[2] > mayor) { 
                    mayor = puesto1.precios[2]; 
                  }

                  printf("Mayor: %.1f\n", mayor);
                  return 0;
              }
            hint: Actualiza mayor si encuentras un valor superior.

          - id: p-4-precio-mayor
            language: Pseudocode
            week: 4
            prompt: |
              Declara la constante NUM_PRECIOS (3).

              Declara tPuestoComida con:
              - nombre: texto
              - precios: vector[NUM_PRECIOS] de reales

              En el bloque principal, declara puesto1 e inicializa:
              - puesto1.nombre := "Papas Xpress"
              - puesto1.precios[1] := 2.5
              - puesto1.precios[2] := 3.0
              - puesto1.precios[3] := 1.8

              Declara mayor (real) y calcula el mayor de los tres precios con comparaciones (sin bucles). Imprime "Mayor: x".
            answer: |
              const
                NUM_PRECIOS: integer = 3;
              end const

              type
                tPuestoComida = record
                  nombre: string;
                  precios: vector[NUM_PRECIOS] of real;
                end record
              end type

              algorithm
                var
                  puesto1: tPuestoComida;
                  mayor: real;
                end var

                puesto1.nombre := "Papas Xpress";
                puesto1.precios[1] := 2.5;
                puesto1.precios[2] := 3.0;
                puesto1.precios[3] := 1.8;

                mayor := puesto1.precios[1];
                if puesto1.precios[2] > mayor then
                  mayor := puesto1.precios[2];
                end if
                if puesto1.precios[3] > mayor then
                  mayor := puesto1.precios[3];
                end if

                writeString("Mayor: ");
                writeReal(mayor);
              end algorithm
            hint: Una sentencia por línea; if con then / end if.

          - id: c-4-cartelera-inicializa-imprime-primera
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_NOMBRE (20) y MAX_ATRACCIONES (2).

              Declara tAtraccion con:
              - nombre: cadena de tamaño MAX_NOMBRE
              - duracionMinutos: entero

              En main, declara cartelera (array de tAtraccion con MAX_ATRACCIONES) e inicializa:
              - cartelera 0 - nombre = "Fantasmagoría" y cartelera 0 - duracionMinutos = 7
              - cartelera 1 - nombre = "Aqua Rush" y cartelera 1 - duracionMinutos = 12

              Imprime una línea con el formato: "Primera: x (y min)" mostrando el nombre y la duración de la primera atracción.
            answer: |
              #include <stdio.h>
              #include <string.h>

              #define MAX_NOMBRE 20
              #define MAX_ATRACCIONES 2

              typedef struct {
                  char nombre[MAX_NOMBRE];
                  int duracionMinutos;
              } tAtraccion;

              int main() {
                  tAtraccion cartelera[MAX_ATRACCIONES];

                  strncpy(cartelera[0].nombre, "Fantasmagoría", MAX_NOMBRE);
                  cartelera[0].duracionMinutos = 7;

                  strncpy(cartelera[1].nombre, "Aqua Rush", MAX_NOMBRE);
                  cartelera[1].duracionMinutos = 12;

                  printf("Primera: %s (%d min)\n", cartelera[0].nombre, cartelera[0].duracionMinutos);
                  return 0;
              }
            hint: Recuerda usar strncpy para los nombres.

          - id: p-4-cartelera-inicializa-imprime-primera
            language: Pseudocode
            week: 4
            prompt: |
              Declara la constante MAX_ATRACCIONES con valor 2.

              Declara tAtraccion con:
              - nombre: texto
              - duracionMinutos: entero

              En el bloque principal, declara cartelera (vector de MAX_ATRACCIONES) e inicializa:
              - cartelera 0 - nombre = "Fantasmagoría" y cartelera 0 - duracionMinutos = 7
              - cartelera 1 - nombre = "Aqua Rush" y cartelera 1 - duracionMinutos = 12

              Imprime una línea con el formato: "Primera: x (y min)" mostrando el nombre y duración de la primera atracción.
            answer: |
              const
                MAX_ATRACCIONES: integer = 2;
              end const

              type
                tAtraccion = record
                  nombre: string;
                  duracionMinutos: integer;
                end record
              end type

              algorithm
                var
                  cartelera: vector[MAX_ATRACCIONES] of tAtraccion;
                end var

                cartelera[1].nombre := "Fantasmagoría";
                cartelera[1].duracionMinutos := 7;
                cartelera[2].nombre := "Aqua Rush";
                cartelera[2].duracionMinutos := 12;

                writeString("Primera: ");
                writeString(cartelera[1].nombre);
                writeString(" (");
                writeInteger(cartelera[1].duracionMinutos);
                writeString(" min)");
              end algorithm
            hint: En pseudocódigo imprimimos por partes, cada llamada en su línea.


      - number: 3
        explanation:
          C: |
            En este nivel aprenderás a trabajar con **estructuras (`struct`) más avanzadas en C**, incluyendo:
            - **enumerados (`enum`)** para representar categorías de atracciones,  
            - **arrays de estructuras** para almacenar varias entidades,  
            - **estructuras anidadas** (structs dentro de structs),  
            - y su uso con **bucles** y **estructuras de control** (`if`, `while`, `for`, `switch`) para realizar operaciones.

            Estos conceptos son esenciales para modelar un parque de atracciones en un programa.

            ---

            ### Enumerados
            Un `enum` define un conjunto de valores con nombres más claros que los números.  
            Por ejemplo, los tipos de atracciones:

            ```c
            typedef enum {
                MONTANA_RUSA,
                CARRUSEL,
                SIMULADOR
            } tTipoAtraccion;
            ```

            ---

            ### Estructuras básicas
            Un `struct` agrupa datos relacionados.  
            Una atracción puede tener nombre, tipo y duración:

            ```c
            #define MAX_NOMBRE 20

            typedef struct {
                char nombre[MAX_NOMBRE];
                tTipoAtraccion tipo;
                int duracionMinutos;
            } tAtraccion;
            ```

            ---

            ### Arrays de estructuras
            Para manejar varias atracciones a la vez, usamos un array:

            ```c
            #define MAX_ATRACCIONES 3

            int main() {
                tAtraccion atracciones[MAX_ATRACCIONES];
                return 0;
            }
            ```

            ---

            ### Estructuras anidadas
            Una estructura puede contener otra.  
            Por ejemplo, cada atracción puede tener un horario con apertura y cierre:

            ```c
            #define MAX_HORA 6

            typedef struct {
                char apertura[MAX_HORA];
                char cierre[MAX_HORA];
            } tHorario;

            typedef struct {
                char nombre[MAX_NOMBRE];
                tTipoAtraccion tipo;
                int duracionMinutos;
                tHorario horario;
            } tAtraccion;
            ```

            ---

            ### Bucles con estructuras
            Podemos recorrer arrays de `structs` con `for` o `while` para pedir datos y realizar cálculos:

            ```c
            int main() {
                tAtraccion atracciones[MAX_ATRACCIONES];
                int i, totalDuracion = 0;

                for(i = 0; i < MAX_ATRACCIONES; i++) {
                    printf("Duración (min): ");
                    scanf("%d", &atracciones[i].duracionMinutos);
                    totalDuracion += atracciones[i].duracionMinutos;
                }

                printf("Total: %d\n", totalDuracion);
                return 0;
            }
            ```

            ---

            ### Condicionales y switch
            Podemos tomar decisiones con `if` y `switch`.  
            Ejemplo de menú con `do while`:

            ```c
            int main() {
                int opcion;
                do {
                    printf("Opción (1=MONTANA_RUSA,2=CARRUSEL,3=SIMULADOR,0=Salir): ");
                    scanf("%d", &opcion);

                    switch(opcion) {
                        case 1: printf("Montaña rusa\n"); break;
                        case 2: printf("Carrusel\n"); break;
                        case 3: printf("Simulador\n"); break;
                        case 0: printf("Saliendo...\n"); break;
                        default: printf("Inválida\n");
                    }
                } while(opcion != 0);
                return 0;
            }
            ```

            ---

            ### Comparación de cadenas
            Para comparar nombres de atracciones usamos `strcmp`:

            ```c
            int main() {
                tAtraccion a1, a2;
                printf("Nombre 1: ");
                scanf("%s", a1.nombre);
                printf("Nombre 2: ");
                scanf("%s", a2.nombre);

                if(strcmp(a1.nombre, a2.nombre) == 0) {
                    printf("Iguales\n");
                } else {
                    printf("Diferentes\n");
                }
                return 0;
            }
            ```

            ---

            ### Promedios y ternario
            Se puede calcular un promedio y decidir con `?:`:

            ```c
            int main() {
                tAtraccion atracciones[MAX_ATRACCIONES];
                int i, suma = 0;
                float promedio;

                for(i = 0; i < MAX_ATRACCIONES; i++) {
                    printf("Duración (min): ");
                    scanf("%d", &atracciones[i].duracionMinutos);
                    suma += atracciones[i].duracionMinutos;
                }

                promedio = suma / (float)MAX_ATRACCIONES;
                printf("Promedio: %.1f\n", promedio);
                printf("%s\n", (promedio >= 120.0) ? "Larga" : "Corta");

                return 0;
            }
            ```

            ---

            ### Ejemplo completo
            ```c
            #include <stdio.h>
            #include <string.h>
            #include <stdbool.h>

            #define MAX_ATRACCIONES 3
            #define MAX_NOMBRE 20
            #define MAX_HORA 6

            typedef enum {
                MONTANA_RUSA,
                CARRUSEL,
                SIMULADOR
            } tTipoAtraccion;

            typedef struct {
                char apertura[MAX_HORA];
                char cierre[MAX_HORA];
            } tHorario;

            typedef struct {
                char nombre[MAX_NOMBRE];
                tTipoAtraccion tipo;
                int duracionMinutos;
                bool enMantenimiento;
                tHorario horario;
            } tAtraccion;

            int main() {
                tAtraccion atracciones[MAX_ATRACCIONES];
                int i, totalDuracion = 0, contador = 0;

                for(i = 0; i < MAX_ATRACCIONES; i++) {
                    printf("Nombre: ");
                    scanf("%s", atracciones[i].nombre);
                    printf("Tipo (0=MONTANA_RUSA,1=CARRUSEL,2=SIMULADOR): ");
                    scanf("%u", &atracciones[i].tipo);
                    printf("Duración (min): ");
                    scanf("%d", &atracciones[i].duracionMinutos);
                    printf("¿En mantenimiento? (1 sí / 0 no): ");
                    int temp; scanf("%d", &temp);
                    atracciones[i].enMantenimiento = (temp != 0);
                    printf("Apertura: ");
                    scanf("%s", atracciones[i].horario.apertura);
                    printf("Cierre: ");
                    scanf("%s", atracciones[i].horario.cierre);

                    totalDuracion += atracciones[i].duracionMinutos;
                    if(atracciones[i].enMantenimiento) contador++;
                }

                float promedio = totalDuracion / (float)MAX_ATRACCIONES;
                printf("Duración total: %d\n", totalDuracion);
                printf("Promedio: %.1f\n", promedio);
                printf("%s\n", (promedio >= 120.0) ? "Larga" : "Corta");
                printf("En mantenimiento: %d\n", contador);

                for(i = 0; i < MAX_ATRACCIONES; i++) {
                    switch(atracciones[i].tipo) {
                        case MONTANA_RUSA: printf("Montaña rusa\n"); break;
                        case CARRUSEL:     printf("Carrusel\n");     break;
                        case SIMULADOR:    printf("Simulador\n");    break;
                    }
                }

                return 0;
            }
            ```

          Pseudocode: |
            En este nivel aprenderás a trabajar con **registros (`record`) más avanzados en pseudocódigo**, incluyendo:
            - **enumerados** para tipos de atracción,  
            - **arrays de registros** para manejar varias atracciones,  
            - **registros anidados**,  
            - y el uso de **bucles y estructuras de control** (`for`, `while`, `switch`, `if`) para operaciones.

            ---

            ### Enumerados
            ```pseudocode
            type
              tTipoAtraccion = { MONTANA_RUSA, CARRUSEL, SIMULADOR }
            end type
            ```

            ---

            ### Registros
            ```pseudocode
            type
              tAtraccion = record
                nombre: string;
                tipo: tTipoAtraccion;
                duracionMinutos: integer;
              end record
            end type
            ```

            ---

            ### Registros anidados
            ```pseudocode
            type
              tHorario = record
                apertura: string;
                cierre: string;
              end record
            end type

            type
              tAtraccion = record
                nombre: string;
                tipo: tTipoAtraccion;
                duracionMinutos: integer;
                enMantenimiento: boolean;
                horario: tHorario;
              end record
            end type
            ```

            ---

            ### Arrays de registros
            ```pseudocode
            const
              MAX_ATRACCIONES: integer = 3;
            end const

            algorithm
              var
                parque: vector[MAX_ATRACCIONES] of tAtraccion;
              end var
            end algorithm
            ```

            ---

            ### Bucles y operaciones
            ```pseudocode
            algorithm
              var
                parque: vector[MAX_ATRACCIONES] of tAtraccion;
                i, totalDuracion: integer;
              end var

              totalDuracion := 0;
              for i := 1 to MAX_ATRACCIONES do
                writeString("Duración (min): ");
                parque[i].duracionMinutos := readInteger();
                totalDuracion := totalDuracion + parque[i].duracionMinutos;
              end for

              writeString("Total: ");
              writeInteger(totalDuracion);
            end algorithm
            ```

            ---

            ### Condicionales y switch
            ```pseudocode
            algorithm
              var
                atraccion: tAtraccion;
              end var

              atraccion.tipo := MONTANA_RUSA;

              switch atraccion.tipo
                case MONTANA_RUSA then
                  writeString("Montaña rusa");
                end case
                case CARRUSEL then
                  writeString("Carrusel");
                end case
                case SIMULADOR then
                  writeString("Simulador");
                end case
              end switch
            end algorithm
            ```

            ---

            ### Comparación de cadenas
            ```pseudocode
            algorithm
              var
                a1, a2: tAtraccion;
              end var

              writeString("Nombre 1: ");
              a1.nombre := readString();
              writeString("Nombre 2: ");
              a2.nombre := readString();

              if a1.nombre = a2.nombre then
                writeString("Iguales");
              else
                writeString("Diferentes");
              end if
            end algorithm
            ```

            ---

            ### Promedios
            ```pseudocode
            algorithm
              var
                parque: vector[MAX_ATRACCIONES] of tAtraccion;
                i, suma: integer;
                promedio: real;
              end var

              suma := 0;
              for i := 1 to MAX_ATRACCIONES do
                writeString("Duración (min): ");
                parque[i].duracionMinutos := readInteger();
                suma := suma + parque[i].duracionMinutos;
              end for

              promedio := suma / integerToReal(MAX_ATRACCIONES);
              writeString("Promedio: ");
              writeReal(promedio);
            end algorithm
            ```

            ---

            ### Ejemplo completo
            ```pseudocode
            const
              MAX_ATRACCIONES: integer = 3;
            end const

            type
              tTipoAtraccion = { MONTANA_RUSA, CARRUSEL, SIMULADOR };
            end type

            type
              tHorario = record
                apertura: string;
                cierre: string;
              end record
            end type

            type
              tAtraccion = record
                nombre: string;
                tipo: tTipoAtraccion;
                duracionMinutos: integer;
                enMantenimiento: boolean;
                horario: tHorario;
              end record
            end type

            algorithm parqueDiversiones
              var
                parque: vector[MAX_ATRACCIONES] of tAtraccion;
                i, contador, suma: integer;
                promedio: real;
              end var

              suma := 0;
              contador := 0;

              for i := 1 to MAX_ATRACCIONES do
                writeString("Nombre: ");
                parque[i].nombre := readString();

                writeString("Tipo (0=MONTANA_RUSA,1=CARRUSEL,2=SIMULADOR): ");
                parque[i].tipo := readEnum();

                writeString("Duración (min): ");
                parque[i].duracionMinutos := readInteger();
                suma := suma + parque[i].duracionMinutos;

                writeString("¿En mantenimiento? (true/false): ");
                parque[i].enMantenimiento := readBoolean();
                if parque[i].enMantenimiento then
                  contador := contador + 1;
                end if

                writeString("Apertura: ");
                parque[i].horario.apertura := readString();
                writeString("Cierre: ");
                parque[i].horario.cierre := readString();
              end for

              promedio := suma / integerToReal(MAX_ATRACCIONES);

              writeString("Duración total: ");
              writeInteger(suma);
              writeString("Promedio: ");
              writeReal(promedio);
              writeString("En mantenimiento: ");
              writeInteger(contador);

              for i := 1 to MAX_ATRACCIONES do
                switch parque[i].tipo
                  case MONTANA_RUSA then
                    writeString("Montaña rusa");
                  end case
                  case CARRUSEL then
                    writeString("Carrusel");
                  end case
                  case SIMULADOR then
                    writeString("Simulador");
                  end case
                end switch
              end for
            end algorithm
            ```

        questions:
          - id: c-4-l3-registro-basico-for
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_ATRACCIONES con valor 3 y MAX_NOMBRE con valor 20.
              
              Crea un tipo enumerado llamado tTipoAtraccion con los valores MONTANA_RUSA, CARRUSEL y SIMULADOR.
              
              Crea un tipo tAtraccion con los campos exactos:
              - nombre: texto con tamaño máximo MAX_NOMBRE.
              - tipo: de tipo tTipoAtraccion.
              - duracionMinutos: número entero.
              
              Dentro de la función principal, declara un array llamado atracciones de tipo tAtraccion con MAX_ATRACCIONES elementos y una variable entera llamada i.
              
              Recorre el array con un bucle for y, en cada iteración, pide al usuario:
              - el nombre (muestra "Nombre: ") y guarda el texto en el campo de nombre de la atracción actual,
              - el tipo (muestra "Tipo (0=MONTANA_RUSA,1=CARRUSEL,2=SIMULADOR): ") y guarda el valor en el campo de tipo,
              - la duración en minutos (muestra "Duración (min): ") y guarda el número en el campo correspondiente.
              
              Al final, muestra por pantalla el nombre de la primera atracción en su propia línea.
            answer: |
              #include <stdio.h>
              
              #define MAX_ATRACCIONES 3
              #define MAX_NOMBRE 20
              
              typedef enum {
                  MONTANA_RUSA,
                  CARRUSEL,
                  SIMULADOR
              } tTipoAtraccion;
              
              typedef struct {
                  char nombre[MAX_NOMBRE];
                  tTipoAtraccion tipo;
                  int duracionMinutos;
              } tAtraccion;
              
              int main() {
                  tAtraccion atracciones[MAX_ATRACCIONES];
                  int i;
              
                  for(i = 0; i < MAX_ATRACCIONES; i++) {
                      printf("Nombre: ");
                      scanf("%s", atracciones[i].nombre);
                      printf("Tipo (0=MONTANA_RUSA,1=CARRUSEL,2=SIMULADOR): ");
                      scanf("%u", &atracciones[i].tipo);
                      printf("Duración (min): ");
                      scanf("%d", &atracciones[i].duracionMinutos);
                  }
              
                  printf("%s\n", atracciones[0].nombre);
                  return 0;
              }
            hint: |
              Limita la lectura del nombre con %19s (si MAX_NOMBRE es 20).

          - id: p-4-l3-registro-basico-for
            language: Pseudocode
            week: 4
            prompt: |
              Tema Parque de Atracciones.
              
              Declara la constante MAX_ATRACCIONES con valor 3.
              
              Crea un tipo enumerado llamado tTipoAtraccion con los valores MONTANA_RUSA, CARRUSEL y SIMULADOR.
              
              Crea un tipo tAtraccion con los campos exactos:
              - nombre: texto.
              - tipo: de tipo tTipoAtraccion.
              - duracionMinutos: número entero.
              
              En el bloque principal, declara un array llamado atracciones de tipo tAtraccion con MAX_ATRACCIONES elementos y una variable entera i.
              
              Recorre el array con un bucle for (de 1 a MAX_ATRACCIONES) y, en cada iteración, pide al usuario:
              - el nombre (muestra "Nombre: ") y guarda el texto en el campo de nombre de la atracción actual,
              - el tipo (muestra "Tipo (0=MONTANA_RUSA,1=CARRUSEL,2=SIMULADOR): "); lee un número auxiliar y asígnalo al campo de tipo mediante un switch,
              - la duración en minutos (muestra "Duración (min): ") y guarda el número en el campo correspondiente.
              
              Al final, muestra el nombre de la primera atracción en su propia línea.
            answer: |
              const
                MAX_ATRACCIONES: integer = 3;
              end const
              
              type
                tTipoAtraccion = { MONTANA_RUSA, CARRUSEL, SIMULADOR };
              end type
              
              type
                tAtraccion = record
                  nombre: string;
                  tipo: tTipoAtraccion;
                  duracionMinutos: integer;
                end record
              end type
              
              algorithm
                var
                  atracciones: vector[MAX_ATRACCIONES] of tAtraccion;
                  i: integer;
                  auxTipo: integer;
                end var
              
                for i := 1 to MAX_ATRACCIONES do
                  writeString("Nombre: ");
                  atracciones[i].nombre := readString();
              
                  writeString("Tipo (0=MONTANA_RUSA,1=CARRUSEL,2=SIMULADOR): ");
                  atracciones[i].tipo := readEnum();

                  writeString("Duración (min): ");
                  atracciones[i].duracionMinutos := readInteger();
                end for
              
                writeString(atracciones[1].nombre);
              end algorithm
            hint: |
              En pseudocodigo contamos con la funcion readEnum();

          - id: c-4-l3-suma-duraciones-while
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_ATRACCIONES con valor 3 y MAX_NOMBRE con valor 15.
              
              Define el tipo tAtraccion con:
              - nombre: texto con tamaño máximo MAX_NOMBRE.
              - duracionMinutos: número entero.
              
              En la función principal, declara un array atracciones de tipo tAtraccion. Asigna manualmente las duraciones 10, 15 y 20 a sus tres elementos.
              Declara una variable entera i y otra llamada totalDuracion inicializada a 0. Usando un bucle while, recorre el array y acumula en totalDuracion
              la suma de las duraciones. Al terminar, imprime en una línea: "Total: x".
            answer: |
              #include <stdio.h>
              
              #define MAX_ATRACCIONES 3
              #define MAX_NOMBRE 15
              
              typedef struct {
                  char nombre[MAX_NOMBRE];
                  int duracionMinutos;
              } tAtraccion;
              
              int main() {
                  tAtraccion atracciones[MAX_ATRACCIONES];
                  int i = 0;
                  int totalDuracion = 0;
              
                  atracciones[0].duracionMinutos = 10;
                  atracciones[1].duracionMinutos = 15;
                  atracciones[2].duracionMinutos = 20;
              
                  while(i < MAX_ATRACCIONES) {
                      totalDuracion += atracciones[i].duracionMinutos;
                      i++;
                  }
              
                  printf("Total: %d\n", totalDuracion);
                  return 0;
              }
            hint: |
              Inicializa i en 0 antes del while.

          - id: p-4-l3-suma-duraciones-while
            language: Pseudocode
            week: 4
            prompt: |
              Declara la constante MAX_ATRACCIONES con valor 3.
              
              Define el tipo tAtraccion con:
              - nombre: texto.
              - duracionMinutos: número entero.
              
              En el bloque principal, declara un array atracciones de tipo tAtraccion. Asigna manualmente a sus tres elementos las duraciones 10, 15 y 20.
              Declara una variable i e inicialízala a 1, y otra llamada totalDuracion con valor 0. Recorre el array con un bucle while sumando las duraciones
              en totalDuracion. Al final, escribe "Total: " y en la línea siguiente el valor acumulado.
            answer: |
              const
                MAX_ATRACCIONES: integer = 3;
              end const
              
              type
                tAtraccion = record
                  nombre: string;
                  duracionMinutos: integer;
                end record
              end type
              
              algorithm
                var
                  atracciones: vector[MAX_ATRACCIONES] of tAtraccion;
                  i: integer;
                  totalDuracion: integer;
                end var
              
                atracciones[1].duracionMinutos := 10;
                atracciones[2].duracionMinutos := 15;
                atracciones[3].duracionMinutos := 20;
              
                i := 1;
                totalDuracion := 0;
                while i <= MAX_ATRACCIONES do
                  totalDuracion := totalDuracion + atracciones[i].duracionMinutos;
                  i := i + 1;
                end while
              
                writeString("Total: ");
                writeInteger(totalDuracion);
              end algorithm
            hint: |
              En pseudocódigo los índices de arrays empiezan en 1.

          - id: c-4-l3-menu-switch-do-while
            language: C
            week: 4
            prompt: |
              Declara un tipo enumerado tTipoAtraccion con los valores MONTANA_RUSA, CARRUSEL y SIMULADOR.
              
              En la función principal, crea un menú dentro de un bucle do-while:
              - Pide una opción entera mostrando "Opción (1=MONTANA_RUSA,2=CARRUSEL,3=SIMULADOR,0=Salir): ".
              - Con un switch, muestra exactamente una de estas líneas según la opción:
                "Montaña rusa", "Carrusel", "Simulador", "Saliendo..." o "Inválida".
              
              El bucle termina cuando la opción sea 0.
            answer: |
              #include <stdio.h>
              
              typedef enum {
                  MONTANA_RUSA,
                  CARRUSEL,
                  SIMULADOR
              } tTipoAtraccion;
              
              int main() {
                  int opcion;
                  do {
                      printf("Opción (1=MONTANA_RUSA,2=CARRUSEL,3=SIMULADOR,0=Salir): ");
                      scanf("%d", &opcion);
              
                      switch(opcion) {
                          case 1: 
                            printf("Montaña rusa\n"); 
                            break;
                          case 2: 
                            printf("Carrusel\n"); 
                            break;
                          case 3: 
                            printf("Simulador\n"); 
                            break;
                          case 0: 
                            printf("Saliendo...\n"); 
                            break;
                          default: 
                            printf("Inválida\n");
                      }
                  } while(opcion != 0);
                  return 0;
              }
            hint: |
              do-while ejecuta el cuerpo al menos una vez.

          - id: p-4-l3-menu-switch-do-while
            language: Pseudocode
            week: 4
            prompt: |
              Crea un menú en un bucle do-while:
              - Pide una opción entera mostrando "Opción (1=Montaña rusa,2=Carrusel,3=Simulador,0=Salir): ".
              - Con un switch, muestra exactamente una de estas líneas:
                "Montaña rusa", "Carrusel", "Simulador", "Saliendo..." o "Inválida".
              
              El bucle termina cuando la opción sea 0.
            answer: |
              algorithm
                var
                  opcion: integer;
                end var
              
                do
                  writeString("Opción (1=Montaña rusa,2=Carrusel,3=Simulador,0=Salir): ");
                  opcion := readInteger();
              
                  switch opcion
                    case 1 then
                      writeString("Montaña rusa");
                    end case
                    case 2 then
                      writeString("Carrusel");
                    end case
                    case 3 then
                      writeString("Simulador");
                    end case
                    case 0 then
                      writeString("Saliendo...");
                    end case
                    case default then
                      writeString("Inválida");
                    end case
                  end switch
                while opcion <> 0;
              end algorithm
            hint: |
              La condición del do-while va después del bloque.

          - id: c-4-l3-strcmp-dos-atracciones
            language: C
            week: 4
            prompt: |
              Declara la constante MAX_NOMBRE con valor 25.
              
              Define el tipo tAtraccion con:
              - nombre: texto con tamaño máximo MAX_NOMBRE.
              
              En la función main, declara dos variables a1 y a2 de tipo tAtraccion. Pide al usuario dos nombres:
              - muestra "Nombre 1: " y guarda el texto en el nombre de a1,
              - muestra "Nombre 2: " y guarda el texto en el nombre de a2.
              
              Compara ambos nombres y muestra "Iguales" si son exactamente iguales, o "Diferentes" en caso contrario.
            answer: |
              #include <stdio.h>
              #include <string.h>
              
              #define MAX_NOMBRE 25
              
              typedef struct {
                  char nombre[MAX_NOMBRE];
              } tAtraccion;
              
              int main() {
                  tAtraccion a1, a2;
              
                  printf("Nombre 1: ");
                  scanf("%s", a1.nombre);
                  printf("Nombre 2: ");
                  scanf("%s", a2.nombre);
              
                  if(strcmp(a1.nombre, a2.nombre) == 0) {
                      printf("Iguales\n");
                  } else {
                      printf("Diferentes\n");
                  }
              
                  return 0;
              }
            hint: |
              strcmp devuelve 0 si las cadenas son iguales.

          - id: p-4-l3-compara-nombres-simple
            language: Pseudocode
            week: 4
            prompt: |
              Define el tipo tAtraccion con:
              - nombre: texto.
              
              En el bloque principal, declara a1 y a2 de tipo tAtraccion. Pide al usuario dos nombres:
              - muestra "Nombre 1: " y guarda el texto en el nombre de a1,
              - muestra "Nombre 2: " y guarda el texto en el nombre de a2.
              
              Si ambos nombres son iguales, muestra "Iguales"; en caso contrario, muestra "Diferentes".
            answer: |
              type
                tAtraccion = record
                  nombre: string;
                end record
              end type
              
              algorithm
                var
                  a1: tAtraccion;
                  a2: tAtraccion;
                end var
              
                writeString("Nombre 1: ");
                a1.nombre := readString();
                writeString("Nombre 2: ");
                a2.nombre := readString();
              
                if a1.nombre = a2.nombre then
                  writeString("Iguales");
                else
                  writeString("Diferentes");
                end if
              end algorithm
            hint: |
              La comparación de textos se realiza con = y <>.

          - id: c-4-l3-horarios-for
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_ATRACCIONES con valor 2, MAX_NOMBRE con valor 20 y MAX_HORA con valor 6.
              
              Crea un tipo tHorario con:
              - apertura: texto con tamaño máximo MAX_HORA.
              - cierre: texto con tamaño máximo MAX_HORA.
              
              Crea un tipo tAtraccion con:
              - nombre: texto con tamaño máximo MAX_NOMBRE.
              - horario: de tipo tHorario.
              
              En la función principal, declara un array atracciones de tipo tAtraccion y una variable entera i.
              Recorre el array con un bucle for y para cada elemento pide al usuario:
              - el nombre (muestra "Nombre: "),
              - la hora de apertura (muestra "Apertura: "),
              - la hora de cierre (muestra "Cierre: ").
              
              Al finalizar, muestra en una línea la hora de cierre de la segunda atracción.
            answer: |
              #include <stdio.h>
              
              #define MAX_ATRACCIONES 2
              #define MAX_NOMBRE 20
              #define MAX_HORA 6
              
              typedef struct {
                  char apertura[MAX_HORA];
                  char cierre[MAX_HORA];
              } tHorario;
              
              typedef struct {
                  char nombre[MAX_NOMBRE];
                  tHorario horario;
              } tAtraccion;
              
              int main() {
                  tAtraccion atracciones[MAX_ATRACCIONES];
                  int i;
                  for(i = 0; i < MAX_ATRACCIONES; i++) {
                      printf("Nombre: ");
                      scanf("%s", atracciones[i].nombre);
                      printf("Apertura: ");
                      scanf("%s", atracciones[i].horario.apertura);
                      printf("Cierre: ");
                      scanf("%s", atracciones[i].horario.cierre);
                  }
                  printf("%s\n", atracciones[1].horario.cierre);
                  return 0;
              }
            hint: |
              Respeta el orden del enunciado para declarar los datos

          - id: p-4-l3-horarios-for
            language: Pseudocode
            week: 4
            prompt: |
              Declara la constante MAX_ATRACCIONES con valor 2.
              
              Crea un tipo tHorario con:
              - apertura: texto.
              - cierre: texto.
              
              Crea un tipo tAtraccion con:
              - nombre: texto.
              - horario: de tipo tHorario.
              
              En el bloque principal, declara un array atracciones de tipo tAtraccion y una variable entera i.
              Recorre el array con un bucle for (de 1 a MAX_ATRACCIONES) y para cada elemento pide al usuario:
              - el nombre (muestra "Nombre: "),
              - la hora de apertura (muestra "Apertura: "),
              - la hora de cierre (muestra "Cierre: ").
              
              Al finalizar, muestra en una línea la hora de cierre de la segunda atracción.
            answer: |
              const
                MAX_ATRACCIONES: integer = 2;
              end const
              
              type
                tHorario = record
                  apertura: string;
                  cierre: string;
                end record
              end type
              
              type
                tAtraccion = record
                  nombre: string;
                  horario: tHorario;
                end record
              end type
              
              algorithm
                var
                  atracciones: vector[MAX_ATRACCIONES] of tAtraccion;
                  i: integer;
                end var
              
                for i := 1 to MAX_ATRACCIONES do
                  writeString("Nombre: ");
                  atracciones[i].nombre := readString();
                  writeString("Apertura: ");
                  atracciones[i].horario.apertura := readString();
                  writeString("Cierre: ");
                  atracciones[i].horario.cierre := readString();
                end for
              
                writeString(atracciones[2].horario.cierre);
              end algorithm
            hint: |
              Un campo puede ser otro record anidado.

          - id: c-4-l3-contar-mantenimiento-for
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_ATRACCIONES con valor 4 y MAX_NOMBRE con valor 20.
              
              Crea un tipo tAtraccion con:
              - nombre: texto con tamaño máximo MAX_NOMBRE.
              - enMantenimiento: valor lógico.
              
              En la función principal, declara un array atracciones de tipo tAtraccion, una variable entera i y otra entera contador inicializada a 0.
              Recorre el array con un bucle for. Para cada posición, pide al usuario:
              - el nombre (muestra "Nombre: ") y guárdalo en el campo de nombre,
              - si está en mantenimiento (muestra "¿En mantenimiento? (1 sí / 0 no): "); lee un número y conviértelo a valor lógico para el campo enMantenimiento.
              
              Luego, con otro bucle for, cuenta cuántas atracciones tienen enMantenimiento verdadero y muestra en una línea: "En mantenimiento: x".
            answer: |
              #include <stdio.h>
              #include <stdbool.h>
              
              #define MAX_ATRACCIONES 4
              #define MAX_NOMBRE 20
              
              typedef struct {
                  char nombre[MAX_NOMBRE];
                  bool enMantenimiento;
              } tAtraccion;
              
              int main() {
                  tAtraccion atracciones[MAX_ATRACCIONES];
                  int i, contador = 0;
                  int temp;
              
                  for(i = 0; i < MAX_ATRACCIONES; i++) {
                      printf("Nombre: ");
                      scanf("%s", atracciones[i].nombre);
                      printf("¿En mantenimiento? (1 sí / 0 no): ");
                      scanf("%d", &temp);
                      atracciones[i].enMantenimiento = (temp != 0);
                  }
              
                  for(i = 0; i < MAX_ATRACCIONES; i++) {
                      if(atracciones[i].enMantenimiento) {
                          contador++;
                      }
                  }
              
                  printf("En mantenimiento: %d\n", contador);
                  return 0;
              }
            hint: |
              Lee 0/1 y asigna al bool con una comparación.

          - id: p-4-l3-contar-mantenimiento-for
            language: Pseudocode
            week: 4
            prompt: |
              Declara la constante MAX_ATRACCIONES con valor 4.
              
              Crea un tipo tAtraccion con:
              - nombre: texto.
              - enMantenimiento: valor booleano.
              
              En el bloque principal, declara un array atracciones de tipo tAtraccion, una variable entera i, una entera contador (inicial 0) y una booleana temp.
              Recorre el array con un bucle for y, para cada posición, pide:
              - el nombre (muestra "Nombre: ") y guárdalo en el campo de nombre,
              - si está en mantenimiento (muestra "¿En mantenimiento? (true/false): "); lee el valor en temp y asígnalo al campo enMantenimiento.
              
              Después, con otro for, cuenta cuántas atracciones tienen enMantenimiento verdadero y escribe:
              "En mantenimiento: " y, en la línea siguiente, el número contado.
            answer: |
              const
                MAX_ATRACCIONES: integer = 4;
              end const
              
              type
                tAtraccion = record
                  nombre: string;
                  enMantenimiento: boolean;
                end record
              end type
              
              algorithm
                var
                  atracciones: vector[MAX_ATRACCIONES] of tAtraccion;
                  i: integer;
                  contador: integer;
                  temp: boolean;
                end var
              
                for i := 1 to MAX_ATRACCIONES do
                  writeString("Nombre: ");
                  atracciones[i].nombre := readString();
                  writeString("¿En mantenimiento? (true/false): ");
                  atracciones[i].enMantenimiento := readBoolean();
                end for
              
                contador := 0;
                for i := 1 to MAX_ATRACCIONES do
                  if atracciones[i].enMantenimiento then
                    contador := contador + 1;
                  end if
                end for
              
                writeString("En mantenimiento: ");
                writeInteger(contador);
              end algorithm
            hint: |
              Una sentencia por línea en pseudocódigo.

          - id: c-4-l3-switch-por-tipo
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_ATRACCIONES con valor 3 y MAX_NOMBRE con valor 18.
              
              Declara el tipo enumerado tTipoAtraccion con MONTANA_RUSA, CARRUSEL y SIMULADOR.
              Declara el tipo tAtraccion con:
              - nombre: texto con tamaño máximo MAX_NOMBRE.
              - tipo: de tipo tTipoAtraccion.
              
              En la función principal, lee los datos de tres atracciones usando un bucle for (nombre y tipo numérico 0..2).
              Después recorre el array con un bucle for y, para cada atracción, muestra exactamente una línea con el texto del tipo:
              "Montaña rusa", "Carrusel" o "Simulador". Usa un switch para decidir el texto.
            answer: |
              #include <stdio.h>
              
              #define MAX_ATRACCIONES 3
              #define MAX_NOMBRE 18
              
              typedef enum {
                  MONTANA_RUSA,
                  CARRUSEL,
                  SIMULADOR
              } tTipoAtraccion;
              
              typedef struct {
                  char nombre[MAX_NOMBRE];
                  tTipoAtraccion tipo;
              } tAtraccion;
              
              int main() {
                  tAtraccion atracciones[MAX_ATRACCIONES];
                  int i;
              
                  for(i = 0; i < MAX_ATRACCIONES; i++) {
                      printf("Nombre: ");
                      scanf("%s", atracciones[i].nombre);
                      printf("Tipo (0=MONTANA_RUSA,1=CARRUSEL,2=SIMULADOR): ");
                      scanf("%u", &atracciones[i].tipo;
                      
                  }
              
                  for(i = 0; i < MAX_ATRACCIONES; i++) {
                      switch(atracciones[i].tipo) {
                          case MONTANA_RUSA: 
                              printf("Montaña rusa\n"); 
                              break;
                          case CARRUSEL:     
                              printf("Carrusel\n");     
                              break;
                          case SIMULADOR:    
                              printf("Simulador\n");    
                              break;
                          default:           
                              printf("Desconocido\n");
                      }
                  }
                  return 0;
              }
            hint: |
              Un switch por cada elemento del array.

          - id: p-4-l3-switch-por-tipo
            language: Pseudocode
            week: 4
            prompt: |
              Declara la constante MAX_ATRACCIONES con valor 3.
              
              Declara el tipo enumerado tTipoAtraccion con MONTANA_RUSA, CARRUSEL y SIMULADOR.
              Declara el tipo tAtraccion con:
              - nombre: texto.
              - tipo: de tipo tTipoAtraccion.
              
              En el bloque principal, pide al usuario los datos de tres atracciones con un bucle (nombre y un número 0..2 para el tipo; usa un switch para asignarlo).
              Recorre el array con un bucle for y, para cada atracción, muestra exactamente una línea con el texto del tipo:
              "Montaña rusa", "Carrusel" o "Simulador".
            answer: |
              const
                MAX_ATRACCIONES: integer = 3;
              end const
              
              type
                tTipoAtraccion = { MONTANA_RUSA, CARRUSEL, SIMULADOR };
              end type
              
              type
                tAtraccion = record
                  nombre: string;
                  tipo: tTipoAtraccion;
                end record
              end type
              
              algorithm
                var
                  atracciones: vector[MAX_ATRACCIONES] of tAtraccion;
                  i: integer;
                end var
              
                for i := 1 to MAX_ATRACCIONES do
                  writeString("Nombre: ");
                  atracciones[i].nombre := readString();
                  writeString("Tipo (0=MONTANA_RUSA,1=CARRUSEL,2=SIMULADOR): ");
                  atracciones[i].tipo := readEnum();
                end for
              
                for i := 1 to MAX_ATRACCIONES do
                  switch atracciones[i].tipo
                    case MONTANA_RUSA then
                      writeString("Montaña rusa");
                    end case
                    case CARRUSEL then
                      writeString("Carrusel");
                    end case
                    case SIMULADOR then
                      writeString("Simulador");
                    end case
                    case default then
                      writeString("Desconocido");
                    end case
                  end switch
                end for
              end algorithm
            hint: |
              Mantén una sola salida por línea.

          - id: c-4-l3-entrada-hasta-fin-strcmp
            language: C
            week: 4
            prompt: |
              Declara las constantes MAX_ATRACCIONES con valor 4 y MAX_NOMBRE con valor 20.
              
              Define el tipo tAtraccion con:
              - nombre: texto con tamaño máximo MAX_NOMBRE.
              
              En la función principal, declara un array atracciones de tipo tAtraccion, un búfer temporal llamado tempNombre (texto de tamaño MAX_NOMBRE) y una variable entera i inicializada a 0.
              
              Usa un bucle while y repite mientras haya espacio disponible ( i menor que MAX_ATRACCIONES):
              - pide un nombre mostrando "Nombre (FIN para terminar): " y guárdalo en el búfer temporal,
              - si el usuario escribe la palabra FIN, detén la repetición (Usando break para detener el bucle),
              - en caso contrario (No uses else), copia el contenido del búfer temporal al campo de nombre del siguiente elemento y avanza al siguiente índice.
              
              Al terminar, muestra en una línea "Guardados: x" con la cantidad de elementos almacenados.
            answer: |
              #include <stdio.h>
              #include <string.h>
              
              #define MAX_ATRACCIONES 4
              #define MAX_NOMBRE 20
              
              typedef struct {
                  char nombre[MAX_NOMBRE];
              } tAtraccion;
              
              int main() {
                  tAtraccion atracciones[MAX_ATRACCIONES];
                  char tempNombre[MAX_NOMBRE];
                  int i = 0;
              
                  while(i < MAX_ATRACCIONES) {
                      printf("Nombre (FIN para terminar): ");
                      scanf("%s", tempNombre);
                      if(strcmp(tempNombre, "FIN") == 0) {
                          break;
                      }
                      strncpy(atracciones[i].nombre, tempNombre, MAX_NOMBRE);
                      i++;
                  }
              
                  printf("Guardados: %d\n", i);
                  return 0;
              }
            hint: |
              Usa strcmp para comparar con "FIN" y strncpy para copiar.

          - id: p-4-l3-entrada-hasta-vacio
            language: Pseudocode
            week: 4
            prompt: |
              Declara la constante MAX_ATRACCIONES con valor 4.
              
              Define el tipo tAtraccion con:
              - nombre: texto.
              
              En el bloque principal, declara un array atracciones de tipo tAtraccion, una variable de texto tempNombre y una entera i inicializada a 1.
              
              Mientras no se supere el límite y el usuario no escriba "FIN":
              - pide un nombre mostrando "Nombre (FIN para terminar): " y guárdalo en tempNombre,
              - si no es "FIN", guarda el texto en el nombre del siguiente elemento del array y avanza al siguiente índice.
              
              Al terminar, muestra "Guardados: " y, en la línea siguiente, la cantidad de elementos realmente guardados.
            answer: |
              const
                MAX_ATRACCIONES: integer = 4;
              end const
              
              type
                tAtraccion = record
                  nombre: string;
                end record
              end type
              
              algorithm
                var
                  atracciones: vector[MAX_ATRACCIONES] of tAtraccion;
                  tempNombre: string;
                  i: integer;
                end var
              
                i := 1;
                tempNombre := "";
                while (i <= MAX_ATRACCIONES and tempNombre <> "FIN") do
                  writeString("Nombre (FIN para terminar): ");
                  tempNombre := readString();
                  if tempNombre <> "FIN" then
                    atracciones[i].nombre := tempNombre;
                    i := i + 1;
                  end if
                end while
              
                writeString("Guardados: ");
                writeInteger(i - 1);
              end algorithm
            hint: |
              Controla fin por palabra y por límite.

          - id: c-4-l3-promedio-y-ternario
            language: C
            week: 4
            prompt: |
              Declara la constante MAX_ATRACCIONES con valor 3.
              
              Define el tipo tAtraccion con:
              - duracionMinutos: número entero.
              
              En la función principal, declara un array atracciones de tipo tAtraccion, una variable entera i , otra llamada suma con valor inicial 0 y un float promedio.
              Con un bucle for, pide al usuario tres duraciones mostrando "Duración (min): " y guarda cada valor en el campo de duración del elemento actual, acumulándolo en suma.
              
              Calcula el promedio como un número decimal dividiendo la suma entre 3 (Castea a float) y muestra:
              - en una línea: "Promedio: x.x" (con un decimal),
              - en la siguiente línea, usa un operador ternario para imprimir "Larga" si el promedio es mayor o igual que 120, o "Corta" en caso contrario.
            answer: |
              #include <stdio.h>
              
              #define MAX_ATRACCIONES 3
              
              typedef struct {
                  int duracionMinutos;
              } tAtraccion;
              
              int main() {
                  tAtraccion atracciones[MAX_ATRACCIONES];
                  int i;
                  suma = 0;
                  float promedio;
              
                  for(i = 0; i < MAX_ATRACCIONES; i++) {
                      printf("Duración (min): ");
                      scanf("%d", &atracciones[i].duracionMinutos);
                      suma += atracciones[i].duracionMinutos;
                  }
              
                  promedio = suma / (float)3;
                  printf("Promedio: %.1f\n", promedio);
                  printf("%s\n", (promedio >= 120.0) ? "Larga" : "Corta");
                  return 0;
              }
            hint: |
              Recuerda castear a (float) el numero 3 en la division

          - id: p-4-l3-promedio-simple
            language: Pseudocode
            week: 4
            prompt: |
              Declara la constante MAX_ATRACCIONES con valor 3.
              
              Define el tipo tAtraccion con:
              - duracionMinutos: número entero.
              
              En el bloque principal, declara un array atracciones de tipo tAtraccion, una variable entera i, otra entera suma y otra real promedio.
              Con un bucle for, pide al usuario tres duraciones mostrando "Duración (min): " y guarda cada valor en el campo de duración del elemento actual, acumulándolo en suma.
              
              Calcula el promedio como número real dividiendo suma entre 3 (Casteando a real) y muestra:
              - en una línea: "Promedio: "
              - en la línea siguiente, el valor del promedio.
            answer: |
              const
                MAX_ATRACCIONES: integer = 3;
              end const
              
              type
                tAtraccion = record
                  duracionMinutos: integer;
                end record
              end type
              
              algorithm
                var
                  atracciones: vector[MAX_ATRACCIONES] of tAtraccion;
                  i: integer;
                  suma: integer;
                  promedio: real;
                end var
              
                suma := 0;
                for i := 1 to MAX_ATRACCIONES do
                  writeString("Duración (min): ");
                  atracciones[i].duracionMinutos := readInteger();
                  suma := suma + atracciones[i].duracionMinutos;
                end for
              
                promedio := suma / integerToReal(3);
                writeString("Promedio: ");
                writeReal(promedio);
              end algorithm
            hint: |
              Una sentencia por línea; no hay operador ternario en pseudocódigo.

  - number: 5
    explanation: |
      Explicacion semana 5
    levels:
      - number: 1
        explanation:
          C: |
            En este nivel aprenderás a trabajar con **funciones** en C.  
            Las funciones permiten dividir un programa en partes más pequeñas y reutilizables.  
            En videojuegos, por ejemplo, puedes tener una función que calcule la vida restante de un personaje o la puntuación obtenida tras derrotar a un enemigo.

            ### ¿Qué es una función?
            Una **función** es un bloque de código independiente que:
            - Tiene un **nombre** que la identifica.
            - Puede recibir **parámetros de entrada** (valores con los que trabaja).  
              ⚠️ Los parámetros de entrada son **solo de lectura**: la función puede usarlos internamente, pero no modifica la variable original del programa que la llamó.
            - Devuelve un **valor de salida** (resultado).
            - Puede llamarse tantas veces como quieras.

            ---

            ### Prototipos de funciones (encabezados)
            Antes de `main`, se declaran los **prototipos**.  
            Un prototipo indica el nombre, parámetros y tipo de retorno, pero no contiene el cuerpo.

            ```c
            int calcularPuntos(int enemigos, int bonus);
            int factorial(int number);
            ```

            ---

            ### Sintaxis general de una función
            ```c
            tipo nombreFuncion(tipo param1, tipo param2, ...) {
                // instrucciones
                return valor;
            }
            ```

            *El `return` devuelve el resultado al punto del programa donde se llamó a la función.*

            ---

            ### Ejemplo completo
            ```c
            #include <stdio.h>

            // Prototipos
            int calcularPuntos(int enemigos, int bonus);
            int factorial(int number);

            // main primero
            int main() {
                int puntos, combinaciones;

                // Uso de función para puntos
                puntos = calcularPuntos(5, 20);
                printf("Puntos obtenidos: %d\n", puntos);

                // Uso de función factorial para combinaciones de ítems
                int totalItems = 6;
                int itemsElegidos = 2;
                combinaciones = factorial(totalItems) / 
                                (factorial(itemsElegidos) * factorial(totalItems - itemsElegidos));

                printf("Posibles combinaciones: %d\n", combinaciones);

                return 0;
            }

            // Implementaciones al final
            int calcularPuntos(int enemigos, int bonus) {
                int total = enemigos * 10 + bonus;
                return total;
            }

            int factorial(int number) {
                int fact = 1;
                int i = 1;
                while (i <= number) {
                    fact = fact * i;
                    i = i + 1;
                }
                return fact;
            }
            ```

            Este programa sigue la estructura usada en la universidad:  
            primero los **prototipos**, luego el `main`, y finalmente las **implementaciones**.  

            **Qué hace el programa:**  
            - Calcula la **puntuación** del jugador con la función `calcularPuntos`, multiplicando enemigos derrotados por 10 y sumando un bonus.  
            - Calcula las **combinaciones posibles de ítems** en un inventario usando la función `factorial`.  
            - Muestra por pantalla tanto los puntos obtenidos como el número de combinaciones.  

          Pseudocode: |
            En este nivel aprenderás a trabajar con **funciones** en pseudocódigo.  
            Las funciones permiten dividir un algoritmo en partes más pequeñas y reutilizables.  
            En videojuegos, puedes usarlas para calcular la vida restante de un personaje o la puntuación obtenida tras derrotar a enemigos.

            ### ¿Qué es una función?
            Una **función**:
            - Tiene un **nombre** que la identifica.
            - Puede recibir **parámetros de entrada**.  
              ⚠️ Los parámetros de entrada son **solo de lectura**: el algoritmo puede usarlos internamente, pero no cambia el valor de la variable que se pasó desde fuera.
            - Devuelve un **valor** como resultado.
            - Puede llamarse tantas veces como quieras.

            ---

            ### Prototipos de funciones
            En pseudocódigo no existen prototipos reales, pero podemos simularlos indicando solo la firma.  
            Esto ayuda a organizar el código cuando usamos varias funciones.

            ```pseudocode
            function calcularPuntos(enemigos: integer, bonus: integer): integer end function
            function factorial(number: integer): integer end function
            ```

            ---

            ### Sintaxis general de una función
            ```pseudocode
            function nombreFuncion(param1: tipo, param2: tipo): tipo
              ...
              return valor
            end function
            ```

            ---

            ### Ejemplo completo
            ```pseudocode
            { Implementaciones }
            function calcularPuntos(enemigos: integer, bonus: integer): integer
              var
                total: integer;
              end var
              total := enemigos * 10 + bonus;
              return total;
            end function

            function factorial(number: integer): integer
              var
                fact: integer;
                i: integer;
              end var
              fact := 1;
              i := 1;
              while i <= number do
                fact := fact * i;
                i := i + 1;
              end while
              return fact;
            end function

            algorithm funcionesVideojuego
              var
                puntos: integer;
                combinaciones: integer;
                totalItems: integer;
                itemsElegidos: integer;
              end var

              puntos := calcularPuntos(5, 20);
              writeString("Puntos obtenidos: ");
              writeInteger(puntos);

              totalItems := 6;
              itemsElegidos := 2;
              combinaciones := factorial(totalItems) div 
                               (factorial(itemsElegidos) * factorial(totalItems - itemsElegidos));

              writeString("Posibles combinaciones: ");
              writeInteger(combinaciones);
            end algorithm
            ```

            **Qué hace el programa:**  
            - Usa `calcularPuntos` para obtener la **puntuación** del jugador (enemigos derrotados × 10 + bonus).  
            - Usa `factorial` para calcular las **combinaciones posibles de ítems** en el inventario.  
            - Finalmente escribe en pantalla tanto los puntos obtenidos como el número de combinaciones.  

        questions:
          - id: c-5-l1-prototipo-xp
            language: C
            week: 5
            prompt: |
              Declara el prototipo de una función llamada addXP que reciba dos enteros xp1 y xp2
              y devuelva un entero con la experiencia total del jugador.
              No implementes la función, solo el prototipo.
            answer: |
              int addXP(int xp1, int xp2);
            hint: Un prototipo siempre incluye tipo de retorno, nombre, parámetros y termina con ;

          - id: p-5-l1-prototipo-xp
            language: Pseudocode
            week: 5
            prompt: |
              Escribe únicamente el encabezado de una función llamada addXP que reciba dos enteros xp1 y xp2
              y devuelva un entero con la experiencia total.
            answer: |
              function addXP(xp1: integer, xp2: integer): integer
              end function
            hint: En pseudocódigo se escribe function ... end function.

          - id: c-5-l1-prototipo-bonus
            language: C
            week: 5
            prompt: |
              Declara el prototipo de una función llamada applyBonus que reciba un número decimal base
              y devuelva un número decimal aumentado en 10%.
              No implementes la función, solo el prototipo.
            answer: |
              float applyBonus(float base);
            hint: Usa float como tipo de retorno y de parámetro.

          - id: p-5-l1-prototipo-bonus
            language: Pseudocode
            week: 5
            prompt: |
              Escribe solo el encabezado de una función llamada applyBonus que reciba un real base
              y devuelva un real aumentado en 10%.
            answer: |
              function applyBonus(base: real): real
              end function
            hint: Aquí solo se pide encabezado, no implementación.

          - id: c-5-l1-prototipo-enum-level
            language: C
            week: 5
            prompt: |
              Declara un tipo enumerado tLevel con los valores NOVATO, GUERRERO y MAESTRO.
              Luego declara el prototipo de una función llamada levelToValue que reciba un tLevel
              y devuelva un entero con el valor del nivel (ejemplo: NOVATO=1, GUERRERO=2, MAESTRO=3).
            answer: |
              typedef enum { NOVATO, GUERRERO, MAESTRO } tLevel;
              int levelToValue(tLevel l);
            hint: Aquí devolvemos un entero en lugar de un string.

          - id: p-5-l1-prototipo-enum-level
            language: Pseudocode
            week: 5
            prompt: |
              Declara un tipo enumerado tLevel con los valores NOVATO, GUERRERO y MAESTRO.
              Luego escribe solo el encabezado de una función llamada levelToValue que reciba un tLevel
              y devuelva un entero con el valor del nivel (ejemplo: NOVATO=1, GUERRERO=2, MAESTRO=3).
            answer: |
              type
                tLevel = { NOVATO, GUERRERO, MAESTRO }
              end type

              function levelToValue(l: tLevel): integer
              end function
            hint: El tipo enumerado se define antes de usarlo en la función.

          - id: c-5-l1-prototipo-struct-item
            language: C
            week: 5
            prompt: |
              Declara una constante MAX_ITEM = 15.
              Declara una estructura tItem con los campos:
              - nombre: array de chars
              - valor: entero
              Declara además el prototipo de una función getValor que reciba un tItem
              y devuelva un entero con su valor.
            answer: |
              #define MAX_ITEM 15

              typedef struct {
                  char nombre[MAX_ITEM];
                  int valor;
              } tItem;

              int getValor(tItem i);
            hint: Los textos se representan con arrays de char.

          - id: p-5-l1-prototipo-struct-item
            language: Pseudocode
            week: 5
            prompt: |
              Declara un tipo tItem con los campos:
              - nombre: string
              - valor: integer
              Luego escribe el encabezado de una función llamada getValor que reciba un tItem
              y devuelva un entero con su valor.
            answer: |
              type
                tItem = record
                  nombre: string;
                  valor: integer;
                end record
              end type

              function getValor(i: tItem): integer
              end function
            hint: El encabezado solo indica parámetros y tipo de retorno.

          - id: c-5-l1-main-powerup
            language: C
            week: 5
            prompt: |
              Declara el prototipo de una función llamada calcPowerUp que reciba un entero base
              y devuelva un entero con el doble de poder.
              En main declara base=40, llama a calcPowerUp y guarda el resultado en power.
              No implementes la función, solo el prototipo y la llamada.
            answer: |
              #include <stdio.h>

              int calcPowerUp(int base);

              int main() {
                  int base = 40;
                  int power = calcPowerUp(base);
                  return 0;
              }
            hint: Solo se pide prototipo y llamada, no la implementación.

          - id: p-5-l1-main-powerup
            language: Pseudocode
            week: 5
            prompt: |
              Escribe el encabezado de una función llamada calcPowerUp que reciba un entero base
              y devuelva un entero con el doble de poder.
              En el bloque principal declara base=40, llama a calcPowerUp y guarda el resultado en power.
              No implementes la función.
            answer: |
              function calcPowerUp(base: integer): integer
              end function

              algorithm
                var
                  base: integer;
                  power: integer;
                end var

                base := 40;
                power := calcPowerUp(base);
              end algorithm
            hint: Aquí solo se pide encabezado y llamada, no implementación.

          - id: c-5-l1-funcion-critical
            language: C
            week: 5
            prompt: |
              Declara el prototipo de una función llamada criticalHit que reciba un número decimal dmg
              y devuelva un número decimal.
              Implementa la función devolviendo dmg * 1.5 (aumenta el daño en 50%).
            answer: |
              float criticalHit(float dmg);

              float criticalHit(float dmg) {
                  return dmg * 1.5;
              }
            hint: Incluye prototipo antes de la implementación.

          - id: p-5-l1-funcion-critical
            language: Pseudocode
            week: 5
            prompt: |
              Escribe el encabezado de una función llamada criticalHit que reciba un real dmg
              y devuelva un real.
              Implementa la función devolviendo dmg * 1.5.
            answer: |
              function criticalHit(dmg: real): real
                return dmg * 1.5;
              end function
            hint: Aquí sí se incluye return dentro de la función.

          - id: c-5-l1-funcion-checkmana
            language: C
            week: 5
            prompt: |
              Declara una estructura tMage con el campo mana (entero).
              Declara el prototipo de una función hasMana que reciba un tMage
              y devuelva un entero (1 si mana > 0, 0 si no).
              En main declara un mago con mana=20 usando {}, llama a hasMana y guarda el resultado en estado.
              Implementa la función.
            answer: |
              #include <stdio.h>

              typedef struct {
                  int mana;
              } tMage;

              int hasMana(tMage m);

              int main() {
                  tMage mago = {20};
                  int estado = hasMana(mago);
                  return 0;
              }

              int hasMana(tMage m) {
                  if(m.mana > 0) return 1;
                  else return 0;
              }
            hint: Devuelve 1 si tiene maná, 0 si no.

          - id: p-5-l1-funcion-checkmana
            language: Pseudocode
            week: 5
            prompt: |
              Declara un tipo tMage con el campo mana (entero).
              Escribe el encabezado de una función hasMana que reciba un tMage
              y devuelva un entero (1 si mana > 0, 0 si no).
              En el bloque principal declara un mago con mana=20, llama a hasMana y guarda el resultado en estado.
              Implementa la función devolviendo 1 o 0 según corresponda.
            answer: |
              type
                tMage = record
                  mana: integer;
                end record
              end type

              function hasMana(m: tMage): integer
                if m.mana > 0 then
                  return 1;
                else
                  return 0;
                end if
              end function

              algorithm
                var
                  mago: tMage;
                  estado: integer;
                end var

                mago.mana := 20;
                estado := hasMana(mago);
              end algorithm
            hint: Usa un if para devolver 1 o 0 según el maná.

          - id: c-5-l1-funcion-sum-hp
            language: C
            week: 5
            prompt: |
              Declara una estructura tPlayer con los campos:
              - vida: real
              - nivel: entero
              Declara el prototipo e implementa una función totalLife que reciba dos tPlayer
              y devuelva un real con la suma de sus vidas.
            answer: |
              typedef struct {
                  float vida;
                  int nivel;
              } tPlayer;

              float totalLife(tPlayer p1, tPlayer p2);

              float totalLife(tPlayer p1, tPlayer p2) {
                  return p1.vida + p2.vida;
              }
            hint: Los structs pueden pasarse como parámetros en las funciones.

          - id: p-5-l1-funcion-sum-hp
            language: Pseudocode
            week: 5
            prompt: |
              Declara un tipo tPlayer con los campos:
              - vida: real
              - nivel: integer
              Escribe e implementa una función totalLife que reciba dos tPlayer
              y devuelva un real con la suma de sus vidas.
            answer: |
              type
                tPlayer = record
                  vida: real;
                  nivel: integer;
                end record
              end type

              function totalLife(p1: tPlayer, p2: tPlayer): real
                return p1.vida + p2.vida;
              end function
            hint: Usa return para devolver la suma de las vidas.

          - id: c-5-l1-main-attack
            language: C
            week: 5
            prompt: |
              Declara el prototipo de una función llamada attack que reciba dos enteros atk y def
              y devuelva un entero con el daño (atk - def).
              En main declara atk=50 y def=20, llama a attack y guarda el resultado en dmg.
              Implementa la función.
            answer: |
              #include <stdio.h>

              int attack(int atk, int def);

              int main() {
                  int atk = 50;
                  int def = 20;
                  int dmg = attack(atk, def);
                  return 0;
              }

              int attack(int atk, int def) {
                  return atk - def;
              }
            hint: El daño se calcula como ataque menos defensa.

          - id: p-5-l1-main-attack
            language: Pseudocode
            week: 5
            prompt: |
              Escribe el encabezado de una función attack que reciba dos enteros atk y def
              y devuelva un entero con el daño (atk - def).
              En el bloque principal declara atk=50 y def=20, llama a attack y guarda el resultado en dmg.
              Implementa la función.
            answer: |
              function attack(atk: integer, def: integer): integer
                return atk - def;
              end function

              algorithm
                var
                  atk: integer;
                  def: integer;
                  dmg: integer;
                end var

                atk := 50;
                def := 20;
                dmg := attack(atk, def);
              end algorithm
            hint: Usa return para devolver atk - def.

      - number: 2
        explanation:
          C: |
            En este nivel aprenderás a usar **punteros en C**. Los punteros permiten guardar la **dirección de memoria** de una variable, acceder a su contenido, modificarlo, y trabajar con arrays y estructuras de forma más flexible.  
            Son muy útiles en videojuegos para gestionar objetos, personajes y recursos.

            ---
            ### ¿Qué es un puntero?
            Un puntero es una variable que almacena la dirección de otra variable.  
            Para declarar un puntero se usa `*` y para obtener la dirección de una variable se usa `&`.

            ```c
            int score = 500;        // variable normal
            int *pScore = &score;   // puntero que apunta a score
            ```

            ---
            ### Acceso al valor con el operador `*`
            Usando `*` podemos **leer** o **modificar** el valor al que apunta el puntero.

            ```c
            int health = 100;
            int *pHealth = &health;

            *pHealth = 80;  // cambia health a 80
            ```

            ---
            ### Imprimir valores y direcciones
            Con `printf` podemos imprimir el contenido (`%d`) o la dirección (`%p`).

            ```c
            int coins = 250;
            int *pCoins = &coins;

            printf("%d", *pCoins); // imprime 250
            printf("%p", pCoins);  // imprime la dirección de coins
            ```

            ---
            ### Punteros y estructuras
            Un puntero a una estructura permite acceder a sus campos con `->`.

            ```c
            typedef struct {
                int valor;
            } tItem;

            tItem espada = {100};
            tItem *pEspada = &espada;

            printf("%d", pEspada->valor); // imprime 100
            ```

            También se pueden modificar los campos:

            ```c
            typedef struct {
                int hp;
            } tPlayer;

            tPlayer heroe = {120};
            tPlayer *pHeroe = &heroe;

            pHeroe->hp = 200; // cambia hp del héroe a 200
            ```

            ---
            ### Punteros y arrays
            El nombre de un array es equivalente a un puntero a su primer elemento.  
            Podemos recorrerlo o modificarlo usando aritmética de punteros.

            ```c
            int scores[3] = {10, 20, 30};
            int *pScores = scores;

            printf("%d", *(pScores + 1)); // imprime 20
            ```

            Y también modificar elementos:

            ```c
            int inventory[3] = {5, 10, 15};
            int *pInv = inventory;

            *(pInv + 2) = 50; // cambia el tercer valor a 50
            ```

            ---
            ### Ejemplo completo
            ```c
            #include <stdio.h>

            typedef struct {
                int valor;
            } tItem;

            typedef struct {
                int hp;
            } tPlayer;

            int main() {
                // Variable y puntero
                int score = 500;
                int *pScore = &score;

                // Modificación con puntero
                int health = 100;
                int *pHealth = &health;
                *pHealth = 80;

                // Impresión con puntero
                int coins = 250;
                int *pCoins = &coins;
                printf("Coins: %d\n", *pCoins);
                printf("Coins address: %p\n", pCoins);

                // Puntero a struct y acceso
                tItem espada = {100};
                tItem *pEspada = &espada;
                printf("Espada valor: %d\n", pEspada->valor);

                // Modificación de struct
                tPlayer heroe = {120};
                tPlayer *pHeroe = &heroe;
                pHeroe->hp = 200;
                printf("Heroe HP: %d\n", heroe.hp);

                // Array y punteros
                int scores[3] = {10, 20, 30};
                int *pScores = scores;
                printf("Segundo score: %d\n", *(pScores + 1));

                int inventory[3] = {5, 10, 15};
                int *pInv = inventory;
                *(pInv + 2) = 50;
                printf("Tercer valor inventory: %d\n", inventory[2]);

                return 0;
            }
            ```

            Este programa muestra cómo usar punteros para acceder y modificar variables, estructuras y arrays, simulando elementos de un videojuego como vida, inventario o armas.

        questions:
          - id: c-5-l2-pointer-basic
            language: C
            week: 5
            prompt: |
              Declara un entero score con valor 500.
              Declara un puntero pScore que apunte a score.
            answer: |
              #include <stdio.h>

              int main() {
                  int score = 500;
                  int *pScore = &score;
                  return 0;
              }
            hint: Usa * para declarar punteros y & para obtener la dirección.

          - id: c-5-l2-pointer-dereference
            language: C
            week: 5
            prompt: |
              Declara un entero health con valor 100.
              Declara un puntero pHealth que apunte a health.
              Usando el puntero, asigna el valor 80 a health.
            answer: |
              #include <stdio.h>

              int main() {
                  int health = 100;
                  int *pHealth = &health;
                  *pHealth = 80;
                  return 0;
              }
            hint: El operador * permite acceder al valor apuntado.

          - id: c-5-l2-pointer-print
            language: C
            week: 5
            prompt: |
              Declara un entero coins con valor 250.
              Declara un puntero pCoins que apunte a coins.
              Imprime con printf el valor de coins usando el puntero.
            answer: |
              #include <stdio.h>

              int main() {
                  int coins = 250;
                  int *pCoins = &coins;
                  printf("%d", *pCoins);
                  return 0;
              }
            hint: printf muestra el contenido con %d.

          - id: c-5-l2-pointer-address
            language: C
            week: 5
            prompt: |
              Declara un entero stamina con valor 40.
              Declara un puntero pStamina que apunte a stamina.
              Imprime con printf la dirección almacenada en pStamina.
            answer: |
              #include <stdio.h>

              int main() {
                  int stamina = 40;
                  int *pStamina = &stamina;
                  printf("%p", pStamina);
                  return 0;
              }
            hint: Usa %p para imprimir direcciones.

          - id: c-5-l2-pointer-change
            language: C
            week: 5
            prompt: |
              Declara un entero level con valor 3.
              Declara un puntero pLevel que apunte a level.
              Cambia el valor de level a 4 usando el puntero.
            answer: |
              #include <stdio.h>

              int main() {
                  int level = 3;
                  int *pLevel = &level;
                  *pLevel = 4;
                  return 0;
              }
            hint: Con *pLevel accedes al contenido de level.

          - id: c-5-l2-struct-pointer
            language: C
            week: 5
            prompt: |
              Declara una estructura tItem con un campo valor (entero).
              En main declara un objeto pocion con valor=50.
              Declara un puntero pItem que apunte a pocion.
            answer: |
              #include <stdio.h>

              typedef struct {
                  int valor;
              } tItem;

              int main() {
                  tItem pocion = {50};
                  tItem *pItem = &pocion;
                  return 0;
              }
            hint: Para punteros a struct, usa el nombre del tipo seguido de *.

          - id: c-5-l2-struct-pointer-access
            language: C
            week: 5
            prompt: |
              Declara una estructura tItem con un campo valor (entero).
              En main declara un objeto espada con valor=100.
              Declara un puntero pEspada que apunte a espada.
              Imprime el valor usando pEspada con el operador ->.
            answer: |
              #include <stdio.h>

              typedef struct {
                  int valor;
              } tItem;

              int main() {
                  tItem espada = {100};
                  tItem *pEspada = &espada;
                  printf("%d", pEspada->valor);
                  return 0;
              }
            hint: Usa -> para acceder a campos desde un puntero a struct.

          - id: c-5-l2-struct-modify
            language: C
            week: 5
            prompt: |
              Declara una estructura tPlayer con un campo hp (entero).
              En main declara un objeto heroe con hp=120.
              Declara un puntero pHeroe que apunte a heroe.
              Usa el puntero para cambiar hp a 200.
            answer: |
              #include <stdio.h>

              typedef struct {
                  int hp;
              } tPlayer;

              int main() {
                  tPlayer heroe = {120};
                  tPlayer *pHeroe = &heroe;
                  pHeroe->hp = 200;
                  return 0;
              }
            hint: Con -> puedes modificar campos del struct.

          - id: c-5-l2-array-pointer
            language: C
            week: 5
            prompt: |
              Declara un array de enteros scores con valores {10, 20, 30}.
              Declara un puntero pScores que apunte al primer elemento del array.
              Imprime con printf el segundo valor usando el puntero.
            answer: |
              #include <stdio.h>

              int main() {
                  int scores[3] = {10, 20, 30};
                  int *pScores = scores;
                  printf("%d", *(pScores + 1));
                  return 0;
              }
            hint: Los arrays se comportan como punteros al primer elemento.

          - id: c-5-l2-array-pointer-change
            language: C
            week: 5
            prompt: |
              Declara un array de enteros inventory con valores {5, 10, 15}.
              Declara un puntero pInv que apunte al primer elemento.
              Cambia el tercer valor del array a 50 usando el puntero.
            answer: |
              #include <stdio.h>

              int main() {
                  int inventory[3] = {5, 10, 15};
                  int *pInv = inventory;
                  *(pInv + 2) = 50;
                  return 0;
              }
            hint: " *(p + i) accede al elemento i del array. "

      - number: 3
        explanation:
          C: |
            En este nivel aprenderás a trabajar con **acciones (procedimientos)** en C.  
            Una acción es similar a una función, pero **no devuelve un valor**.  
            En videojuegos, las acciones son útiles para mostrar información en pantalla, actualizar la vida de un jugador o aplicar un efecto, sin necesidad de devolver un resultado directo.

            ### ¿Qué es una acción?
            Una **acción** (también llamada procedimiento) es un bloque de código independiente que:
            - Tiene un **nombre** que la identifica.  
            - Puede recibir **parámetros**:  
              - `in` (entrada → solo lectura).  
              - `out` (salida → el valor se escribe dentro del parámetro y afecta a la variable original).  
              - `inout` (entrada/salida → se lee y se modifica, actualizando la variable original).  
            - No devuelve un valor con `return`.  

            ---

            ### Prototipos de acciones (encabezados)
            Igual que en las funciones, se declara el encabezado antes de `main`.  
            Ejemplo:
            ```c
            void mostrarPuntos(int puntos);
            void aplicarBonus(int enemigos, int bonus, int *resultado);       // salida
            void acumularPuntos(int enemigos, int bonus, int *resultado);    // entrada/salida
            ```

            ---

            ### Sintaxis general de una acción
            ```c
            void nombreAccion(tipo parametros) {
                // instrucciones
            }
            ```

            *Se utiliza `void` porque no devuelve ningún valor.*

            ---

            ### Ejemplo en código
            Acción que recibe un parámetro de entrada y lo muestra:
            ```c
            void mostrarPuntos(int puntos) {
                printf("Puntos actuales: %d\n", puntos);
            }
            ```

            ---

            ### Ejemplo completo
            ```c
            #include <stdio.h>

            // Prototipos
            void mostrarPuntos(int puntos);                       // entrada
            void aplicarBonus(int enemigos, int bonus, int *res); // salida
            void acumularPuntos(int enemigos, int bonus, int *res); // entrada/salida

            // main primero
            int main() {
                int puntos;
                int total = 100; // puntos iniciales del jugador

                // Acción de salida: calcula puntos a partir de enemigos y bonus
                aplicarBonus(5, 20, &puntos);
                mostrarPuntos(puntos);

                // Acción de entrada/salida: acumula puntos en el total del jugador
                acumularPuntos(3, 10, &total);
                mostrarPuntos(total);

                return 0;
            }

            // Implementaciones al final
            // Acción de entrada
            void mostrarPuntos(int puntos) {
                printf("Puntos actuales: %d\n", puntos);
            }

            // Acción con parámetro de salida
            void aplicarBonus(int enemigos, int bonus, int *res) {
                int calculo = enemigos * 10 + bonus;
                *res = calculo; // modifica la variable original
            }

            // Acción con parámetro entrada/salida
            void acumularPuntos(int enemigos, int bonus, int *res) {
                int calculo = enemigos * 5 + bonus;
                *res = *res + calculo; // suma al valor original
            }
            ```

            **Qué hace el programa:**  
            - `aplicarBonus` (salida) calcula puntos en base a enemigos derrotados y bonus, guardándolos en una variable.  
            - `mostrarPuntos` (entrada) imprime los puntos actuales del jugador.  
            - `acumularPuntos` (entrada/salida) suma más puntos al total existente.  
            - Se simula cómo un jugador gana puntos por enemigos derrotados y acumula un total.  

          Pseudocode: |
            En este nivel aprenderás a trabajar con **acciones** en pseudocódigo.  
            Una acción es similar a una función, pero **no devuelve un valor**.  
            En videojuegos, las acciones sirven para mostrar mensajes, actualizar variables de juego o aplicar efectos sobre los personajes.

            ### ¿Qué es una acción?
            Una **acción**:
            - Tiene un **nombre** que la identifica.  
            - Puede recibir **parámetros**:  
              - `in` (entrada → solo lectura).  
              - `out` (salida → el valor se escribe dentro del parámetro y afecta a la variable original).  
              - `inout` (entrada/salida → se lee y se modifica, actualizando la variable original).  
            - No devuelve un valor.  

            ---

            ### Sintaxis general de una acción
            ```pseudocode
            action nombreAccion(parametros)
              ...
            end action
            ```

            ---

            ### Ejemplo en pseudocódigo
            Acción de entrada para mostrar puntos:
            ```pseudocode
            action mostrarPuntos(in puntos: integer)
              writeString("Puntos actuales: ");
              writeInteger(puntos);
            end action
            ```

            ---

            ### Ejemplo completo
            ```pseudocode
            { Implementaciones }

            action mostrarPuntos(in puntos: integer)
              writeString("Puntos actuales: ");
              writeInteger(puntos);
            end action

            action aplicarBonus(in enemigos: integer, in bonus: integer, out res: integer)
              var
                calculo: integer;
              end var
              calculo := enemigos * 10 + bonus;
              res := calculo;   { modifica la variable original }
            end action

            action acumularPuntos(in enemigos: integer, in bonus: integer, inout res: integer)
              var
                calculo: integer;
              end var
              calculo := enemigos * 5 + bonus;
              res := res + calculo;   { suma al valor original }
            end action

            algorithm accionesVideojuego
              var
                puntos: integer;
                total: integer;
              end var

              total := 100;  { puntos iniciales }

              aplicarBonus(5, 20, puntos);    { calcula puntos con salida }
              mostrarPuntos(puntos);

              acumularPuntos(3, 10, total);   { acumula puntos en total }
              mostrarPuntos(total);
            end algorithm
            ```

            **Qué hace el programa:**  
            - `aplicarBonus` (salida) calcula los puntos por enemigos derrotados y bonus, y los asigna a una variable.  
            - `mostrarPuntos` (entrada) escribe en pantalla los puntos actuales.  
            - `acumularPuntos` (entrada/salida) suma más puntos al total acumulado del jugador.  
            - Se simula un sistema de puntuación en un videojuego, donde el jugador gana y acumula puntos progresivamente.  
        
          







        questions:
          - id: c-5-l2-action-welcome
            language: C
            week: 5
            prompt: |
              Declara una acción en C llamada showWelcome que no reciba parámetros.
              Dentro de la acción imprime con printf el mensaje "Bienvenido al RPG".
              En main llama a showWelcome.
            answer: |
              #include <stdio.h>

              void showWelcome();

              int main() {
                  showWelcome();
                  return 0;
              }

              void showWelcome() {
                  printf("Bienvenido al RPG\n");
              }
            hint: Una acción en C se define con void, no devuelve valores.

          - id: p-5-l2-action-welcome
            language: Pseudocode
            week: 5
            prompt: |
              Declara una acción llamada showWelcome que no reciba parámetros.
              Dentro de la acción escribe el mensaje "Bienvenido al RPG".
              En el bloque principal llama a showWelcome.
            answer: |
              action showWelcome()
                writeString("Bienvenido al RPG");
              end action

              algorithm
                showWelcome();
              end algorithm
            hint: Una acción no devuelve valores, solo ejecuta instrucciones.

          - id: c-5-l2-action-in-score
            language: C
            week: 5
            prompt: |
              Declara una acción printScore que reciba como entrada un entero score.
              Dentro de la acción muestra con printf "Puntuacion: <score>".
              En main declara un entero score=300 y llama a printScore con esa variable.
            answer: |
              #include <stdio.h>

              void printScore(int score);

              int main() {
                  int score = 300;
                  printScore(score);
                  return 0;
              }

              void printScore(int score) {
                  printf("Puntuacion: %d\n", score);
              }
            hint: Los parámetros de entrada en C se pasan como variables normales.

          - id: p-5-l2-action-in-score
            language: Pseudocode
            week: 5
            prompt: |
              Declara una acción printScore que reciba como entrada un entero score.
              Dentro de la acción escribe el mensaje "Puntuacion: " seguido del valor.
              En el bloque principal declara un entero score=300 y llama a printScore.
            answer: |
              action printScore(in score: integer)
                writeString("Puntuacion: ");
                writeInteger(score);
              end action

              algorithm
                var
                  score: integer;
                end var

                score := 300;
                printScore(score);
              end algorithm
            hint: Usa "in" para los parámetros de entrada.

          - id: c-5-l2-action-out-health
            language: C
            week: 5
            prompt: |
              Declara una acción initHealth que reciba como salida un entero *health.
              Dentro de la acción asigna a *health el valor 100.
              En main declara un entero hp sin inicializar, llama a initHealth con &hp
              y luego muestra hp con printf.
            answer: |
              #include <stdio.h>

              void initHealth(int *health);

              int main() {
                  int hp;
                  initHealth(&hp);
                  printf("%d\n", hp);
                  return 0;
              }

              void initHealth(int *health) {
                  *health = 100;
              }
            hint: Los parámetros de salida en C se pasan como punteros.

          - id: p-5-l2-action-out-health
            language: Pseudocode
            week: 5
            prompt: |
              Declara una acción initHealth que reciba como salida un entero health.
              Dentro de la acción asigna a health el valor 100.
              En el bloque principal declara un entero hp sin inicializar, llama a initHealth con hp
              y luego muestra hp.
            answer: |
              action initHealth(out health: integer)
                health := 100;
              end action

              algorithm
                var
                  hp: integer;
                end var

                initHealth(hp);
                writeInteger(hp);
              end algorithm
            hint: Usa "out" cuando la acción debe inicializar un valor.

          - id: c-5-l2-action-inout-heal
            language: C
            week: 5
            prompt: |
              Declara una acción heal que reciba como entrada/salida un entero *hp.
              Dentro de la acción suma 50 al valor apuntado por hp usando operador compuesto.
              En main declara un entero hp=120, llama a heal con &hp
              y luego imprime el nuevo valor.
            answer: |
              #include <stdio.h>

              void heal(int *hp);

              int main() {
                  int hp = 120;
                  heal(&hp);
                  printf("%d\n", hp);
                  return 0;
              }

              void heal(int *hp) {
                  *hp += 50;
              }
            hint: Usa inout cuando el valor inicial se modifica.

          - id: p-5-l2-action-inout-heal
            language: Pseudocode
            week: 5
            prompt: |
              Declara una acción heal que reciba como entrada/salida un entero hp.
              Dentro de la acción suma 50 al valor de hp.
              En el bloque principal declara hp=120, llama a heal con hp
              y muestra el nuevo valor.
            answer: |
              action heal(inout hp: integer)
                hp := hp + 50;
              end action

              algorithm
                var
                  hp: integer;
                end var

                hp := 120;
                heal(hp);
                writeInteger(hp);
              end algorithm
            hint: Usa "inout" cuando el parámetro se actualiza.

          - id: c-5-l2-action-struct-revive
            language: C
            week: 5
            prompt: |
              Declara una estructura tPlayer con los campos:
              - nombre: texto de 20 chars
              - hp: entero
              Declara una acción revive que reciba como salida un puntero a tPlayer
              y lo inicialice con hp=100 y nombre="Heroe".
              En main declara un jugador sin inicializar y llama a revive.
              Imprime los valores "Nombre: x Hp: x".
            answer: |
              #include <stdio.h>
              #include <string.h>

              typedef struct {
                  char nombre[20];
                  int hp;
              } tPlayer;

              void revive(tPlayer *p);

              int main() {
                  tPlayer jugador;
                  revive(&jugador);
                  printf("Nombre: %s Hp: %d\n", jugador.nombre, jugador.hp);
                  return 0;
              }

              void revive(tPlayer *p) {
                  strcpy(p->nombre, "Heroe");
                  p->hp = 100;
              }
            hint: Con punteros a structs se usa -> para asignar.

          - id: p-5-l2-action-struct-revive
            language: Pseudocode
            week: 5
            prompt: |
              Declara un tipo tPlayer con los campos:
              - nombre: string
              - hp: integer
              Declara una acción revive que reciba un tPlayer por salida
              y lo inicialice con nombre="Heroe" y hp=100.
              En el bloque principal declara un jugador y llama a revive.
              Imprime los valores "Nombre: x Hp: x"
            answer: |
              type
                tPlayer = record
                  nombre: string;
                  hp: integer;
                end record
              end type

              action revive(out p: tPlayer)
                p.nombre := "Heroe";
                p.hp := 100;
              end action

              algorithm
                var
                  jugador: tPlayer;
                end var

                revive(jugador);
                writeString("Nombre: ");
                writeString(jugador.nombre);
                writeString("Hp: ");
                writeInteger(jugador.hp);
              end algorithm
            hint: Usa "out" cuando la acción debe devolver un struct completo.

          - id: c-5-l2-action-array-reset
            language: C
            week: 5
            prompt: |
              Declara una acción resetInventory que reciba como entrada/salida un array de 3 enteros items.
              Dentro de la acción usa un bucle for para poner todos sus valores a 0.
              En main declara el array items con {10,20,30}, llama a resetInventory e imprime los valores separados
              por un espacio "x x x".
            answer: |
              #include <stdio.h>

              void resetInventory(int *items);

              int main() {
                  int items[3] = {10, 20, 30};
                  resetInventory(items);
                  printf("%d %d %d", items[0], items[1], items[2]);
                  return 0;
              }

              void resetInventory(int *items) {
                  for(int i=0; i<3; i++) {
                      items[i] = 0;
                  }
              }
            hint: Los arrays en C se pasan como punteros.

          - id: p-5-l2-action-array-reset
            language: Pseudocode
            week: 5
            prompt: |
              Declara una acción resetInventory que reciba como entrada/salida un array de 3 enteros items.
              Dentro de la acción usa un bucle for que itere 3 veces y ponga en 0 los valores del array.
              En el bloque principal declara items con los valores {10,20,30}, llama a resetInventory
              y muestra los 3 valores "x x x".
            answer: |
              action resetInventory(inout items: array[3] of integer)
                var
                  i: integer;
                end var
              
                for i = 1 to 3 do
                  items[i] := 0;
                end for
              end action

              algorithm
                var
                  items: array[3] of integer;
                end var

                items[1] := 10;
                items[2] := 20;
                items[3] := 30;
              
                resetInventory(items);
              
                writeInteger(items[1]);
                writeInteger(items[2]);
                writeInteger(items[3]);
              end algorithm
            hint: En pseudocódigo los arrays de 3 posiciones se definen como array[3].

          - id: c-5-l2-action-two-in
            language: C
            week: 5
            prompt: |
              Declara una acción showAttack que reciba dos enteros atk y def como entrada.
              Dentro de la acción declara una variable entera total y calcula atk-def.
              Muestra el valor de total con printf.
              En main declara atk=50 y def=20 y llama a showAttack.
            answer: |
              #include <stdio.h>

              void showAttack(int atk, int def);

              int main() {
                  int atk = 50;
                  int def = 20;
                  showAttack(atk, def);
                  return 0;
              }

              void showAttack(int atk, int def) {
                  int total = atk - def;
                  printf("%d", total);
              }
            hint: Puedes pasar más de un parámetro in a la acción.

          - id: p-5-l2-action-two-in
            language: Pseudocode
            week: 5
            prompt: |
              Declara una acción showAttack que reciba dos enteros atk y def como entrada.
              Dentro de la acción declara una variable entera total y calcula atk-def.
              Imprime el valor de total.
              En el bloque principal declara atk=50 y def=20 y llama a showAttack.
            answer: |
              action showAttack(in atk: integer, in def: integer)
                var
                  tota: integer;
                end var
              
                total := atk - def;
                writeInteger(total);
              end action

              algorithm
                var
                  atk: integer;
                  def: integer;
                end var

                atk := 50;
                def := 20;
                showAttack(atk, def);
              end algorithm
            hint: Usa "in" para ambos parámetros.

          - id: c-5-l2-action-in-out
            language: C
            week: 5
            prompt: |
              Declara una acción grantXP que reciba como entrada un entero base
              y como salida un entero *xp.
              Dentro de la acción asigna *xp = base * 10.
              En main declara base=5 y una variable xp, llama a grantXP y muestra xp.
            answer: |
              #include <stdio.h>

              void grantXP(int base, int *xp);

              int main() {
                  int base = 5;
                  int xp;
                  grantXP(base, &xp);
                  printf("%d", xp);
                  return 0;
              }

              void grantXP(int base, int *xp) {
                  *xp = base * 10;
              }
            hint: Combina parámetros in y out.

          - id: p-5-l2-action-in-out
            language: Pseudocode
            week: 5
            prompt: |
              Declara una acción grantXP que reciba como entrada un entero base
              y como salida un entero xp.
              Dentro de la acción asigna xp = base * 10.
              En el bloque principal declara base=5 y xp, llama a grantXP y muestra xp.
            answer: |
              action grantXP(in base: integer, out xp: integer)
                xp := base * 10;
              end action

              algorithm
                var
                  base: integer;
                  xp: integer;
                end var

                base := 5;
                grantXP(base, xp);
                writeInteger(xp);
              end algorithm
            hint: Usa una mezcla de in y out.

          - id: c-5-l2-action-in-inout
            language: C
            week: 5
            prompt: |
              Declara una acción powerUp que reciba como entrada un entero bonus
              y como entrada/salida un entero *atk.
              Dentro de la acción suma bonus al valor apuntado por atk.
              En main declara atk=40 y bonus=15, llama a powerUp y muestra atk.
            answer: |
              #include <stdio.h>

              void powerUp(int bonus, int *atk);

              int main() {
                  int atk = 40;
                  int bonus = 15;
                  powerUp(bonus, &atk);
                  printf("%d", atk);
                  return 0;
              }

              void powerUp(int bonus, int *atk) {
                  *atk = *atk + bonus;
              }
            hint: Combina un parámetro in y uno inout.

          - id: p-5-l2-action-in-inout
            language: Pseudocode
            week: 5
            prompt: |
              Declara una acción powerUp que reciba como entrada un entero bonus
              y como entrada/salida un entero atk.
              Dentro de la acción suma bonus al valor de atk.
              En el bloque principal declara atk=40 y bonus=15, llama a powerUp y muestra atk.
            answer: |
              action powerUp(in bonus: integer, inout atk: integer)
                atk := atk + bonus;
              end action

              algorithm
                var
                  atk: integer;
                  bonus: integer;
                end var

                atk := 40;
                bonus := 15;
                powerUp(bonus, atk);
                writeInteger(atk);
              end algorithm
            hint: Mezcla in y inout en la acción.

          - id: c-5-l2-action-struct-inout
            language: C
            week: 5
            prompt: |
              Declara una estructura tEnemy con el campo hp (entero).
              Declara una acción damage que reciba como entrada un entero dmg
              y como entrada/salida un puntero a tEnemy.
              Dentro de la acción resta dmg a hp.
              En main declara un enemigo con hp= {200}.
              Llama a damage con 30 y enemigo.
              Imprime el valor del hp de enemigo.
            answer: |
              #include <stdio.h>

              typedef struct {
                  int hp;
              } tEnemy;

              void damage(int dmg, tEnemy *e);

              int main() {
                  tEnemy enemigo = {200};
                  damage(30, &enemigo);
                  printf("%d", enemigo.hp);
                  return 0;
              }

              void damage(int dmg, tEnemy *e) {
                  e->hp = e->hp - dmg;
              }
            hint: Usa -> para modificar un struct desde un puntero.

          - id: p-5-l2-action-struct-inout
            language: Pseudocode
            week: 5
            prompt: |
              Declara un tipo tEnemy con el campo hp (entero).
              Declara una acción damage que reciba como entrada un entero dmg
              y como entrada/salida un tEnemy e.
              Dentro de la acción resta dmg al campo hp.
              En el bloque principal declara un enemigo con hp=200.
              Llama a damage con 30 y enemigo.
              Imprime el valor del hp de enemigo.
            answer: |
              type
                tEnemy = record
                  hp: integer;
                end record
              end type

              action damage(in dmg: integer, inout e: tEnemy)
                e.hp := e.hp - dmg;
              end action

              algorithm
                var
                  enemigo: tEnemy;
                end var

                enemigo.hp := 200;
                damage(30, enemigo);
                writeInteger(enemigo.hp);
              end algorithm
            hint: Usa in para dmg y inout para el struct.

  - number: 7
    explanation:
    levels:
      - number: 1
        explanation:
          C: | 
            Explicacion C
          Pseudocode: |
            Explicacion Pseudocode
        questions:
          - id: c-5-l1-table-enemy
            language: C
            week: 5
            prompt: |
              Declara una constante MAX_ENEMIES = 50.
              Declara una estructura tEnemy con los campos:
              - name: texto (usa MAX_NAME = 30)
              - health: entero
              Declara una tabla tEnemyTable con:
              - data: array de MAX_ENEMIES de tEnemy
              - count: entero con el número de enemigos almacenados.
            answer: |
              #define MAX_NAME 30
              #define MAX_ENEMIES 50

              typedef struct {
                  char name[MAX_NAME];
                  int health;
              } tEnemy;

              typedef struct {
                  tEnemy data[MAX_ENEMIES];
                  int count;
              } tEnemyTable;
            hint: Recuerda que una tabla combina el array y un contador.

          - id: p-5-l1-table-enemy
            language: Pseudocode
            week: 5
            prompt: |
              Declara una constante MAX_ENEMIES = 50.
              Declara un tipo tEnemy con los campos:
              - name: string
              - health: integer
              Declara un tipo tEnemyTable con:
              - data: vector[MAX_ENEMIES] de tEnemy
              - count: integer
            answer: |
              const
                MAX_ENEMIES: integer = 50;
              end const

              type
                tEnemy = record
                  name: string;
                  health: integer;
                end record
              end type

              type
                tEnemyTable = record
                  data: vector[MAX_ENEMIES] of tEnemy;
                  count: integer;
                end record
              end type
            hint: La tabla es un record con el array y el contador.

          - id: c-5-l1-init-enemytable
            language: C
            week: 5
            prompt: |
              Declara el prototipo e implementación de una función initEnemyTable que reciba
              un puntero a tEnemyTable y lo inicialice con count = 0.
            answer: |
              void initEnemyTable(tEnemyTable* table);

              void initEnemyTable(tEnemyTable* table) {
                  table->count = 0;
              }
            hint: Usa -> para acceder a count porque es un puntero.

          - id: p-5-l1-init-enemytable
            language: Pseudocode
            week: 5
            prompt: |
              Escribe el encabezado e implementación de una acción initEnemyTable
              que reciba un parámetro de tipo inout tEnemyTable y lo inicialice con count = 0.
            answer: |
              action initEnemyTable(inout table: tEnemyTable)
                table.count := 0;
              end action
            hint: Una acción en pseudocódigo no devuelve valor.

          - id: c-5-l1-table-item
            language: C
            week: 5
            prompt: |
              Declara una constante MAX_ITEMS = 100.
              Declara una estructura tItem con los campos:
              - name: texto (usa MAX_NAME = 30)
              - value: entero
              Declara un tipo tInventory con:
              - data: array de MAX_ITEMS de tItem
              - count: entero
            answer: |
              #define MAX_NAME 30
              #define MAX_ITEMS 100

              typedef struct {
                  char name[MAX_NAME];
                  int value;
              } tItem;

              typedef struct {
                  tItem data[MAX_ITEMS];
                  int count;
              } tInventory;
            hint: El inventario es otra tabla similar a los enemigos.

          - id: p-5-l1-table-item
            language: Pseudocode
            week: 5
            prompt: |
              Declara una constante MAX_ITEMS = 100.
              Declara un tipo tItem con los campos:
              - name: string
              - value: integer
              Declara un tipo tInventory con:
              - data: vector[MAX_ITEMS] de tItem
              - count: integer
            answer: |
              const
                MAX_ITEMS: integer = 100;
              end const

              type
                tItem = record
                  name: string;
                  value: integer;
                end record
              end type

              type
                tInventory = record
                  data: vector[MAX_ITEMS] of tItem;
                  count: integer;
                end record
              end type
            hint: Las tablas siempre combinan vector y contador.

          - id: c-5-l1-main-init-inventory
            language: C
            week: 5
            prompt: |
              Declara el prototipo e implementación de una función initInventory que ponga count=0.
              En main declara una variable inv de tipo tInventory, inicialízala con initInventory
              y devuelve 0.
            answer: |
              void initInventory(tInventory* inv);

              void initInventory(tInventory* inv) {
                  inv->count = 0;
              }

              int main() {
                  tInventory inv;
                  initInventory(&inv);
                  return 0;
              }
            hint: Pasa la dirección de inv al llamar a initInventory.

          - id: p-5-l1-main-init-inventory
            language: Pseudocode
            week: 5
            prompt: |
              Escribe la acción initInventory que ponga count=0 en un tInventory.
              En el bloque principal declara una variable inv de tipo tInventory
              e inicialízala llamando a initInventory.
            answer: |
              action initInventory(inout inv: tInventory)
                inv.count := 0;
              end action

              algorithm
                var
                  inv: tInventory;
                end var

                initInventory(inv);
              end algorithm
            hint: Pasa inv como inout para que se inicialice.

          - id: c-5-l1-table-player
            language: C
            week: 5
            prompt: |
              Declara una constante MAX_PLAYERS = 20.
              Declara una estructura tPlayer con:
              - username: texto (usa MAX_NAME = 30)
              - level: entero
              Declara una tabla tPlayerTable con:
              - data: array de MAX_PLAYERS de tPlayer
              - count: entero
              En main declara un tPlayerTable players y pon count=0.
            answer: |
              #define MAX_NAME 30
              #define MAX_PLAYERS 20

              typedef struct {
                  char username[MAX_NAME];
                  int level;
              } tPlayer;

              typedef struct {
                  tPlayer data[MAX_PLAYERS];
                  int count;
              } tPlayerTable;

              int main() {
                  tPlayerTable players;
                  players.count = 0;
                  return 0;
              }
            hint: La inicialización directa se hace con .count = 0.

          - id: p-5-l1-table-player
            language: Pseudocode
            week: 5
            prompt: |
              Declara una constante MAX_PLAYERS = 20.
              Declara un tipo tPlayer con:
              - username: string
              - level: integer
              Declara un tipo tPlayerTable con:
              - data: vector[MAX_PLAYERS] de tPlayer
              - count: integer
              En el bloque principal declara un tPlayerTable players y pon count=0.
            answer: |
              const
                MAX_PLAYERS: integer = 20;
              end const

              type
                tPlayer = record
                  username: string;
                  level: integer;
                end record
              end type

              type
                tPlayerTable = record
                  data: vector[MAX_PLAYERS] of tPlayer;
                  count: integer;
                end record
              end type

              algorithm
                var
                  players: tPlayerTable;
                end var

                players.count := 0;
              end algorithm
            hint: Se inicializa el contador a 0 en el bloque principal.

          - id: c-5-l1-table-weapon
            language: C
            week: 5
            prompt: |
              Declara una constante MAX_WEAPONS = 40.
              Declara un enum tWeaponType con los valores SWORD, BOW y STAFF.
              Declara un struct tWeapon con:
              - name: texto (usa MAX_NAME = 30)
              - type: tWeaponType
              Declara una tabla tWeaponTable con data[MAX_WEAPONS] y count.
            answer: |
              #define MAX_NAME 30
              #define MAX_WEAPONS 40

              typedef enum { SWORD, BOW, STAFF } tWeaponType;

              typedef struct {
                  char name[MAX_NAME];
                  tWeaponType type;
              } tWeapon;

              typedef struct {
                  tWeapon data[MAX_WEAPONS];
                  int count;
              } tWeaponTable;
            hint: Un enum se define antes de usarlo dentro del struct.

          - id: p-5-l1-table-weapon
            language: Pseudocode
            week: 5
            prompt: |
              Declara una constante MAX_WEAPONS = 40.
              Declara un tipo enumerado tWeaponType con valores SWORD, BOW y STAFF.
              Declara un tipo tWeapon con:
              - name: string
              - type: tWeaponType
              Declara un tipo tWeaponTable con:
              - data: vector[MAX_WEAPONS] de tWeapon
              - count: integer
            answer: |
              const
                MAX_WEAPONS: integer = 40;
              end const

              type
                tWeaponType = { SWORD, BOW, STAFF };
              end type

              type
                tWeapon = record
                  name: string;
                  type: tWeaponType;
                end record
              end type

              type
                tWeaponTable = record
                  data: vector[MAX_WEAPONS] of tWeapon;
                  count: integer;
                end record
              end type
            hint: Recuerda cerrar cada tipo con end type.

          - id: c-5-l1-init-weapon-main
            language: C
            week: 5
            prompt: |
              Declara la función initWeaponTable que inicialice count=0 en un tWeaponTable.
              En main declara una variable armas de tipo tWeaponTable e inicialízala con initWeaponTable.
            answer: |
              void initWeaponTable(tWeaponTable* table);

              void initWeaponTable(tWeaponTable* table) {
                  table->count = 0;
              }

              int main() {
                  tWeaponTable armas;
                  initWeaponTable(&armas);
                  return 0;
              }
            hint: Se pasa la dirección de la tabla con &.

          - id: p-5-l1-init-weapon-main
            language: Pseudocode
            week: 5
            prompt: |
              Declara la acción initWeaponTable que inicialice count=0 en un tWeaponTable.
              En el bloque principal declara una variable armas de tipo tWeaponTable e inicialízala con initWeaponTable.
            answer: |
              action initWeaponTable(inout table: tWeaponTable)
                table.count := 0;
              end action

              algorithm
                var
                  armas: tWeaponTable;
                end var

                initWeaponTable(armas);
              end algorithm
            hint: En pseudocódigo las acciones se llaman igual que en C.

          - id: c-5-l1-table-npc
            language: C
            week: 5
            prompt: |
              Declara una constante MAX_NPCS = 60.
              Declara una estructura tNPC con:
              - name: texto (usa MAX_NAME = 30)
              - dialogue: texto (usa MAX_MSG = 100)
              Declara una tabla tNPCTable con:
              - data: array[MAX_NPCS] de tNPC
              - count: entero
            answer: |
              #define MAX_NAME 30
              #define MAX_MSG 100
              #define MAX_NPCS 60

              typedef struct {
                  char name[MAX_NAME];
                  char dialogue[MAX_MSG];
              } tNPC;

              typedef struct {
                  tNPC data[MAX_NPCS];
                  int count;
              } tNPCTable;
            hint: Cada NPC tiene nombre y diálogo como strings.

          - id: p-5-l1-table-npc
            language: Pseudocode
            week: 5
            prompt: |
              Declara una constante MAX_NPCS = 60.
              Declara un tipo tNPC con:
              - name: string
              - dialogue: string
              Declara un tipo tNPCTable con:
              - data: vector[MAX_NPCS] de tNPC
              - count: integer
            answer: |
              const
                MAX_NPCS: integer = 60;
              end const

              type
                tNPC = record
                  name: string;
                  dialogue: string;
                end record
              end type

              type
                tNPCTable = record
                  data: vector[MAX_NPCS] of tNPC;
                  count: integer;
                end record
              end type
            hint: Un NPC tiene cadenas de texto como atributos.
          - id: c-5-l1-table-quest
            language: C
            week: 5
            prompt: |
              Declara una constante MAX_QUESTS = 25.
              Declara una estructura tQuest con:
              - title: texto (usa MAX_NAME = 30)
              - reward: entero
              Declara una tabla tQuestTable con:
              - data: array[MAX_QUESTS] de tQuest
              - count: entero
              En main declara una variable quests de tipo tQuestTable e inicialízala poniendo count=0.
            answer: |
              #define MAX_NAME 30
              #define MAX_QUESTS 25

              typedef struct {
                  char title[MAX_NAME];
                  int reward;
              } tQuest;

              typedef struct {
                  tQuest data[MAX_QUESTS];
                  int count;
              } tQuestTable;

              int main() {
                  tQuestTable quests;
                  quests.count = 0;
                  return 0;
              }
            hint: La inicialización directa de count se hace en main.

          - id: p-5-l1-table-quest
            language: Pseudocode
            week: 5
            prompt: |
              Declara una constante MAX_QUESTS = 25.
              Declara un tipo tQuest con:
              - title: string
              - reward: integer
              Declara un tipo tQuestTable con:
              - data: vector[MAX_QUESTS] de tQuest
              - count: integer
              En el bloque principal declara una variable quests de tipo tQuestTable e inicialízala poniendo count=0.
            answer: |
              const
                MAX_QUESTS: integer = 25;
              end const

              type
                tQuest = record
                  title: string;
                  reward: integer;
                end record
              end type

              type
                tQuestTable = record
                  data: vector[MAX_QUESTS] of tQuest;
                  count: integer;
                end record
              end type

              algorithm
                var
                  quests: tQuestTable;
                end var

                quests.count := 0;
              end algorithm
            hint: El contador siempre comienza en 0 al declarar la tabla.

          - id: c-5-l1-table-boss
            language: C
            week: 5
            prompt: |
              Declara una constante MAX_BOSSES = 10.
              Declara una estructura tBoss con:
              - name: texto (usa MAX_NAME = 30)
              - hp: real
              - stage: entero
              Declara una tabla tBossTable con:
              - data: array[MAX_BOSSES] de tBoss
              - count: entero
              Declara e implementa una función initBossTable que reciba un puntero a tBossTable
              e inicialice count=0.
            answer: |
              #define MAX_NAME 30
              #define MAX_BOSSES 10

              typedef struct {
                  char name[MAX_NAME];
                  float hp;
                  int stage;
              } tBoss;

              typedef struct {
                  tBoss data[MAX_BOSSES];
                  int count;
              } tBossTable;

              void initBossTable(tBossTable* table);

              void initBossTable(tBossTable* table) {
                  table->count = 0;
              }
            hint: Usa float para hp porque es un valor decimal.

          - id: p-5-l1-table-boss
            language: Pseudocode
            week: 5
            prompt: |
              Declara una constante MAX_BOSSES = 10.
              Declara un tipo tBoss con:
              - name: string
              - hp: real
              - stage: integer
              Declara un tipo tBossTable con:
              - data: vector[MAX_BOSSES] de tBoss
              - count: integer
              Declara e implementa una acción initBossTable que reciba un inout tBossTable
              e inicialice count=0.
            answer: |
              const
                MAX_BOSSES: integer = 10;
              end const

              type
                tBoss = record
                  name: string;
                  hp: real;
                  stage: integer;
                end record
              end type

              type
                tBossTable = record
                  data: vector[MAX_BOSSES] of tBoss;
                  count: integer;
                end record
              end type

              action initBossTable(inout table: tBossTable)
                table.count := 0;
              end action
            hint: La acción no devuelve nada, solo modifica la tabla.

      - number: 2
        explanation:
          C:
          Pseudocode:
        questions:
          # =====================================================
          # BLOQUE 1: INSERCIÓN (3 pares)
          # =====================================================

          - id: c-5-l2-insert-skill
            language: C
            week: 5
            prompt: |
              Declara una constante MAX_SKILLS = 30 y MAX_NAME = 30.
              Declara una estructura tSkill con:
              - name: texto
              - level: entero
              Declara una tabla tSkillTable con:
              - data: array[MAX_SKILLS] de tSkill
              - count: entero
              Implementa la función addSkill que reciba un puntero a tSkillTable (table)
              y un tSkill (s), lo inserte al final de la tabla y aumente count.
            answer: |
              #include <string.h>
              #define MAX_NAME 30
              #define MAX_SKILLS 30

              typedef struct {
                  char name[MAX_NAME];
                  int level;
              } tSkill;

              typedef struct {
                  tSkill data[MAX_SKILLS];
                  int count;
              } tSkillTable;

              void addSkill(tSkillTable* table, tSkill s) {
                  table->data[table->count] = s;
                  table->count++;
              }
            hint: Inserta al final usando table->count como índice.

          - id: p-5-l2-insert-skill
            language: Pseudocode
            week: 5
            prompt: |
              Declara una constante MAX_SKILLS = 30.
              Declara un tipo tSkill con:
              - name: string
              - level: integer
              Declara un tipo tSkillTable con:
              - data: vector[MAX_SKILLS] de tSkill
              - count: integer
              Implementa una acción addSkill que reciba un inout tSkillTable (table)
              y un tSkill (s), lo inserte al final de la tabla y aumente count.
            answer: |
              const
                MAX_SKILLS: integer = 30;
              end const

              type
                tSkill = record
                  name: string;
                  level: integer;
                end record
              end type

              type
                tSkillTable = record
                  data: vector[MAX_SKILLS] of tSkill;
                  count: integer;
                end record
              end type

              action addSkill(inout table: tSkillTable, in s: tSkill)
                table.data[table.count + 1] := s;
                table.count := table.count + 1;
              end action
            hint: En pseudocódigo los índices empiezan en 1.

          - id: c-5-l2-insert-potion
            language: C
            week: 5
            prompt: |
              Declara una constante MAX_POTIONS = 50 y MAX_NAME = 30.
              Declara un struct tPotion con:
              - name: texto
              - power: real
              Declara una tabla tPotionTable con data[MAX_POTIONS] y count.
              Implementa la función addPotion que reciba un puntero a tPotionTable (table)
              y un tPotion (p), lo inserte al final y aumente count.
            answer: |
              #define MAX_NAME 30
              #define MAX_POTIONS 50

              typedef struct {
                  char name[MAX_NAME];
                  float power;
              } tPotion;

              typedef struct {
                  tPotion data[MAX_POTIONS];
                  int count;
              } tPotionTable;

              void addPotion(tPotionTable* table, tPotion p) {
                  table->data[table->count] = p;
                  table->count++;
              }
            hint: Usa float para power.

          - id: p-5-l2-insert-potion
            language: Pseudocode
            week: 5
            prompt: |
              Declara una constante MAX_POTIONS = 50.
              Declara un tipo tPotion con:
              - name: string
              - power: real
              Declara un tipo tPotionTable con data[MAX_POTIONS] y count.
              Implementa una acción addPotion que reciba un inout tPotionTable (table)
              y un tPotion (p), lo inserte al final y aumente count.
            answer: |
              const
                MAX_POTIONS: integer = 50;
              end const

              type
                tPotion = record
                  name: string;
                  power: real;
                end record
              end type

              type
                tPotionTable = record
                  data: vector[MAX_POTIONS] of tPotion;
                  count: integer;
                end record
              end type

              action addPotion(inout table: tPotionTable, in p: tPotion)
                table.data[table.count + 1] := p;
                table.count := table.count + 1;
              end action
            hint: Recuerda aumentar count tras insertar.

          - id: c-5-l2-insert-achievement
            language: C
            week: 5
            prompt: |
              Declara una constante MAX_ACHIEVEMENTS = 40 y MAX_NAME = 30.
              Declara un struct tAchievement con:
              - title: texto
              - points: entero
              Declara un tAchievementTable con data[MAX_ACHIEVEMENTS] y count.
              Implementa la función addAchievement que reciba un puntero a tAchievementTable (table)
              y un tAchievement (a), lo inserte al final y aumente count.
            answer: |
              #define MAX_NAME 30
              #define MAX_ACHIEVEMENTS 40

              typedef struct {
                  char title[MAX_NAME];
                  int points;
              } tAchievement;

              typedef struct {
                  tAchievement data[MAX_ACHIEVEMENTS];
                  int count;
              } tAchievementTable;

              void addAchievement(tAchievementTable* table, tAchievement a) {
                  table->data[table->count] = a;
                  table->count++;
              }
            hint: Similar a insertar skills o potions.

          - id: p-5-l2-insert-achievement
            language: Pseudocode
            week: 5
            prompt: |
              Declara una constante MAX_ACHIEVEMENTS = 40.
              Declara un tipo tAchievement con:
              - title: string
              - points: integer
              Declara un tipo tAchievementTable con data[MAX_ACHIEVEMENTS] y count.
              Implementa una acción addAchievement que reciba un inout tAchievementTable (table)
              y un tAchievement (a), lo inserte al final y aumente count.
            answer: |
              const
                MAX_ACHIEVEMENTS: integer = 40;
              end const

              type
                tAchievement = record
                  title: string;
                  points: integer;
                end record
              end type

              type
                tAchievementTable = record
                  data: vector[MAX_ACHIEVEMENTS] of tAchievement;
                  count: integer;
                end record
              end type

              action addAchievement(inout table: tAchievementTable, in a: tAchievement)
                table.data[table.count + 1] := a;
                table.count := table.count + 1;
              end action
            hint: No olvides incrementar el contador.

          # =====================================================
          # BLOQUE 2: BÚSQUEDA LINEAL (3 pares)
          # =====================================================

          - id: c-5-l2-search-skill
            language: C
            week: 5
            prompt: |
              Implementa la función searchSkill que reciba un tSkillTable (table) y un nombre (name),
              y devuelva la posición en el array (o -1 si no existe).
              Usa un while con booleano found, inicializa pos=-1, i=0.
            answer: |
              #include <stdbool.h>
              #include <string.h>

              int searchSkill(tSkillTable table, const char* name) {
                  int i = 0;
                  int pos = -1;
                  bool found = false;
                  while(i < table.count && !found) {
                      if(strcmp(table.data[i].name, name) == 0) {
                          pos = i;
                          found = true;
                      } else {
                          i++;
                      }
                  }
                  return pos;
              }
            hint: Sigue el esquema de búsqueda lineal de la teoría.

          - id: p-5-l2-search-skill
            language: Pseudocode
            week: 5
            prompt: |
              Implementa una función searchSkill que reciba un tSkillTable (table) y un string (name),
              y devuelva un integer con la posición encontrada o -1 si no existe.
              Usa un while con variable booleana found, inicializa pos=-1, i=1.
            answer: |
              function searchSkill(table: tSkillTable, name: string): integer
                var
                  i: integer;
                  pos: integer;
                  found: boolean;
                end var

                i := 1;
                pos := -1;
                found := false;

                while i ≤ table.count and not found do
                  if table.data[i].name = name then
                    pos := i;
                    found := true;
                  else
                    i := i + 1;
                  end if
                end while

                return pos;
              end function
            hint: Recuerda que los índices en pseudocódigo comienzan en 1.

          - id: c-5-l2-search-potion
            language: C
            week: 5
            prompt: |
              Implementa la función searchPotion que reciba un tPotionTable (table) y un real power,
              y devuelva la posición encontrada o -1 si no existe.
              Usa while con booleano found.
            answer: |
              #include <stdbool.h>

              int searchPotion(tPotionTable table, float power) {
                  int i = 0;
                  int pos = -1;
                  bool found = false;
                  while(i < table.count && !found) {
                      if(table.data[i].power == power) {
                          pos = i;
                          found = true;
                      } else {
                          i++;
                      }
                  }
                  return pos;
              }
            hint: Inicializa pos en -1 como valor por defecto.

          - id: p-5-l2-search-potion
            language: Pseudocode
            week: 5
            prompt: |
              Implementa una función searchPotion que reciba un tPotionTable (table) y un real (power),
              y devuelva un integer con la posición encontrada o -1 si no existe.
              Usa el esquema de búsqueda lineal con while y booleano found.
            answer: |
              function searchPotion(table: tPotionTable, power: real): integer
                var
                  i: integer;
                  pos: integer;
                  found: boolean;
                end var

                i := 1;
                pos := -1;
                found := false;

                while i ≤ table.count and not found do
                  if table.data[i].power = power then
                    pos := i;
                    found := true;
                  else
                    i := i + 1;
                  end if
                end while

                return pos;
              end function
            hint: Usa pos=-1 como valor inicial de no encontrado.

          - id: c-5-l2-search-achievement
            language: C
            week: 5
            prompt: |
              Implementa la función searchAchievement que reciba un tAchievementTable (table) y un integer points,
              y devuelva la posición de un logro con esos puntos o -1 si no existe.
              Usa while con booleano found.
            answer: |
              #include <stdbool.h>

              int searchAchievement(tAchievementTable table, int points) {
                  int i = 0;
                  int pos = -1;
                  bool found = false;
                  while(i < table.count && !found) {
                      if(table.data[i].points == points) {
                          pos = i;
                          found = true;
                      } else {
                          i++;
                      }
                  }
                  return pos;
              }
            hint: Devuelve -1 si no encuentra el valor buscado.

          - id: p-5-l2-search-achievement
            language: Pseudocode
            week: 5
            prompt: |
              Implementa una función searchAchievement que reciba un tAchievementTable (table) y un integer (points),
              y devuelva un integer con la posición encontrada o -1 si no existe.
              Usa while con booleano found.
            answer: |
              function searchAchievement(table: tAchievementTable, points: integer): integer
                var
                  i: integer;
                  pos: integer;
                  found: boolean;
                end var

                i := 1;
                pos := -1;
                found := false;

                while i ≤ table.count and not found do
                  if table.data[i].points = points then
                    pos := i;
                    found := true;
                  else
                    i := i + 1;
                  end if
                end while

                return pos;
              end function
            hint: Usa el esquema de búsqueda lineal de la teoría.

          # =====================================================
          # BLOQUE 3: ELIMINACIÓN (3 pares)
          # =====================================================

          - id: c-5-l2-delete-skill
            language: C
            week: 5
            prompt: |
              Implementa la función deleteSkill que reciba un puntero a tSkillTable (table) y un string (name).
              Primero busca el nombre con searchSkill. Si se encuentra, desplaza los elementos a la izquierda
              y disminuye count en 1.
            answer: |
              void deleteSkill(tSkillTable* table, const char* name) {
                  int pos = searchSkill(*table, name);
                  if(pos != -1) {
                      for(int i = pos; i < table->count - 1; i++) {
                          table->data[i] = table->data[i+1];
                      }
                      table->count--;
                  }
              }
            hint: Desplaza todos los elementos posteriores una posición a la izquierda.

          - id: p-5-l2-delete-skill
            language: Pseudocode
            week: 5
            prompt: |
              Implementa una acción deleteSkill que reciba un inout tSkillTable (table) y un string (name).
              Primero busca con searchSkill. Si se encuentra, desplaza todos los elementos a la izquierda
              y reduce count en 1.
            answer: |
              action deleteSkill(inout table: tSkillTable, in name: string)
                var
                  pos: integer;
                  i: integer;
                end var

                pos := searchSkill(table, name);

                if pos ≠ -1 then
                  for i := pos to table.count - 1 do
                    table.data[i] := table.data[i+1];
                  end for
                  table.count := table.count - 1;
                end if
              end action
            hint: Sigue el patrón de la teoría para eliminación.

          - id: c-5-l2-delete-potion
            language: C
            week: 5
            prompt: |
              Implementa la función deletePotion que reciba un puntero a tPotionTable (table) y un real (power).
              Usa searchPotion. Si encuentra el elemento, desplaza hacia la izquierda
              y reduce count en 1.
            answer: |
              void deletePotion(tPotionTable* table, float power) {
                  int pos = searchPotion(*table, power);
                  if(pos != -1) {
                      for(int i = pos; i < table->count - 1; i++) {
                          table->data[i] = table->data[i+1];
                      }
                      table->count--;
                  }
              }
            hint: Usa la búsqueda antes de eliminar.

          - id: p-5-l2-delete-potion
            language: Pseudocode
            week: 5
            prompt: |
              Implementa una acción deletePotion que reciba un inout tPotionTable (table) y un real (power).
              Usa searchPotion. Si existe, mueve todos los elementos a la izquierda desde pos
              y reduce count en 1.
            answer: |
              action deletePotion(inout table: tPotionTable, in power: real)
                var
                  pos: integer;
                  i: integer;
                end var

                pos := searchPotion(table, power);

                if pos ≠ -1 then
                  for i := pos to table.count - 1 do
                    table.data[i] := table.data[i+1];
                  end for
                  table.count := table.count - 1;
                end if
              end action
            hint: Elimina compactando la tabla.

          - id: c-5-l2-delete-achievement
            language: C
            week: 5
            prompt: |
              Implementa la función deleteAchievement que reciba un puntero a tAchievementTable (table) y un integer (points).
              Usa searchAchievement. Si se encuentra, desplaza hacia la izquierda
              y reduce count en 1.
            answer: |
              void deleteAchievement(tAchievementTable* table, int points) {
                  int pos = searchAchievement(*table, points);
                  if(pos != -1) {
                      for(int i = pos; i < table->count - 1; i++) {
                          table->data[i] = table->data[i+1];
                      }
                      table->count--;
                  }
              }
            hint: Desplaza desde la posición encontrada hasta el final.

          - id: p-5-l2-delete-achievement
            language: Pseudocode
            week: 5
            prompt: |
              Implementa una acción deleteAchievement que reciba un inout tAchievementTable (table) y un integer (points).
              Usa searchAchievement. Si existe, desplaza a la izquierda los elementos posteriores
              y reduce count en 1.
            answer: |
              action deleteAchievement(inout table: tAchievementTable, in points: integer)
                var
                  pos: integer;
                  i: integer;
                end var

                pos := searchAchievement(table, points);

                if pos ≠ -1 then
                  for i := pos to table.count - 1 do
                    table.data[i] := table.data[i+1];
                  end for
                  table.count := table.count - 1;
                end if
              end action
            hint: El contador se decrementa al final.

          # =====================================================
          # BLOQUE 4: RECORRIDO (1 par)
          # =====================================================

          - id: c-5-l2-traverse-skill-sum
            language: C
            week: 5
            prompt: |
              Implementa la función sumSkillLevels que reciba un tSkillTable (table)
              y devuelva la suma de todos los niveles de las habilidades.
              Usa un for desde 0 hasta count-1.
            answer: |
              int sumSkillLevels(tSkillTable table) {
                  int i;
                  int total = 0;
                  for(i = 0; i < table.count; i++) {
                      total = total + table.data[i].level;
                  }
                  return total;
              }
            hint: El esquema de recorrido es con for porque sabemos count.

          - id: p-5-l2-traverse-skill-sum
            language: Pseudocode
            week: 5
            prompt: |
              Implementa una función sumSkillLevels que reciba un tSkillTable (table)
              y devuelva un integer con la suma de todos los niveles.
              Usa un for de 1 hasta count.
            answer: |
              function sumSkillLevels(table: tSkillTable): integer
                var
                  i: integer;
                  total: integer;
                end var

                total := 0;

                for i := 1 to table.count do
                  total := total + table.data[i].level;
                end for

                return total;
              end function
            hint: En pseudocódigo el recorrido va de 1 a count.







